Directory Structure:

└── ./
    ├── bulkwriter
    │   ├── bulk_import_test.go
    │   └── bulk_import.go
    ├── column
    │   ├── array_test.go
    │   ├── array.go
    │   ├── columns_test.go
    │   ├── columns.go
    │   ├── conversion.go
    │   ├── dynamic_test.go
    │   ├── dynamic.go
    │   ├── generic_base_test.go
    │   ├── generic_base.go
    │   ├── json_test.go
    │   ├── json.go
    │   ├── nullable_test.go
    │   ├── nullable.go
    │   ├── scalar_test.go
    │   ├── scalar.go
    │   ├── sparse_test.go
    │   ├── sparse.go
    │   ├── vector_test.go
    │   └── vector.go
    ├── common
    │   ├── version_test.go
    │   └── version.go
    ├── entity
    │   ├── alias.go
    │   ├── analyzer.go
    │   ├── collection_attr_test.go
    │   ├── collection_attr.go
    │   ├── collection.go
    │   ├── common.go
    │   ├── database.go
    │   ├── field_test.go
    │   ├── field.go
    │   ├── function_test.go
    │   ├── function.go
    │   ├── load_state.go
    │   ├── privilege_group.go
    │   ├── rbac.go
    │   ├── resource_group.go
    │   ├── schema_example_test.go
    │   ├── schema_test.go
    │   ├── schema.go
    │   ├── segment.go
    │   ├── sparse_test.go
    │   ├── sparse.go
    │   ├── vectors_test.go
    │   └── vectors.go
    ├── index
    │   ├── ann_param_test.go
    │   ├── ann_param.go
    │   ├── auto_example_test.go
    │   ├── auto.go
    │   ├── common.go
    │   ├── disk_ann.go
    │   ├── flat.go
    │   ├── gpu.go
    │   ├── hnsw.go
    │   ├── index_test.go
    │   ├── index.go
    │   ├── ivf.go
    │   ├── json_test.go
    │   ├── json.go
    │   ├── scalar_test.go
    │   ├── scalar.go
    │   ├── scann.go
    │   └── sparse.go
    ├── milvusclient
    │   ├── admin_test.go
    │   ├── admin.go
    │   ├── alias_example_test.go
    │   ├── alias_options.go
    │   ├── alias_test.go
    │   ├── alias.go
    │   ├── client_config.go
    │   ├── client_suite_test.go
    │   ├── client_test.go
    │   ├── client.go
    │   ├── collection_example_test.go
    │   ├── collection_options.go
    │   ├── collection_test.go
    │   ├── collection.go
    │   ├── common_test.go
    │   ├── common.go
    │   ├── database_example_test.go
    │   ├── database_options.go
    │   ├── database_test.go
    │   ├── database.go
    │   ├── doc.go
    │   ├── index_example_test.go
    │   ├── index_options.go
    │   ├── index_test.go
    │   ├── index.go
    │   ├── interceptors_test.go
    │   ├── interceptors.go
    │   ├── maintenance_example_test.go
    │   ├── maintenance_options.go
    │   ├── maintenance_test.go
    │   ├── maintenance.go
    │   ├── mock_milvus_server_test.go
    │   ├── partition_example_test.go
    │   ├── partition_options.go
    │   ├── partition_test.go
    │   ├── partition.go
    │   ├── rbac_example_test.go
    │   ├── rbac_options.go
    │   ├── rbac_test.go
    │   ├── rbac_v2.go
    │   ├── rbac.go
    │   ├── read_example_test.go
    │   ├── read_option_test.go
    │   ├── read_options.go
    │   ├── read_test.go
    │   ├── read.go
    │   ├── reranker_test.go
    │   ├── reranker.go
    │   ├── resource_group_example_test.go
    │   ├── resource_group_option.go
    │   ├── resource_group_test.go
    │   ├── resource_group.go
    │   ├── results_test.go
    │   ├── results.go
    │   ├── write_example_test.go
    │   ├── write_option_test.go
    │   ├── write_options.go
    │   ├── write_test.go
    │   └── write.go
    ├── row
    │   ├── data_test.go
    │   ├── data.go
    │   ├── schema_test.go
    │   ├── schema.go
    │   └── type.go
    ├── ruleguard
    │   └── rules.go
    ├── .golangci.yml
    ├── go.mod
    ├── go.sum
    ├── Makefile
    ├── OWNERS
    └── README.md



---
File: /bulkwriter/bulk_import_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bulkwriter

import (
	"context"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"github.com/stretchr/testify/suite"
)

type BulkImportSuite struct {
	suite.Suite
}

func (s *BulkImportSuite) TestBulkImport() {
	s.Run("normal_case", func() {
		svr := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
			authHeader := req.Header.Get("Authorization")
			s.Equal("Bearer root:Milvus", authHeader)
			s.True(strings.Contains(req.URL.Path, "/v2/vectordb/jobs/import/create"))
			rw.Write([]byte(`{"status":0, "data":{"jobId": "123"}}`))
		}))
		defer svr.Close()

		resp, err := BulkImport(context.Background(),
			NewBulkImportOption(svr.URL, "hello_milvus", [][]string{{"files/a.json", "files/b.json"}}).
				WithPartition("_default").
				WithOption("backup", "true").
				WithAPIKey("root:Milvus"),
		)
		s.NoError(err)
		s.EqualValues(0, resp.Status)
		s.Equal("123", resp.Data.JobID)
	})

	s.Run("svr_error", func() {
		svr := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
			// rw.
			rw.WriteHeader(http.StatusInternalServerError)
			rw.Write([]byte(`interal server error`))
		}))
		defer svr.Close()

		_, err := BulkImport(context.Background(), NewBulkImportOption(svr.URL, "hello_milvus", [][]string{{"files/a.json", "files/b.json"}}))
		s.Error(err)
	})

	s.Run("status_error", func() {
		svr := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
			s.True(strings.Contains(req.URL.Path, "/v2/vectordb/jobs/import/create"))
			rw.Write([]byte(`{"status":1100, "message": "import job failed"}`))
		}))
		defer svr.Close()

		_, err := BulkImport(context.Background(), NewBulkImportOption(svr.URL, "hello_milvus", [][]string{{"files/a.json", "files/b.json"}}))
		s.Error(err)
	})

	s.Run("server_closed", func() {
		svr2 := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {}))
		svr2.Close()
		_, err := BulkImport(context.Background(), NewBulkImportOption(svr2.URL, "hello_milvus", [][]string{{"files/a.json", "files/b.json"}}))
		s.Error(err)
	})
}

func (s *BulkImportSuite) TestListImportJobs() {
	s.Run("normal_case", func() {
		svr := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
			authHeader := req.Header.Get("Authorization")
			s.Equal("Bearer root:Milvus", authHeader)
			s.True(strings.Contains(req.URL.Path, "/v2/vectordb/jobs/import/list"))
			rw.Write([]byte(`{"status":0, "data":{"records": [{"jobID": "abc", "collectionName": "hello_milvus", "state":"Importing", "progress": 50}]}}`))
		}))
		defer svr.Close()

		resp, err := ListImportJobs(context.Background(),
			NewListImportJobsOption(svr.URL, "hello_milvus").
				WithPageSize(10).
				WithCurrentPage(1).
				WithAPIKey("root:Milvus"),
		)
		s.NoError(err)
		s.EqualValues(0, resp.Status)
		if s.Len(resp.Data.Records, 1) {
			record := resp.Data.Records[0]
			s.Equal("abc", record.JobID)
			s.Equal("hello_milvus", record.CollectionName)
			s.Equal("Importing", record.State)
			s.EqualValues(50, record.Progress)
		}
	})

	s.Run("svr_error", func() {
		svr := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
			rw.WriteHeader(http.StatusInternalServerError)
		}))
		defer svr.Close()

		_, err := ListImportJobs(context.Background(), NewListImportJobsOption(svr.URL, "hello_milvus"))
		s.Error(err)
	})
}

func (s *BulkImportSuite) TestGetImportProgress() {
	s.Run("normal_case", func() {
		svr := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
			authHeader := req.Header.Get("Authorization")
			s.Equal("Bearer root:Milvus", authHeader)
			s.True(strings.Contains(req.URL.Path, "/v2/vectordb/jobs/import/describe"))
			rw.Write([]byte(`{"status":0, "data":{"collectionName": "hello_milvus","jobId":"abc", "state":"Importing", "progress": 50, "importedRows": 20000,"totalRows": 40000, "details":[{"fileName": "files/a.json", "fileSize": 64312, "progress": 100, "state": "Completed"}, {"fileName":"files/b.json", "fileSize":52912, "progress":0, "state":"Importing"}]}}`))
		}))
		defer svr.Close()

		resp, err := GetImportProgress(context.Background(),
			NewGetImportProgressOption(svr.URL, "abc").
				WithAPIKey("root:Milvus"),
		)
		s.NoError(err)
		s.EqualValues(0, resp.Status)
		s.Equal("hello_milvus", resp.Data.CollectionName)
		s.Equal("abc", resp.Data.JobID)
		s.Equal("Importing", resp.Data.State)
		s.EqualValues(50, resp.Data.Progress)
		if s.Len(resp.Data.Details, 2) {
			detail1 := resp.Data.Details[0]
			s.Equal("files/a.json", detail1.FileName)
			s.Equal("Completed", detail1.State)
			s.EqualValues(100, detail1.Progress)
			detail2 := resp.Data.Details[1]
			s.Equal("files/b.json", detail2.FileName)
			s.Equal("Importing", detail2.State)
			s.EqualValues(0, detail2.Progress)
		}
	})

	s.Run("svr_error", func() {
		svr := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
			rw.WriteHeader(http.StatusInternalServerError)
		}))
		defer svr.Close()

		_, err := GetImportProgress(context.Background(), NewGetImportProgressOption(svr.URL, "abc"))
		s.Error(err)
	})
}

func TestBulkImportAPIs(t *testing.T) {
	suite.Run(t, new(BulkImportSuite))
}



---
File: /bulkwriter/bulk_import.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bulkwriter

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

// ResponseBase is the common milvus restful response struct.
type ResponseBase struct {
	Status  int    `json:"status"`
	Message string `json:"message"`
}

// CheckStatus checks the response status and return error if not ok.
func (b ResponseBase) CheckStatus() error {
	if b.Status != 0 {
		return fmt.Errorf("bulk import return error, status: %d, message: %s", b.Status, b.Message)
	}
	return nil
}

type BulkImportOption struct {
	// milvus params
	URL            string `json:"-"`
	CollectionName string `json:"collectionName"`
	// optional in cloud api, use object url instead
	Files [][]string `json:"files,omitempty"`
	// optional params
	PartitionName string `json:"partitionName,omitempty"`
	APIKey        string `json:"-"`
	// cloud extra params
	ObjectURL string `json:"objectUrl,omitempty"`
	ClusterID string `json:"clusterId,omitempty"`
	AccessKey string `json:"accessKey,omitempty"`
	SecretKey string `json:"secretKey,omitempty"`

	// reserved extra options
	Options map[string]string `json:"options,omitempty"`
}

func (opt *BulkImportOption) GetRequest() ([]byte, error) {
	return json.Marshal(opt)
}

func (opt *BulkImportOption) WithPartition(partitionName string) *BulkImportOption {
	opt.PartitionName = partitionName
	return opt
}

func (opt *BulkImportOption) WithAPIKey(key string) *BulkImportOption {
	opt.APIKey = key
	return opt
}

func (opt *BulkImportOption) WithOption(key, value string) *BulkImportOption {
	if opt.Options == nil {
		opt.Options = make(map[string]string)
	}
	opt.Options[key] = value
	return opt
}

// NewBulkImportOption returns BulkImportOption for Milvus bulk import API.
func NewBulkImportOption(uri string,
	collectionName string,
	files [][]string,
) *BulkImportOption {
	return &BulkImportOption{
		URL:            uri,
		CollectionName: collectionName,
		Files:          files,
	}
}

// NewCloudBulkImportOption returns import option for cloud import API.
func NewCloudBulkImportOption(uri string,
	collectionName string,
	apiKey string,
	objectURL string,
	clusterID string,
	accessKey string,
	secretKey string,
) *BulkImportOption {
	return &BulkImportOption{
		URL:            uri,
		CollectionName: collectionName,
		APIKey:         apiKey,
		ObjectURL:      objectURL,
		ClusterID:      clusterID,
		AccessKey:      accessKey,
		SecretKey:      secretKey,
	}
}

type BulkImportResponse struct {
	ResponseBase
	Data struct {
		JobID string `json:"jobId"`
	} `json:"data"`
}

// BulkImport is the API wrapper for restful import API.
func BulkImport(ctx context.Context, option *BulkImportOption) (*BulkImportResponse, error) {
	url := option.URL + "/v2/vectordb/jobs/import/create"
	bs, err := option.GetRequest()
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(bs))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if option.APIKey != "" {
		req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", option.APIKey))
	}

	result := &BulkImportResponse{}
	err = doPostRequest(req, result)
	if err != nil {
		return nil, err
	}
	return result, result.CheckStatus()
}

type ListImportJobsOption struct {
	URL            string `json:"-"`
	CollectionName string `json:"collectionName"`
	ClusterID      string `json:"clusterId,omitempty"`
	APIKey         string `json:"-"`
	PageSize       int    `json:"pageSize,omitempty"`
	CurrentPage    int    `json:"currentPage,omitempty"`
}

func (opt *ListImportJobsOption) WithAPIKey(key string) *ListImportJobsOption {
	opt.APIKey = key
	return opt
}

func (opt *ListImportJobsOption) WithPageSize(pageSize int) *ListImportJobsOption {
	opt.PageSize = pageSize
	return opt
}

func (opt *ListImportJobsOption) WithCurrentPage(currentPage int) *ListImportJobsOption {
	opt.CurrentPage = currentPage
	return opt
}

func (opt *ListImportJobsOption) GetRequest() ([]byte, error) {
	return json.Marshal(opt)
}

func NewListImportJobsOption(uri string, collectionName string) *ListImportJobsOption {
	return &ListImportJobsOption{
		URL:            uri,
		CollectionName: collectionName,
		CurrentPage:    1,
		PageSize:       10,
	}
}

type ListImportJobsResponse struct {
	ResponseBase
	Data *ListImportJobData `json:"data"`
}

type ListImportJobData struct {
	Records []*ImportJobRecord `json:"records"`
}

type ImportJobRecord struct {
	JobID          string `json:"jobId"`
	CollectionName string `json:"collectionName"`
	State          string `json:"state"`
	Progress       int64  `json:"progress"`
	Reason         string `json:"reason"`
}

func ListImportJobs(ctx context.Context, option *ListImportJobsOption) (*ListImportJobsResponse, error) {
	url := option.URL + "/v2/vectordb/jobs/import/list"
	bs, err := option.GetRequest()
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(bs))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if option.APIKey != "" {
		req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", option.APIKey))
	}

	result := &ListImportJobsResponse{}
	if err := doPostRequest(req, result); err != nil {
		return nil, err
	}

	return result, result.CheckStatus()
}

type GetImportProgressOption struct {
	URL   string `json:"-"`
	JobID string `json:"jobId"`
	// optional
	ClusterID string `json:"clusterId"`
	APIKey    string `json:"-"`
}

func (opt *GetImportProgressOption) GetRequest() ([]byte, error) {
	return json.Marshal(opt)
}

func (opt *GetImportProgressOption) WithAPIKey(key string) *GetImportProgressOption {
	opt.APIKey = key
	return opt
}

func NewGetImportProgressOption(uri string, jobID string) *GetImportProgressOption {
	return &GetImportProgressOption{
		URL:   uri,
		JobID: jobID,
	}
}

func NewCloudGetImportProgressOption(uri string, jobID string, apiKey string, clusterID string) *GetImportProgressOption {
	return &GetImportProgressOption{
		URL:       uri,
		JobID:     jobID,
		APIKey:    apiKey,
		ClusterID: clusterID,
	}
}

type GetImportProgressResponse struct {
	ResponseBase
	Data *ImportProgressData `json:"data"`
}

type ImportProgressData struct {
	CollectionName string                  `json:"collectionName"`
	JobID          string                  `json:"jobId"`
	CompleteTime   string                  `json:"completeTime"`
	State          string                  `json:"state"`
	Progress       int64                   `json:"progress"`
	ImportedRows   int64                   `json:"importedRows"`
	TotalRows      int64                   `json:"totalRows"`
	Reason         string                  `json:"reason"`
	FileSize       int64                   `json:"fileSize"`
	Details        []*ImportProgressDetail `json:"details"`
}

type ImportProgressDetail struct {
	FileName     string `json:"fileName"`
	FileSize     int64  `json:"fileSize"`
	Progress     int64  `json:"progress"`
	CompleteTime string `json:"completeTime"`
	State        string `json:"state"`
	ImportedRows int64  `json:"importedRows"`
	TotalRows    int64  `json:"totalRows"`
}

func GetImportProgress(ctx context.Context, option *GetImportProgressOption) (*GetImportProgressResponse, error) {
	url := option.URL + "/v2/vectordb/jobs/import/describe"

	bs, err := option.GetRequest()
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(bs))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/json")
	if option.APIKey != "" {
		req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", option.APIKey))
	}

	result := &GetImportProgressResponse{}
	if err := doPostRequest(req, result); err != nil {
		return nil, err
	}
	return result, result.CheckStatus()
}

func doPostRequest(req *http.Request, response any) error {
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	respData, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}
	return json.Unmarshal(respData, response)
}



---
File: /column/array_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"fmt"
	"math/rand"
	"testing"

	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

type ArraySuite struct {
	suite.Suite
}

func (s *ArraySuite) TestBasic() {
	s.Run("bool_array", func() {
		data := [][]bool{
			{true, false},
			{false, true},
		}
		name := fmt.Sprintf("field_%d", rand.Intn(100))

		column := NewColumnBoolArray(name, data)
		s.Equal(name, column.Name())
		s.Equal(entity.FieldTypeArray, column.Type())
		s.Equal(entity.FieldTypeBool, column.ElementType())

		fd := column.FieldData()
		arrayData := fd.GetScalars().GetArrayData()
		s.Equal(schemapb.DataType_Bool, arrayData.GetElementType())
		for i, row := range data {
			sf := arrayData.GetData()[i]
			s.Equal(row, sf.GetBoolData().GetData())
		}

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnBoolArray)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeArray, column.Type())
			s.Equal(entity.FieldTypeBool, column.ElementType())
			s.Equal(data, parsed.Data())
		}
	})

	s.Run("int8_array", func() {
		data := [][]int8{
			{1, 2},
			{3, 4},
		}
		name := fmt.Sprintf("field_%d", rand.Intn(100))

		column := NewColumnInt8Array(name, data)
		s.Equal(name, column.Name())
		s.Equal(entity.FieldTypeArray, column.Type())
		s.Equal(entity.FieldTypeInt8, column.ElementType())

		fd := column.FieldData()
		arrayData := fd.GetScalars().GetArrayData()
		s.Equal(schemapb.DataType_Int8, arrayData.GetElementType())
		for i, row := range data {
			sf := arrayData.GetData()[i]
			for j, item := range row {
				s.EqualValues(item, sf.GetIntData().GetData()[j])
			}
		}

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnInt8Array)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeArray, column.Type())
			s.Equal(entity.FieldTypeInt8, column.ElementType())
			s.Equal(data, parsed.Data())
		}
	})

	s.Run("int16_array", func() {
		data := [][]int16{
			{1, 2},
			{3, 4},
		}
		name := fmt.Sprintf("field_%d", rand.Intn(100))

		column := NewColumnInt16Array(name, data)
		s.Equal(name, column.Name())
		s.Equal(entity.FieldTypeArray, column.Type())
		s.Equal(entity.FieldTypeInt16, column.ElementType())

		fd := column.FieldData()
		arrayData := fd.GetScalars().GetArrayData()
		s.Equal(schemapb.DataType_Int16, arrayData.GetElementType())
		for i, row := range data {
			sf := arrayData.GetData()[i]
			for j, item := range row {
				s.EqualValues(item, sf.GetIntData().GetData()[j])
			}
		}

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnInt16Array)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeArray, column.Type())
			s.Equal(entity.FieldTypeInt16, column.ElementType())
			s.Equal(data, parsed.Data())
		}
	})

	s.Run("int32_array", func() {
		data := [][]int32{
			{1, 2},
			{3, 4},
		}
		name := fmt.Sprintf("field_%d", rand.Intn(100))

		column := NewColumnInt32Array(name, data)
		s.Equal(name, column.Name())
		s.Equal(entity.FieldTypeArray, column.Type())
		s.Equal(entity.FieldTypeInt32, column.ElementType())

		fd := column.FieldData()
		arrayData := fd.GetScalars().GetArrayData()
		s.Equal(schemapb.DataType_Int32, arrayData.GetElementType())
		for i, row := range data {
			sf := arrayData.GetData()[i]
			s.Equal(row, sf.GetIntData().GetData())
		}

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnInt32Array)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeArray, column.Type())
			s.Equal(entity.FieldTypeInt32, column.ElementType())
			s.Equal(data, parsed.Data())
		}
	})

	s.Run("int64_array", func() {
		data := [][]int64{
			{1, 2},
			{3, 4},
		}
		name := fmt.Sprintf("field_%d", rand.Intn(100))

		column := NewColumnInt64Array(name, data)
		s.Equal(name, column.Name())
		s.Equal(entity.FieldTypeArray, column.Type())
		s.Equal(entity.FieldTypeInt64, column.ElementType())

		fd := column.FieldData()
		arrayData := fd.GetScalars().GetArrayData()
		s.Equal(schemapb.DataType_Int64, arrayData.GetElementType())
		for i, row := range data {
			sf := arrayData.GetData()[i]
			s.Equal(row, sf.GetLongData().GetData())
		}

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnInt64Array)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeArray, column.Type())
			s.Equal(entity.FieldTypeInt64, column.ElementType())
			s.Equal(data, parsed.Data())
		}
	})

	s.Run("float_array", func() {
		data := [][]float32{
			{0.1, 0.2},
			{1.3, 1.4},
		}
		name := fmt.Sprintf("field_%d", rand.Intn(100))

		column := NewColumnFloatArray(name, data)
		s.Equal(name, column.Name())
		s.Equal(entity.FieldTypeArray, column.Type())
		s.Equal(entity.FieldTypeFloat, column.ElementType())

		fd := column.FieldData()
		arrayData := fd.GetScalars().GetArrayData()
		s.Equal(schemapb.DataType_Float, arrayData.GetElementType())
		for i, row := range data {
			sf := arrayData.GetData()[i]
			s.Equal(row, sf.GetFloatData().GetData())
		}

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnFloatArray)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeArray, column.Type())
			s.Equal(entity.FieldTypeFloat, column.ElementType())
			s.Equal(data, parsed.Data())
		}
	})

	s.Run("double_array", func() {
		data := [][]float64{
			{0.1, 0.2},
			{1.3, 1.4},
		}
		name := fmt.Sprintf("field_%d", rand.Intn(100))

		column := NewColumnDoubleArray(name, data)
		s.Equal(name, column.Name())
		s.Equal(entity.FieldTypeArray, column.Type())
		s.Equal(entity.FieldTypeDouble, column.ElementType())

		fd := column.FieldData()
		arrayData := fd.GetScalars().GetArrayData()
		s.Equal(schemapb.DataType_Double, arrayData.GetElementType())
		for i, row := range data {
			sf := arrayData.GetData()[i]
			s.Equal(row, sf.GetDoubleData().GetData())
		}

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnDoubleArray)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeArray, column.Type())
			s.Equal(entity.FieldTypeDouble, column.ElementType())
			s.Equal(data, parsed.Data())
		}
	})

	s.Run("varchar_array", func() {
		data := [][]string{
			{"abc", "def"},
			{"xyz"},
		}

		name := fmt.Sprintf("field_%d", rand.Intn(100))

		column := NewColumnVarCharArray(name, data)
		s.Equal(name, column.Name())
		s.Equal(entity.FieldTypeArray, column.Type())
		s.Equal(entity.FieldTypeVarChar, column.ElementType())

		fd := column.FieldData()
		arrayData := fd.GetScalars().GetArrayData()
		s.Equal(schemapb.DataType_VarChar, arrayData.GetElementType())
		for i, row := range data {
			sf := arrayData.GetData()[i]
			s.Equal(row, sf.GetStringData().GetData())
		}

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnVarCharArray)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeArray, column.Type())
			s.Equal(entity.FieldTypeVarChar, column.ElementType())
			s.Equal(data, parsed.Data())
		}
	})
}

func TestArrays(t *testing.T) {
	suite.Run(t, new(ArraySuite))
}



---
File: /column/array.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

// columnArrayBase implement `Column` interface
// it provided specified `FieldData` behavior for Array columns.
type columnArrayBase[T any] struct {
	*genericColumnBase[[]T]
	elementType entity.FieldType
}

func (c *columnArrayBase[T]) FieldData() *schemapb.FieldData {
	fd := &schemapb.FieldData{
		Type:      schemapb.DataType_Array,
		FieldName: c.name,
		ValidData: c.validData,
	}

	data := make([]*schemapb.ScalarField, 0, c.Len())
	for _, arr := range c.values {
		data = append(data, slice2Scalar(arr, c.elementType))
	}

	fd.Field = &schemapb.FieldData_Scalars{
		Scalars: &schemapb.ScalarField{
			Data: &schemapb.ScalarField_ArrayData{
				ArrayData: &schemapb.ArrayArray{
					Data:        data,
					ElementType: schemapb.DataType(c.elementType),
				},
			},
		},
	}
	return fd
}

func (c *columnArrayBase[T]) ElementType() entity.FieldType {
	return c.elementType
}

func (c *columnArrayBase[T]) slice(start, end int) *columnArrayBase[T] {
	return &columnArrayBase[T]{
		genericColumnBase: c.genericColumnBase.slice(start, end),
		elementType:       c.elementType,
	}
}

func newArrayBase[T any](fieldName string, data [][]T, elementType entity.FieldType) *columnArrayBase[T] {
	return &columnArrayBase[T]{
		genericColumnBase: &genericColumnBase[[]T]{
			name:      fieldName,
			fieldType: entity.FieldTypeArray,
			values:    data,
		},
		elementType: elementType,
	}
}

/* bool array */

type ColumnBoolArray struct {
	*columnArrayBase[bool]
}

func NewColumnBoolArray(fieldName string, data [][]bool) *ColumnBoolArray {
	return &ColumnBoolArray{
		columnArrayBase: newArrayBase[bool](fieldName, data, entity.FieldTypeBool),
	}
}

func (c *ColumnBoolArray) Slice(start, end int) Column {
	return &ColumnBoolArray{
		columnArrayBase: c.columnArrayBase.slice(start, end),
	}
}

/* int8 array */

type ColumnInt8Array struct {
	*columnArrayBase[int8]
}

func NewColumnInt8Array(fieldName string, data [][]int8) *ColumnInt8Array {
	return &ColumnInt8Array{
		columnArrayBase: newArrayBase(fieldName, data, entity.FieldTypeInt8),
	}
}

func (c *ColumnInt8Array) Slice(start, end int) Column {
	return &ColumnInt8Array{
		columnArrayBase: c.columnArrayBase.slice(start, end),
	}
}

/* int16 array */

type ColumnInt16Array struct {
	*columnArrayBase[int16]
}

func NewColumnInt16Array(fieldName string, data [][]int16) *ColumnInt16Array {
	return &ColumnInt16Array{
		columnArrayBase: newArrayBase(fieldName, data, entity.FieldTypeInt16),
	}
}

func (c *ColumnInt16Array) Slice(start, end int) Column {
	return &ColumnInt16Array{
		columnArrayBase: c.columnArrayBase.slice(start, end),
	}
}

/* int32 array */

type ColumnInt32Array struct {
	*columnArrayBase[int32]
}

func NewColumnInt32Array(fieldName string, data [][]int32) *ColumnInt32Array {
	return &ColumnInt32Array{
		columnArrayBase: newArrayBase(fieldName, data, entity.FieldTypeInt32),
	}
}

func (c *ColumnInt32Array) Slice(start, end int) Column {
	return &ColumnInt32Array{
		columnArrayBase: c.columnArrayBase.slice(start, end),
	}
}

/* int64 array */

type ColumnInt64Array struct {
	*columnArrayBase[int64]
}

func NewColumnInt64Array(fieldName string, data [][]int64) *ColumnInt64Array {
	return &ColumnInt64Array{
		columnArrayBase: newArrayBase(fieldName, data, entity.FieldTypeInt64),
	}
}

func (c *ColumnInt64Array) Slice(start, end int) Column {
	return &ColumnInt64Array{
		columnArrayBase: c.columnArrayBase.slice(start, end),
	}
}

/* float32 array */

type ColumnFloatArray struct {
	*columnArrayBase[float32]
}

func NewColumnFloatArray(fieldName string, data [][]float32) *ColumnFloatArray {
	return &ColumnFloatArray{
		columnArrayBase: newArrayBase(fieldName, data, entity.FieldTypeFloat),
	}
}

func (c *ColumnFloatArray) Slice(start, end int) Column {
	return &ColumnFloatArray{
		columnArrayBase: c.columnArrayBase.slice(start, end),
	}
}

/* float64 array */

type ColumnDoubleArray struct {
	*columnArrayBase[float64]
}

func NewColumnDoubleArray(fieldName string, data [][]float64) *ColumnDoubleArray {
	return &ColumnDoubleArray{
		columnArrayBase: newArrayBase(fieldName, data, entity.FieldTypeDouble),
	}
}

func (c *ColumnDoubleArray) Slice(start, end int) Column {
	return &ColumnDoubleArray{
		columnArrayBase: c.columnArrayBase.slice(start, end),
	}
}

/* varchar array */

type ColumnVarCharArray struct {
	*columnArrayBase[string]
}

func NewColumnVarCharArray(fieldName string, data [][]string) *ColumnVarCharArray {
	return &ColumnVarCharArray{
		columnArrayBase: newArrayBase(fieldName, data, entity.FieldTypeVarChar),
	}
}



---
File: /column/columns_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"math/rand"
	"strconv"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

func TestIDColumns(t *testing.T) {
	dataLen := rand.Intn(100) + 1
	base := rand.Intn(5000) // id start point

	intPKCol := entity.NewSchema().WithField(
		entity.NewField().WithName("pk").WithIsPrimaryKey(true).WithDataType(entity.FieldTypeInt64),
	)
	strPKCol := entity.NewSchema().WithField(
		entity.NewField().WithName("pk").WithIsPrimaryKey(true).WithDataType(entity.FieldTypeVarChar),
	)

	t.Run("nil id", func(t *testing.T) {
		_, err := IDColumns(intPKCol, nil, 0, -1)
		assert.NoError(t, err)
		_, err = IDColumns(strPKCol, nil, 0, -1)
		assert.NoError(t, err)

		idField := &schemapb.IDs{}
		col, err := IDColumns(intPKCol, idField, 0, -1)
		assert.NoError(t, err)
		assert.EqualValues(t, 0, col.Len())
		col, err = IDColumns(strPKCol, idField, 0, -1)
		assert.NoError(t, err)
		assert.EqualValues(t, 0, col.Len())
	})

	t.Run("int ids", func(t *testing.T) {
		ids := make([]int64, 0, dataLen)
		for i := 0; i < dataLen; i++ {
			ids = append(ids, int64(i+base))
		}
		idField := &schemapb.IDs{
			IdField: &schemapb.IDs_IntId{
				IntId: &schemapb.LongArray{
					Data: ids,
				},
			},
		}
		column, err := IDColumns(intPKCol, idField, 0, dataLen)
		assert.Nil(t, err)
		assert.NotNil(t, column)
		assert.Equal(t, dataLen, column.Len())

		column, err = IDColumns(intPKCol, idField, 0, -1) // test -1 method
		assert.Nil(t, err)
		assert.NotNil(t, column)
		assert.Equal(t, dataLen, column.Len())
	})
	t.Run("string ids", func(t *testing.T) {
		ids := make([]string, 0, dataLen)
		for i := 0; i < dataLen; i++ {
			ids = append(ids, strconv.FormatInt(int64(i+base), 10))
		}
		idField := &schemapb.IDs{
			IdField: &schemapb.IDs_StrId{
				StrId: &schemapb.StringArray{
					Data: ids,
				},
			},
		}
		column, err := IDColumns(strPKCol, idField, 0, dataLen)
		assert.Nil(t, err)
		assert.NotNil(t, column)
		assert.Equal(t, dataLen, column.Len())

		column, err = IDColumns(strPKCol, idField, 0, -1) // test -1 method
		assert.Nil(t, err)
		assert.NotNil(t, column)
		assert.Equal(t, dataLen, column.Len())
	})
}

func TestGetIntData(t *testing.T) {
	type testCase struct {
		tag      string
		fd       *schemapb.FieldData
		expectOK bool
	}

	cases := []testCase{
		{
			tag: "normal_IntData",
			fd: &schemapb.FieldData{
				Field: &schemapb.FieldData_Scalars{
					Scalars: &schemapb.ScalarField{
						Data: &schemapb.ScalarField_IntData{
							IntData: &schemapb.IntArray{Data: []int32{1, 2, 3}},
						},
					},
				},
			},
			expectOK: true,
		},
		{
			tag: "empty_LongData",
			fd: &schemapb.FieldData{
				Field: &schemapb.FieldData_Scalars{
					Scalars: &schemapb.ScalarField{
						Data: &schemapb.ScalarField_LongData{
							LongData: &schemapb.LongArray{Data: nil},
						},
					},
				},
			},
			expectOK: true,
		},
		{
			tag: "nonempty_LongData",
			fd: &schemapb.FieldData{
				Field: &schemapb.FieldData_Scalars{
					Scalars: &schemapb.ScalarField{
						Data: &schemapb.ScalarField_LongData{
							LongData: &schemapb.LongArray{Data: []int64{1, 2, 3}},
						},
					},
				},
			},
			expectOK: false,
		},
		{
			tag: "other_data",
			fd: &schemapb.FieldData{
				Field: &schemapb.FieldData_Scalars{
					Scalars: &schemapb.ScalarField{
						Data: &schemapb.ScalarField_BoolData{},
					},
				},
			},
			expectOK: false,
		},
		{
			tag: "vector_data",
			fd: &schemapb.FieldData{
				Field: &schemapb.FieldData_Vectors{},
			},
			expectOK: false,
		},
	}

	for _, tc := range cases {
		t.Run(tc.tag, func(t *testing.T) {
			_, ok := getIntData(tc.fd)
			assert.Equal(t, tc.expectOK, ok)
		})
	}
}



---
File: /column/columns.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"fmt"

	"github.com/cockroachdb/errors"
	"github.com/samber/lo"

	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

// Column interface field type for column-based data frame
type Column interface {
	Name() string
	Type() entity.FieldType
	Len() int
	Slice(int, int) Column
	FieldData() *schemapb.FieldData
	AppendValue(interface{}) error
	Get(int) (interface{}, error)
	GetAsInt64(int) (int64, error)
	GetAsString(int) (string, error)
	GetAsDouble(int) (float64, error)
	GetAsBool(int) (bool, error)
	// nullable related API
	AppendNull() error
	IsNull(int) (bool, error)
	Nullable() bool
	SetNullable(bool)
	ValidateNullable() error
	CompactNullableValues()
}

var errFieldDataTypeNotMatch = errors.New("FieldData type not matched")

// IDColumns converts schemapb.IDs to corresponding column
// currently Int64 / string may be in IDs
func IDColumns(schema *entity.Schema, ids *schemapb.IDs, begin, end int) (Column, error) {
	var idColumn Column
	pkField := schema.PKField()
	if pkField == nil {
		return nil, errors.New("PK Field not found")
	}
	switch pkField.DataType {
	case entity.FieldTypeInt64:
		data := ids.GetIntId().GetData()
		if data == nil {
			return NewColumnInt64(pkField.Name, nil), nil
		}
		if end >= 0 {
			idColumn = NewColumnInt64(pkField.Name, data[begin:end])
		} else {
			idColumn = NewColumnInt64(pkField.Name, data[begin:])
		}
	case entity.FieldTypeVarChar, entity.FieldTypeString:
		data := ids.GetStrId().GetData()
		if data == nil {
			return NewColumnVarChar(pkField.Name, nil), nil
		}
		if end >= 0 {
			idColumn = NewColumnVarChar(pkField.Name, data[begin:end])
		} else {
			idColumn = NewColumnVarChar(pkField.Name, data[begin:])
		}
	default:
		return nil, fmt.Errorf("unsupported id type %v", pkField.DataType)
	}
	return idColumn, nil
}

func parseScalarData[T any, COL Column, NCOL Column](
	name string,
	data []T,
	start, end int,
	validData []bool,
	creator func(string, []T) COL,
	nullableCreator func(string, []T, []bool, ...ColumnOption[T]) (NCOL, error),
) (Column, error) {
	if end < 0 {
		end = len(data)
	}
	data = data[start:end]
	if len(validData) > 0 {
		ncol, err := nullableCreator(name, data, validData, WithSparseNullableMode[T](true))
		return ncol, err
	}

	return creator(name, data), nil
}

func parseArrayData(fieldName string, elementType schemapb.DataType, fieldDataList []*schemapb.ScalarField, validData []bool, begin, end int) (Column, error) {
	switch elementType {
	case schemapb.DataType_Bool:
		data := lo.Map(fieldDataList, func(fd *schemapb.ScalarField, _ int) []bool {
			return fd.GetBoolData().GetData()
		})
		return parseScalarData(fieldName, data, begin, end, validData, NewColumnBoolArray, NewNullableColumnBoolArray)

	case schemapb.DataType_Int8:
		data := lo.Map(fieldDataList, func(fd *schemapb.ScalarField, _ int) []int8 {
			return int32ToType[int8](fd.GetIntData().GetData())
		})
		return parseScalarData(fieldName, data, begin, end, validData, NewColumnInt8Array, NewNullableColumnInt8Array)

	case schemapb.DataType_Int16:
		data := lo.Map(fieldDataList, func(fd *schemapb.ScalarField, _ int) []int16 {
			return int32ToType[int16](fd.GetIntData().GetData())
		})
		return parseScalarData(fieldName, data, begin, end, validData, NewColumnInt16Array, NewNullableColumnInt16Array)

	case schemapb.DataType_Int32:
		data := lo.Map(fieldDataList, func(fd *schemapb.ScalarField, _ int) []int32 {
			return fd.GetIntData().GetData()
		})
		return parseScalarData(fieldName, data, begin, end, validData, NewColumnInt32Array, NewNullableColumnInt32Array)

	case schemapb.DataType_Int64:
		data := lo.Map(fieldDataList, func(fd *schemapb.ScalarField, _ int) []int64 {
			return fd.GetLongData().GetData()
		})
		return parseScalarData(fieldName, data, begin, end, validData, NewColumnInt64Array, NewNullableColumnInt64Array)

	case schemapb.DataType_Float:
		data := lo.Map(fieldDataList, func(fd *schemapb.ScalarField, _ int) []float32 {
			return fd.GetFloatData().GetData()
		})
		return parseScalarData(fieldName, data, begin, end, validData, NewColumnFloatArray, NewNullableColumnFloatArray)

	case schemapb.DataType_Double:
		data := lo.Map(fieldDataList, func(fd *schemapb.ScalarField, _ int) []float64 {
			return fd.GetDoubleData().GetData()
		})
		return parseScalarData(fieldName, data, begin, end, validData, NewColumnDoubleArray, NewNullableColumnDoubleArray)

	case schemapb.DataType_VarChar, schemapb.DataType_String:
		data := lo.Map(fieldDataList, func(fd *schemapb.ScalarField, _ int) []string {
			return fd.GetStringData().GetData()
		})
		return parseScalarData(fieldName, data, begin, end, validData, NewColumnVarCharArray, NewNullableColumnVarCharArray)

	default:
		return nil, fmt.Errorf("unsupported element type %s", elementType)
	}
}

func int32ToType[T ~int8 | int16](data []int32) []T {
	return lo.Map(data, func(i32 int32, _ int) T {
		return T(i32)
	})
}

// FieldDataColumn converts schemapb.FieldData to Column, used int search result conversion logic
// begin, end specifies the start and end positions
func FieldDataColumn(fd *schemapb.FieldData, begin, end int) (Column, error) {
	validData := fd.GetValidData()

	switch fd.GetType() {
	case schemapb.DataType_Bool:
		return parseScalarData(fd.GetFieldName(), fd.GetScalars().GetBoolData().GetData(), begin, end, validData, NewColumnBool, NewNullableColumnBool)

	case schemapb.DataType_Int8:
		data := int32ToType[int8](fd.GetScalars().GetIntData().GetData())
		return parseScalarData(fd.GetFieldName(), data, begin, end, validData, NewColumnInt8, NewNullableColumnInt8)

	case schemapb.DataType_Int16:
		data := int32ToType[int16](fd.GetScalars().GetIntData().GetData())
		return parseScalarData(fd.GetFieldName(), data, begin, end, validData, NewColumnInt16, NewNullableColumnInt16)

	case schemapb.DataType_Int32:
		return parseScalarData(fd.GetFieldName(), fd.GetScalars().GetIntData().GetData(), begin, end, validData, NewColumnInt32, NewNullableColumnInt32)

	case schemapb.DataType_Int64:
		return parseScalarData(fd.GetFieldName(), fd.GetScalars().GetLongData().GetData(), begin, end, validData, NewColumnInt64, NewNullableColumnInt64)

	case schemapb.DataType_Float:
		return parseScalarData(fd.GetFieldName(), fd.GetScalars().GetFloatData().GetData(), begin, end, validData, NewColumnFloat, NewNullableColumnFloat)

	case schemapb.DataType_Double:
		return parseScalarData(fd.GetFieldName(), fd.GetScalars().GetDoubleData().GetData(), begin, end, validData, NewColumnDouble, NewNullableColumnDouble)

	case schemapb.DataType_String:
		return parseScalarData(fd.GetFieldName(), fd.GetScalars().GetStringData().GetData(), begin, end, validData, NewColumnString, NewNullableColumnString)

	case schemapb.DataType_VarChar:
		return parseScalarData(fd.GetFieldName(), fd.GetScalars().GetStringData().GetData(), begin, end, validData, NewColumnVarChar, NewNullableColumnVarChar)

	case schemapb.DataType_Array:
		data := fd.GetScalars().GetArrayData()
		return parseArrayData(fd.GetFieldName(), data.GetElementType(), data.GetData(), validData, begin, end)

	case schemapb.DataType_JSON:
		return parseScalarData(fd.GetFieldName(), fd.GetScalars().GetJsonData().GetData(), begin, end, validData, NewColumnJSONBytes, NewNullableColumnJSONBytes)

	case schemapb.DataType_FloatVector:
		vectors := fd.GetVectors()
		x, ok := vectors.GetData().(*schemapb.VectorField_FloatVector)
		if !ok {
			return nil, errFieldDataTypeNotMatch
		}
		data := x.FloatVector.GetData()
		dim := int(vectors.GetDim())
		if end < 0 {
			end = len(data) / dim
		}
		vector := make([][]float32, 0, end-begin) // shall not have remanunt
		for i := begin; i < end; i++ {
			v := make([]float32, dim)
			copy(v, data[i*dim:(i+1)*dim])
			vector = append(vector, v)
		}
		return NewColumnFloatVector(fd.GetFieldName(), dim, vector), nil

	case schemapb.DataType_BinaryVector:
		vectors := fd.GetVectors()
		x, ok := vectors.GetData().(*schemapb.VectorField_BinaryVector)
		if !ok {
			return nil, errFieldDataTypeNotMatch
		}
		data := x.BinaryVector
		if data == nil {
			return nil, errFieldDataTypeNotMatch
		}
		dim := int(vectors.GetDim())
		blen := dim / 8
		if end < 0 {
			end = len(data) / blen
		}
		vector := make([][]byte, 0, end-begin)
		for i := begin; i < end; i++ {
			v := make([]byte, blen)
			copy(v, data[i*blen:(i+1)*blen])
			vector = append(vector, v)
		}
		return NewColumnBinaryVector(fd.GetFieldName(), dim, vector), nil

	case schemapb.DataType_Float16Vector:
		vectors := fd.GetVectors()
		x, ok := vectors.GetData().(*schemapb.VectorField_Float16Vector)
		if !ok {
			return nil, errFieldDataTypeNotMatch
		}
		data := x.Float16Vector
		dim := int(vectors.GetDim())
		if end < 0 {
			end = len(data) / dim / 2
		}
		vector := make([][]byte, 0, end-begin)
		for i := begin; i < end; i++ {
			v := make([]byte, dim*2)
			copy(v, data[i*dim*2:(i+1)*dim*2])
			vector = append(vector, v)
		}
		return NewColumnFloat16Vector(fd.GetFieldName(), dim, vector), nil

	case schemapb.DataType_BFloat16Vector:
		vectors := fd.GetVectors()
		x, ok := vectors.GetData().(*schemapb.VectorField_Bfloat16Vector)
		if !ok {
			return nil, errFieldDataTypeNotMatch
		}
		data := x.Bfloat16Vector
		dim := int(vectors.GetDim())
		if end < 0 {
			end = len(data) / dim / 2
		}
		vector := make([][]byte, 0, end-begin) // shall not have remanunt
		for i := begin; i < end; i++ {
			v := make([]byte, dim*2)
			copy(v, data[i*dim*2:(i+1)*dim*2])
			vector = append(vector, v)
		}
		return NewColumnBFloat16Vector(fd.GetFieldName(), dim, vector), nil
	case schemapb.DataType_SparseFloatVector:
		sparseVectors := fd.GetVectors().GetSparseFloatVector()
		if sparseVectors == nil {
			return nil, errFieldDataTypeNotMatch
		}
		data := sparseVectors.Contents
		if end < 0 {
			end = len(data)
		}
		data = data[begin:end]
		vectors := make([]entity.SparseEmbedding, 0, len(data))
		for _, bs := range data {
			vector, err := entity.DeserializeSliceSparseEmbedding(bs)
			if err != nil {
				return nil, err
			}
			vectors = append(vectors, vector)
		}
		return NewColumnSparseVectors(fd.GetFieldName(), vectors), nil
	default:
		return nil, fmt.Errorf("unsupported data type %s", fd.GetType())
	}
}

// getIntData get int32 slice from result field data
// also handles LongData bug (see also https://github.com/milvus-io/milvus/issues/23850)
func getIntData(fd *schemapb.FieldData) (*schemapb.ScalarField_IntData, bool) {
	switch data := fd.GetScalars().GetData().(type) {
	case *schemapb.ScalarField_IntData:
		return data, true
	case *schemapb.ScalarField_LongData:
		// only alway empty LongData for backward compatibility
		if len(data.LongData.GetData()) == 0 {
			return &schemapb.ScalarField_IntData{
				IntData: &schemapb.IntArray{},
			}, true
		}
		return nil, false
	default:
		return nil, false
	}
}



---
File: /column/conversion.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"fmt"

	"github.com/cockroachdb/errors"
	"github.com/samber/lo"

	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

func slice2Scalar[T any](values []T, elementType entity.FieldType) *schemapb.ScalarField {
	var ok bool
	scalarField := &schemapb.ScalarField{}
	switch elementType {
	case entity.FieldTypeBool:
		var bools []bool
		bools, ok = any(values).([]bool)
		scalarField.Data = &schemapb.ScalarField_BoolData{
			BoolData: &schemapb.BoolArray{
				Data: bools,
			},
		}
	case entity.FieldTypeInt8:
		var int8s []int8
		int8s, ok = any(values).([]int8)
		int32s := lo.Map(int8s, func(i8 int8, _ int) int32 { return int32(i8) })
		scalarField.Data = &schemapb.ScalarField_IntData{
			IntData: &schemapb.IntArray{
				Data: int32s,
			},
		}
	case entity.FieldTypeInt16:
		var int16s []int16
		int16s, ok = any(values).([]int16)
		int32s := lo.Map(int16s, func(i16 int16, _ int) int32 { return int32(i16) })
		scalarField.Data = &schemapb.ScalarField_IntData{
			IntData: &schemapb.IntArray{
				Data: int32s,
			},
		}
	case entity.FieldTypeInt32:
		var int32s []int32
		int32s, ok = any(values).([]int32)
		scalarField.Data = &schemapb.ScalarField_IntData{
			IntData: &schemapb.IntArray{
				Data: int32s,
			},
		}
	case entity.FieldTypeInt64:
		var int64s []int64
		int64s, ok = any(values).([]int64)
		scalarField.Data = &schemapb.ScalarField_LongData{
			LongData: &schemapb.LongArray{
				Data: int64s,
			},
		}
	case entity.FieldTypeFloat:
		var floats []float32
		floats, ok = any(values).([]float32)
		scalarField.Data = &schemapb.ScalarField_FloatData{
			FloatData: &schemapb.FloatArray{
				Data: floats,
			},
		}
	case entity.FieldTypeDouble:
		var doubles []float64
		doubles, ok = any(values).([]float64)
		scalarField.Data = &schemapb.ScalarField_DoubleData{
			DoubleData: &schemapb.DoubleArray{
				Data: doubles,
			},
		}
	case entity.FieldTypeVarChar, entity.FieldTypeString:
		var strings []string
		strings, ok = any(values).([]string)
		scalarField.Data = &schemapb.ScalarField_StringData{
			StringData: &schemapb.StringArray{
				Data: strings,
			},
		}
	}

	if !ok {
		panic(fmt.Sprintf("unexpected values type(%T) of fieldType %v", values, elementType))
	}
	return scalarField
}

func values2FieldData[T any](values []T, fieldType entity.FieldType, dim int) *schemapb.FieldData {
	fd := &schemapb.FieldData{}
	switch fieldType {
	// scalars
	case entity.FieldTypeBool,
		entity.FieldTypeFloat,
		entity.FieldTypeDouble,
		entity.FieldTypeInt8,
		entity.FieldTypeInt16,
		entity.FieldTypeInt32,
		entity.FieldTypeInt64,
		entity.FieldTypeVarChar,
		entity.FieldTypeString,
		entity.FieldTypeJSON:
		fd.Field = &schemapb.FieldData_Scalars{
			Scalars: values2Scalars(values, fieldType), // scalars,
		}
	// vectors
	case entity.FieldTypeFloatVector,
		entity.FieldTypeFloat16Vector,
		entity.FieldTypeBFloat16Vector,
		entity.FieldTypeBinaryVector,
		entity.FieldTypeSparseVector:
		fd.Field = &schemapb.FieldData_Vectors{
			Vectors: values2Vectors(values, fieldType, int64(dim)),
		}
	default:
		panic(fmt.Sprintf("unexpected values type(%T) of fieldType %v", values, fieldType))
	}
	return fd
}

func values2Scalars[T any](values []T, fieldType entity.FieldType) *schemapb.ScalarField {
	scalars := &schemapb.ScalarField{}
	var ok bool
	switch fieldType {
	case entity.FieldTypeBool:
		var bools []bool
		bools, ok = any(values).([]bool)
		scalars.Data = &schemapb.ScalarField_BoolData{
			BoolData: &schemapb.BoolArray{Data: bools},
		}
	case entity.FieldTypeInt8:
		var int8s []int8
		int8s, ok = any(values).([]int8)
		int32s := lo.Map(int8s, func(i8 int8, _ int) int32 { return int32(i8) })
		scalars.Data = &schemapb.ScalarField_IntData{
			IntData: &schemapb.IntArray{Data: int32s},
		}
	case entity.FieldTypeInt16:
		var int16s []int16
		int16s, ok = any(values).([]int16)
		int32s := lo.Map(int16s, func(i16 int16, _ int) int32 { return int32(i16) })
		scalars.Data = &schemapb.ScalarField_IntData{
			IntData: &schemapb.IntArray{Data: int32s},
		}
	case entity.FieldTypeInt32:
		var int32s []int32
		int32s, ok = any(values).([]int32)
		scalars.Data = &schemapb.ScalarField_IntData{
			IntData: &schemapb.IntArray{Data: int32s},
		}
	case entity.FieldTypeInt64:
		var int64s []int64
		int64s, ok = any(values).([]int64)
		scalars.Data = &schemapb.ScalarField_LongData{
			LongData: &schemapb.LongArray{Data: int64s},
		}
	case entity.FieldTypeVarChar, entity.FieldTypeString:
		var strVals []string
		strVals, ok = any(values).([]string)
		scalars.Data = &schemapb.ScalarField_StringData{
			StringData: &schemapb.StringArray{Data: strVals},
		}
	case entity.FieldTypeFloat:
		var floats []float32
		floats, ok = any(values).([]float32)
		scalars.Data = &schemapb.ScalarField_FloatData{
			FloatData: &schemapb.FloatArray{Data: floats},
		}
	case entity.FieldTypeDouble:
		var data []float64
		data, ok = any(values).([]float64)
		scalars.Data = &schemapb.ScalarField_DoubleData{
			DoubleData: &schemapb.DoubleArray{Data: data},
		}
	case entity.FieldTypeJSON:
		var data [][]byte
		data, ok = any(values).([][]byte)
		scalars.Data = &schemapb.ScalarField_JsonData{
			JsonData: &schemapb.JSONArray{
				Data: data,
			},
		}
	}
	// shall not be accessed
	if !ok {
		panic(fmt.Sprintf("unexpected values type(%T) of fieldType %v", values, fieldType))
	}
	return scalars
}

func values2Vectors[T any](values []T, fieldType entity.FieldType, dim int64) *schemapb.VectorField {
	vectorField := &schemapb.VectorField{
		Dim: dim,
	}
	var ok bool
	switch fieldType {
	case entity.FieldTypeFloatVector:
		var vectors []entity.FloatVector
		vectors, ok = any(values).([]entity.FloatVector)
		data := make([]float32, 0, int64(len(vectors))*dim)
		for _, vector := range vectors {
			data = append(data, vector...)
		}
		vectorField.Data = &schemapb.VectorField_FloatVector{
			FloatVector: &schemapb.FloatArray{
				Data: data,
			},
		}
	case entity.FieldTypeFloat16Vector:
		var vectors []entity.Float16Vector
		vectors, ok = any(values).([]entity.Float16Vector)
		data := make([]byte, 0, int64(len(vectors))*dim*2)
		for _, vector := range vectors {
			data = append(data, vector.Serialize()...)
		}
		vectorField.Data = &schemapb.VectorField_Float16Vector{
			Float16Vector: data,
		}
	case entity.FieldTypeBFloat16Vector:
		var vectors []entity.BFloat16Vector
		vectors, ok = any(values).([]entity.BFloat16Vector)
		data := make([]byte, 0, int64(len(vectors))*dim*2)
		for _, vector := range vectors {
			data = append(data, vector.Serialize()...)
		}
		vectorField.Data = &schemapb.VectorField_Bfloat16Vector{
			Bfloat16Vector: data,
		}
	case entity.FieldTypeBinaryVector:
		var vectors []entity.BinaryVector
		vectors, ok = any(values).([]entity.BinaryVector)
		data := make([]byte, 0, int64(len(vectors))*dim/8)
		for _, vector := range vectors {
			data = append(data, vector.Serialize()...)
		}
		vectorField.Data = &schemapb.VectorField_BinaryVector{
			BinaryVector: data,
		}
	case entity.FieldTypeSparseVector:
		var vectors []entity.SparseEmbedding
		vectors, ok = any(values).([]entity.SparseEmbedding)
		data := lo.Map(vectors, func(row entity.SparseEmbedding, _ int) []byte {
			return row.Serialize()
		})
		vectorField.Data = &schemapb.VectorField_SparseFloatVector{
			SparseFloatVector: &schemapb.SparseFloatArray{
				Contents: data,
			},
		}
	}

	if !ok {
		panic(fmt.Sprintf("unexpected values type(%T) of fieldType %v", values, fieldType))
	}
	return vectorField
}

func value2Type[T any, U any](v T) (U, error) {
	var z U
	switch v := any(v).(type) {
	case U:
		return v, nil
	default:
		return z, errors.Newf("cannot automatically convert %T to %T", v, z)
	}
}



---
File: /column/dynamic_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"testing"

	"github.com/stretchr/testify/suite"
)

type ColumnDynamicSuite struct {
	suite.Suite
}

func (s *ColumnDynamicSuite) TestGetInt() {
	cases := []struct {
		input       string
		expectErr   bool
		expectValue int64
	}{
		{`{"field": 1000000000000000001}`, false, 1000000000000000001},
		{`{"field": 4418489049307132905}`, false, 4418489049307132905},
		{`{"other_field": 4418489049307132905}`, true, 0},
		{`{"field": "string"}`, true, 0},
	}

	for _, c := range cases {
		s.Run(c.input, func() {
			column := NewColumnDynamic(NewColumnJSONBytes("", [][]byte{[]byte(c.input)}), "field")
			v, err := column.GetAsInt64(0)
			if c.expectErr {
				s.Error(err)
				return
			}
			s.NoError(err)
			s.Equal(c.expectValue, v)
		})
	}
}

func (s *ColumnDynamicSuite) TestGetString() {
	cases := []struct {
		input       string
		expectErr   bool
		expectValue string
	}{
		{`{"field": "abc"}`, false, "abc"},
		{`{"field": "test"}`, false, "test"},
		{`{"other_field": "string"}`, true, ""},
		{`{"field": 123}`, true, ""},
	}

	for _, c := range cases {
		s.Run(c.input, func() {
			// column := NewColumnDynamic(&ColumnJSONBytes{
			// 	values: [][]byte{[]byte(c.input)},
			// }, "field")
			column := NewColumnDynamic(NewColumnJSONBytes("", [][]byte{[]byte(c.input)}), "field")
			v, err := column.GetAsString(0)
			if c.expectErr {
				s.Error(err)
				return
			}
			s.NoError(err)
			s.Equal(c.expectValue, v)
		})
	}
}

func (s *ColumnDynamicSuite) TestGetBool() {
	cases := []struct {
		input       string
		expectErr   bool
		expectValue bool
	}{
		{`{"field": true}`, false, true},
		{`{"field": false}`, false, false},
		{`{"other_field": true}`, true, false},
		{`{"field": "test"}`, true, false},
	}

	for _, c := range cases {
		s.Run(c.input, func() {
			// column := NewColumnDynamic(&ColumnJSONBytes{
			// 	values: [][]byte{[]byte(c.input)},
			// }, "field")
			column := NewColumnDynamic(NewColumnJSONBytes("", [][]byte{[]byte(c.input)}), "field")
			v, err := column.GetAsBool(0)
			if c.expectErr {
				s.Error(err)
				return
			}
			s.NoError(err)
			s.Equal(c.expectValue, v)
		})
	}
}

func (s *ColumnDynamicSuite) TestGetDouble() {
	cases := []struct {
		input       string
		expectErr   bool
		expectValue float64
	}{
		{`{"field": 1}`, false, 1.0},
		{`{"field": 6231.123}`, false, 6231.123},
		{`{"other_field": 1.0}`, true, 0},
		{`{"field": "string"}`, true, 0},
	}

	for _, c := range cases {
		s.Run(c.input, func() {
			// column := NewColumnDynamic(&ColumnJSONBytes{
			// 	values: [][]byte{[]byte(c.input)},
			// }, "field")
			column := NewColumnDynamic(NewColumnJSONBytes("", [][]byte{[]byte(c.input)}), "field")
			v, err := column.GetAsDouble(0)
			if c.expectErr {
				s.Error(err)
				return
			}
			s.NoError(err)
			s.Less(v-c.expectValue, 1e-10)
		})
	}
}

func (s *ColumnDynamicSuite) TestIndexOutOfRange() {
	var err error
	column := NewColumnDynamic(NewColumnJSONBytes("", nil), "field")

	s.Equal("field", column.Name())

	_, err = column.GetAsInt64(0)
	s.Error(err)

	_, err = column.GetAsString(0)
	s.Error(err)

	_, err = column.GetAsBool(0)
	s.Error(err)

	_, err = column.GetAsDouble(0)
	s.Error(err)
}

func TestColumnDynamic(t *testing.T) {
	suite.Run(t, new(ColumnDynamicSuite))
}



---
File: /column/dynamic.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"github.com/cockroachdb/errors"
	"github.com/tidwall/gjson"
)

// ColumnDynamic is a logically wrapper for dynamic json field with provided output field.
type ColumnDynamic struct {
	*ColumnJSONBytes
	outputField string
}

func NewColumnDynamic(column *ColumnJSONBytes, outputField string) *ColumnDynamic {
	return &ColumnDynamic{
		ColumnJSONBytes: column,
		outputField:     outputField,
	}
}

func (c *ColumnDynamic) Name() string {
	return c.outputField
}

// Get returns element at idx as interface{}.
// Overrides internal json column behavior, returns raw json data.
func (c *ColumnDynamic) Get(idx int) (interface{}, error) {
	bs, err := c.ColumnJSONBytes.Value(idx)
	if err != nil {
		return 0, err
	}
	r := gjson.GetBytes(bs, c.outputField)
	if !r.Exists() {
		return 0, errors.New("column not has value")
	}
	return r.Raw, nil
}

func (c *ColumnDynamic) GetAsInt64(idx int) (int64, error) {
	bs, err := c.ColumnJSONBytes.Value(idx)
	if err != nil {
		return 0, err
	}
	r := gjson.GetBytes(bs, c.outputField)
	if !r.Exists() {
		return 0, errors.New("column not has value")
	}
	if r.Type != gjson.Number {
		return 0, errors.New("column not int")
	}
	return r.Int(), nil
}

func (c *ColumnDynamic) GetAsString(idx int) (string, error) {
	bs, err := c.ColumnJSONBytes.Value(idx)
	if err != nil {
		return "", err
	}
	r := gjson.GetBytes(bs, c.outputField)
	if !r.Exists() {
		return "", errors.New("column not has value")
	}
	if r.Type != gjson.String {
		return "", errors.New("column not string")
	}
	return r.String(), nil
}

func (c *ColumnDynamic) GetAsBool(idx int) (bool, error) {
	bs, err := c.ColumnJSONBytes.Value(idx)
	if err != nil {
		return false, err
	}
	r := gjson.GetBytes(bs, c.outputField)
	if !r.Exists() {
		return false, errors.New("column not has value")
	}
	if !r.IsBool() {
		return false, errors.New("column not string")
	}
	return r.Bool(), nil
}

func (c *ColumnDynamic) GetAsDouble(idx int) (float64, error) {
	bs, err := c.ColumnJSONBytes.Value(idx)
	if err != nil {
		return 0, err
	}
	r := gjson.GetBytes(bs, c.outputField)
	if !r.Exists() {
		return 0, errors.New("column not has value")
	}
	if r.Type != gjson.Number {
		return 0, errors.New("column not string")
	}
	return r.Float(), nil
}



---
File: /column/generic_base_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"fmt"
	"math/rand"
	"testing"

	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

type GenericBaseSuite struct {
	suite.Suite
}

func (s *GenericBaseSuite) TestBasic() {
	name := fmt.Sprintf("test_%d", rand.Intn(10))
	gb := &genericColumnBase[int64]{
		name:      name,
		fieldType: entity.FieldTypeInt64,
		values:    []int64{1, 2, 3},
	}

	s.Equal(name, gb.Name())
	s.Equal(entity.FieldTypeInt64, gb.Type())
	s.EqualValues(3, gb.Len())

	err := gb.AppendValue("abc")
	s.Error(err)
	s.EqualValues(3, gb.Len())

	err = gb.AppendValue(int64(4))
	s.NoError(err)
	s.EqualValues(4, gb.Len())
}

func (s *GenericBaseSuite) TestIndexAccess() {
	name := fmt.Sprintf("test_%d", rand.Intn(10))
	values := []int64{1, 2, 3}
	gb := &genericColumnBase[int64]{
		name:      name,
		fieldType: entity.FieldTypeInt64,
		values:    values,
	}

	for idx, value := range values {
		v, err := gb.Value(idx)
		s.NoError(err)
		s.Equal(value, v)

		s.NotPanics(func() {
			v = gb.MustValue(idx)
		})
		s.Equal(value, v)
	}

	s.Panics(func() {
		gb.MustValue(-1)
	}, "out of range, negative index")

	s.Panics(func() {
		gb.MustValue(3)
	}, "out of range, LTE len")

	s.NotPanics(func() {
		_, err := gb.Value(-1)
		s.Error(err)

		_, err = gb.Value(3)
		s.Error(err)
	})
}

func (s *GenericBaseSuite) TestIndexAccess_Nullable() {
	name := fmt.Sprintf("test_%d", rand.Intn(10))

	s.Run("compact_mode", func() {
		values := []int64{1, 2, 3}
		validData := []bool{true, false, true, false, true}
		gb := &genericColumnBase[int64]{
			name:       name,
			fieldType:  entity.FieldTypeInt64,
			values:     values,
			nullable:   true,
			validData:  validData,
			sparseMode: false,
		}

		err := gb.ValidateNullable()
		s.NoError(err)

		for idx, valid := range validData {
			if valid {
				v, err := gb.Value(idx)
				s.NoError(err)
				s.Equal(values[gb.indexMapping[idx]], v)

				s.NotPanics(func() {
					v = gb.MustValue(idx)
				})
				s.Equal(values[gb.indexMapping[idx]], v)
			} else {
				result, err := gb.IsNull(idx)
				s.NoError(err)
				s.True(result)

				_, err = gb.Value(idx)
				s.Error(err)
			}
		}
	})

	s.Run("sparse_mode", func() {
		values := []int64{1, 0, 2, 0, 3}
		validData := []bool{true, false, true, false, true}
		gb := &genericColumnBase[int64]{
			name:       name,
			fieldType:  entity.FieldTypeInt64,
			values:     values,
			nullable:   true,
			validData:  validData,
			sparseMode: true,
		}

		err := gb.ValidateNullable()
		s.NoError(err)

		for idx, valid := range validData {
			if valid {
				v, err := gb.Value(idx)
				s.NoError(err)
				s.Equal(values[idx], v)

				s.NotPanics(func() {
					v = gb.MustValue(idx)
				})
				s.Equal(values[idx], v)
			} else {
				result, err := gb.IsNull(idx)
				s.NoError(err)
				s.True(result)

				_, err = gb.Value(idx)
				s.NoError(err)
			}
		}
	})
}

func (s *GenericBaseSuite) TestSlice() {
	name := fmt.Sprintf("test_%d", rand.Intn(10))
	values := []int64{1, 2, 3}
	gb := &genericColumnBase[int64]{
		name:      name,
		fieldType: entity.FieldTypeInt64,
		values:    values,
	}

	l := rand.Intn(3)
	another := gb.Slice(0, l)
	s.Equal(l, another.Len())
	agb, ok := another.(*genericColumnBase[int64])
	s.Require().True(ok)

	for i := 0; i < l; i++ {
		s.Equal(gb.MustValue(i), agb.MustValue(i))
	}

	s.NotPanics(func() {
		agb := gb.Slice(10, 10)
		s.Equal(0, agb.Len())
	})
}

func (s *GenericBaseSuite) TestFieldData() {
	name := fmt.Sprintf("test_%d", rand.Intn(10))
	values := []int64{1, 2, 3}
	gb := &genericColumnBase[int64]{
		name:      name,
		fieldType: entity.FieldTypeInt64,
		values:    values,
	}

	fd := gb.FieldData()
	s.Equal(name, fd.GetFieldName())
	s.Equal(schemapb.DataType_Int64, fd.GetType())
}

func (s *GenericBaseSuite) TestConversion() {
	name := fmt.Sprintf("test_%d", rand.Intn(10))
	values := []int64{1, 2, 3}
	gb := &genericColumnBase[int64]{
		name:      name,
		fieldType: entity.FieldTypeInt64,
		values:    values,
	}

	val, err := gb.GetAsInt64(0)
	s.NoError(err)
	s.EqualValues(1, val)

	_, err = gb.GetAsBool(0)
	s.Error(err)

	_, err = gb.GetAsString(0)
	s.Error(err)

	_, err = gb.GetAsDouble(0)
	s.Error(err)

	strValues := []string{"1", "2", "3"}
	strGb := &genericColumnBase[string]{
		name:      name,
		fieldType: entity.FieldTypeVarChar,
		values:    strValues,
	}
	sv, err := strGb.GetAsString(0)
	s.NoError(err)
	s.Equal("1", sv)
}

func (s *GenericBaseSuite) TestNullable() {
	name := fmt.Sprintf("test_%d", rand.Intn(10))
	var values []int64
	gb := &genericColumnBase[int64]{
		name:      name,
		fieldType: entity.FieldTypeInt64,
		values:    values,
	}

	s.False(gb.Nullable())
	s.NoError(gb.ValidateNullable())
	s.Error(gb.AppendNull())
	s.EqualValues(0, gb.Len())

	gb.SetNullable(true)
	s.NoError(gb.ValidateNullable())
	s.NoError(gb.AppendNull())
	s.EqualValues(1, gb.Len())

	gb.SetNullable(false)
	s.NoError(gb.ValidateNullable())
	s.EqualValues(0, gb.Len())

	gb = &genericColumnBase[int64]{
		name:       name,
		fieldType:  entity.FieldTypeInt64,
		values:     []int64{0},
		validData:  []bool{true, false},
		sparseMode: true,
		nullable:   true,
	}
	s.Error(gb.ValidateNullable())
}

func TestGenericBase(t *testing.T) {
	suite.Run(t, new(GenericBaseSuite))
}



---
File: /column/generic_base.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"github.com/cockroachdb/errors"
	"github.com/samber/lo"

	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

type GColumn[T any] interface {
	Value(idx int) T
	AppendValue(v T)
}

var _ Column = (*genericColumnBase[any])(nil)

// genericColumnBase implements `Column` interface
// it provides the basic function for each scalar params
type genericColumnBase[T any] struct {
	name      string
	fieldType entity.FieldType
	values    []T

	// nullable related fields
	// note that nullable must be set to true explicitly
	nullable  bool
	validData []bool
	// nullable column could be presented in two modes
	// - compactMode, in which all valid data are compacted into one slice
	// - sparseMode, in which valid data are located in its index position
	// while invalid one are filled with zero value.
	// for Milvus 2.5.x and before, insert request shall be in compactMode while
	// search & query results are formed in sparseMode
	// this flag indicates which form current column are in and peform validation
	// or conversion logical based on it
	sparseMode bool
	// indexMapping stores the compact-sparse mapping
	indexMapping []int
}

// Name returns column name.
func (c *genericColumnBase[T]) Name() string {
	return c.name
}

// Type returns corresponding field type.
// note that: it is not necessary to be 1-on-1 mapping
// say, `[]byte` could be lots of field type.
func (c *genericColumnBase[T]) Type() entity.FieldType {
	return c.fieldType
}

func (c *genericColumnBase[T]) Len() int {
	if c.validData != nil {
		return len(c.validData)
	}
	return len(c.values)
}

func (c *genericColumnBase[T]) AppendValue(a any) error {
	if a == nil {
		return c.AppendNull()
	}
	v, ok := a.(T)
	if !ok {
		return errors.Newf("unexpected append value type %T, field type %v", a, c.fieldType)
	}
	c.values = append(c.values, v)
	if c.nullable {
		c.validData = append(c.validData, true)
		c.indexMapping = append(c.indexMapping, len(c.values)-1)
	}
	return nil
}

func (c *genericColumnBase[T]) Slice(start, end int) Column {
	return c.slice(start, end)
}

// WARNING: this methods works only for sparse mode column
func (c *genericColumnBase[T]) slice(start, end int) *genericColumnBase[T] {
	l := c.Len()
	if start > l {
		start = l
	}
	if end == -1 || end > l {
		end = l
	}
	result := &genericColumnBase[T]{
		name:       c.name,
		fieldType:  c.fieldType,
		values:     c.values[start:end],
		nullable:   c.nullable,
		sparseMode: c.sparseMode,
	}
	if c.nullable {
		result.validData = c.validData[start:end]
	}
	return result
}

func (c *genericColumnBase[T]) FieldData() *schemapb.FieldData {
	fd := values2FieldData(c.values, c.fieldType, 0)
	fd.FieldName = c.name
	fd.Type = schemapb.DataType(c.fieldType)
	if c.nullable {
		fd.ValidData = c.validData
	}
	return fd
}

func (c *genericColumnBase[T]) rangeCheck(idx int) error {
	if idx < 0 || idx >= c.Len() {
		return errors.Newf("index %d out of range[0, %d)", idx, c.Len())
	}
	return nil
}

func (c *genericColumnBase[T]) Get(idx int) (any, error) {
	idx = c.valueIndex(idx)
	if err := c.rangeCheck(idx); err != nil {
		return nil, err
	}
	return c.values[idx], nil
}

func (c *genericColumnBase[T]) GetAsInt64(idx int) (int64, error) {
	idx = c.valueIndex(idx)
	if err := c.rangeCheck(idx); err != nil {
		return 0, err
	}
	return value2Type[T, int64](c.values[idx])
}

func (c *genericColumnBase[T]) GetAsString(idx int) (string, error) {
	idx = c.valueIndex(idx)
	if err := c.rangeCheck(idx); err != nil {
		return "", err
	}
	return value2Type[T, string](c.values[idx])
}

func (c *genericColumnBase[T]) GetAsDouble(idx int) (float64, error) {
	idx = c.valueIndex(idx)
	if err := c.rangeCheck(idx); err != nil {
		return 0, err
	}
	return value2Type[T, float64](c.values[idx])
}

func (c *genericColumnBase[T]) GetAsBool(idx int) (bool, error) {
	idx = c.valueIndex(idx)
	if err := c.rangeCheck(idx); err != nil {
		return false, err
	}
	return value2Type[T, bool](c.values[idx])
}

func (c *genericColumnBase[T]) Value(idx int) (T, error) {
	idx = c.valueIndex(idx)
	var z T
	if err := c.rangeCheck(idx); err != nil {
		return z, err
	}
	return c.values[idx], nil
}

func (c *genericColumnBase[T]) valueIndex(idx int) int {
	if !c.nullable || c.sparseMode {
		return idx
	}
	return c.indexMapping[idx]
}

func (c *genericColumnBase[T]) Data() []T {
	return c.values
}

func (c *genericColumnBase[T]) MustValue(idx int) T {
	idx = c.valueIndex(idx)
	if idx < 0 || idx > c.Len() {
		panic("index out of range")
	}
	return c.values[idx]
}

func (c *genericColumnBase[T]) AppendNull() error {
	if !c.nullable {
		return errors.New("append null to not nullable column")
	}

	c.validData = append(c.validData, false)
	if !c.sparseMode {
		c.indexMapping = append(c.indexMapping, -1)
	}
	return nil
}

func (c *genericColumnBase[T]) IsNull(idx int) (bool, error) {
	if err := c.rangeCheck(idx); err != nil {
		return false, err
	}
	if !c.nullable {
		return false, nil
	}
	return !c.validData[idx], nil
}

func (c *genericColumnBase[T]) Nullable() bool {
	return c.nullable
}

// SetNullable update the nullable flag and change the valid data array according to the flag value.
// NOTE: set nullable to false will erase all the validData previously set.
func (c *genericColumnBase[T]) SetNullable(nullable bool) {
	c.nullable = nullable
	// initialize validData only when
	if c.nullable && c.validData == nil {
		// set valid flag for all exisiting values
		c.validData = lo.RepeatBy(len(c.values), func(_ int) bool { return true })
	}

	if !c.nullable {
		c.validData = nil
	}
}

// ValidateNullable performs the sanity check for nullable column.
// it checks the length of data and the valid number indicated by validData slice,
// which shall be the same by definition
func (c *genericColumnBase[T]) ValidateNullable() error {
	// skip check if column not nullable
	if !c.nullable {
		return nil
	}

	if c.sparseMode {
		return c.validateNullableSparse()
	}
	return c.validateNullableCompact()
}

func (c *genericColumnBase[T]) validateNullableCompact() error {
	// count valid entries
	var validCnt int
	c.indexMapping = make([]int, len(c.validData))
	for idx, v := range c.validData {
		if v {
			c.indexMapping[idx] = validCnt
			validCnt++
		} else {
			c.indexMapping[idx] = -1
		}
	}
	if validCnt != len(c.values) {
		return errors.Newf("values number(%d) does not match valid count(%d)", len(c.values), validCnt)
	}
	return nil
}

func (c *genericColumnBase[T]) validateNullableSparse() error {
	if len(c.validData) != len(c.values) {
		return errors.Newf("values number (%d) does not match valid data len(%d)", len(c.values), len(c.validData))
	}
	return nil
}

func (c *genericColumnBase[T]) CompactNullableValues() {
	if !c.nullable || !c.sparseMode {
		return
	}

	c.indexMapping = make([]int, len(c.validData))
	var cnt int
	for idx, valid := range c.validData {
		if !valid {
			c.indexMapping[idx] = -1
			continue
		}
		c.values[cnt] = c.values[idx]
		c.indexMapping[idx] = cnt
		cnt++
	}
	c.values = c.values[0:cnt]
}

func (c *genericColumnBase[T]) withValidData(validData []bool) {
	if len(validData) > 0 {
		c.nullable = true
		c.validData = validData
	}
}

func (c *genericColumnBase[T]) base() *genericColumnBase[T] {
	return c
}

type ColumnOption[T any] func(*genericColumnBase[T])

// WithSparseNullableMode returns a ColumnOption that sets the sparse mode for the column.
func WithSparseNullableMode[T any](flag bool) ColumnOption[T] {
	return func(c *genericColumnBase[T]) {
		c.sparseMode = flag
	}
}



---
File: /column/json_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"fmt"
	"math/rand"
	"testing"
	"time"

	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus/client/v2/entity"
)

type ColumnJSONBytesSuite struct {
	suite.Suite
}

func (s *ColumnJSONBytesSuite) SetupSuite() {
	rand.Seed(time.Now().UnixNano())
}

func (s *ColumnJSONBytesSuite) TestAttrMethods() {
	columnName := fmt.Sprintf("column_jsonbs_%d", rand.Int())
	columnLen := 8 + rand.Intn(10)

	v := make([][]byte, columnLen)
	column := NewColumnJSONBytes(columnName, v).WithIsDynamic(true)

	s.Run("test_meta", func() {
		ft := entity.FieldTypeJSON
		s.Equal("JSON", ft.Name())
		s.Equal("JSON", ft.String())
		pbName, pbType := ft.PbFieldType()
		s.Equal("JSON", pbName)
		s.Equal("JSON", pbType)
	})

	s.Run("test_column_attribute", func() {
		s.Equal(columnName, column.Name())
		s.Equal(entity.FieldTypeJSON, column.Type())
		s.Equal(columnLen, column.Len())
		s.EqualValues(v, column.Data())
	})

	s.Run("test_column_field_data", func() {
		fd := column.FieldData()
		s.NotNil(fd)
		s.Equal(fd.GetFieldName(), columnName)

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnJSONBytes)
		if s.True(ok) {
			s.Equal(columnName, parsed.Name())
			s.Equal(entity.FieldTypeJSON, parsed.Type())
			s.Equal(v, parsed.Data())
		}
	})

	s.Run("test_column_valuer_by_idx", func() {
		_, err := column.Value(-1)
		s.Error(err)
		_, err = column.Value(columnLen)
		s.Error(err)
		for i := 0; i < columnLen; i++ {
			v, err := column.Value(i)
			s.NoError(err)
			s.Equal(column.values[i], v)
		}
	})

	s.Run("test_append_value", func() {
		item := make([]byte, 10)
		err := column.AppendValue(item)
		s.NoError(err)
		s.Equal(columnLen+1, column.Len())
		val, err := column.Value(columnLen)
		s.NoError(err)
		s.Equal(item, val)

		err = column.AppendValue(&struct{ Tag string }{Tag: "abc"})
		s.NoError(err)

		err = column.AppendValue(map[string]interface{}{"Value": 123})
		s.NoError(err)

		err = column.AppendValue(1)
		s.Error(err)
	})
}

func TestColumnJSONBytes(t *testing.T) {
	suite.Run(t, new(ColumnJSONBytesSuite))
}



---
File: /column/json.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

var _ (Column) = (*ColumnVarChar)(nil)

type ColumnJSONBytes struct {
	*genericColumnBase[[]byte]
	isDynamic bool
}

func NewColumnJSONBytes(name string, values [][]byte) *ColumnJSONBytes {
	return &ColumnJSONBytes{
		genericColumnBase: &genericColumnBase[[]byte]{
			name:      name,
			fieldType: entity.FieldTypeJSON,
			values:    values,
		},
	}
}

func (c *ColumnJSONBytes) Slice(start, end int) Column {
	return &ColumnJSONBytes{
		genericColumnBase: c.genericColumnBase.slice(start, end),
	}
}

func (c *ColumnJSONBytes) WithIsDynamic(isDynamic bool) *ColumnJSONBytes {
	c.isDynamic = isDynamic
	return c
}

func (c *ColumnJSONBytes) FieldData() *schemapb.FieldData {
	fd := c.genericColumnBase.FieldData()
	fd.IsDynamic = c.isDynamic
	return fd
}

// AppendValue append value into column.
func (c *ColumnJSONBytes) AppendValue(i interface{}) error {
	var v []byte
	switch raw := i.(type) {
	case []byte:
		v = raw
	default:
		k := reflect.TypeOf(i).Kind()
		if k == reflect.Ptr {
			k = reflect.TypeOf(i).Elem().Kind()
		}
		switch k {
		case reflect.Struct:
			fallthrough
		case reflect.Map:
			bs, err := json.Marshal(raw)
			if err != nil {
				return err
			}
			v = bs
		default:
			return fmt.Errorf("expect json compatible type([]byte, struct, map), got %T", i)
		}
	}
	c.values = append(c.values, v)

	return nil
}



---
File: /column/nullable_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"fmt"
	"math/rand"
	"testing"

	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus/client/v2/entity"
)

type NullableScalarSuite struct {
	suite.Suite
}

func (s *NullableScalarSuite) TestBasic() {
	s.Run("nullable_bool", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		compactData := []bool{false}
		sparseData := []bool{false, false}
		validData := []bool{true, false}
		// compact mode
		column, err := NewNullableColumnBool(name, compactData, validData)
		s.NoError(err)
		s.Equal(entity.FieldTypeBool, column.Type())
		s.Equal(name, column.Name())
		s.Equal(compactData, column.Data())
		for i := 0; i < len(validData); i++ {
			r, err := column.IsNull(i)
			s.NoError(err)
			s.Equal(validData[i], !r)
		}
		s.NoError(column.AppendValue(true))
		s.NoError(column.AppendNull())

		// sparse mode
		column, err = NewNullableColumnBool(name, sparseData, validData, WithSparseNullableMode[bool](true))
		s.NoError(err)
		s.Equal(sparseData, column.Data())

		fd := column.FieldData()
		s.Equal(validData, fd.GetValidData())
		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnBool)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(sparseData, parsed.Data())
			s.Equal(entity.FieldTypeBool, column.Type())
		}

		_, err = NewNullableColumnBool(name, compactData, []bool{false, false})
		s.Error(err)
	})

	s.Run("nullable_int8", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		compactData := []int8{1, 3}
		sparseData := []int8{1, 0, 3}
		validData := []bool{true, false, true}
		// compact mode
		column, err := NewNullableColumnInt8(name, compactData, validData)
		s.NoError(err)
		s.Equal(entity.FieldTypeInt8, column.Type())
		s.Equal(name, column.Name())
		s.Equal(compactData, column.Data())
		for i := 0; i < len(validData); i++ {
			r, err := column.IsNull(i)
			s.NoError(err)
			s.Equal(validData[i], !r)
		}

		// sparse mode
		column, err = NewNullableColumnInt8(name, sparseData, validData, WithSparseNullableMode[int8](true))
		s.NoError(err)

		fd := column.FieldData()
		s.Equal(validData, fd.GetValidData())
		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnInt8)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(sparseData, parsed.Data())
			s.Equal(entity.FieldTypeInt8, column.Type())
		}

		_, err = NewNullableColumnInt8(name, compactData, []bool{false, false})
		s.Error(err)
	})

	s.Run("nullable_int16", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		compactData := []int16{1, 3}
		sparseData := []int16{1, 0, 3}
		validData := []bool{true, false, true}
		// compact mode
		column, err := NewNullableColumnInt16(name, compactData, validData)
		s.NoError(err)
		s.Equal(entity.FieldTypeInt16, column.Type())
		s.Equal(name, column.Name())
		s.Equal(compactData, column.Data())
		for i := 0; i < len(validData); i++ {
			r, err := column.IsNull(i)
			s.NoError(err)
			s.Equal(validData[i], !r)
		}

		// compact mode
		column, err = NewNullableColumnInt16(name, sparseData, validData, WithSparseNullableMode[int16](true))
		s.NoError(err)

		fd := column.FieldData()
		s.Equal(validData, fd.GetValidData())
		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnInt16)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(sparseData, parsed.Data())
			s.Equal(entity.FieldTypeInt16, column.Type())
		}

		_, err = NewNullableColumnInt16(name, compactData, []bool{false, false})
		s.Error(err)
	})

	s.Run("nullable_int32", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		compactData := []int32{1, 3}
		sparseData := []int32{1, 0, 3}
		validData := []bool{true, false, true}
		// compact mode
		column, err := NewNullableColumnInt32(name, compactData, validData)
		s.NoError(err)
		s.Equal(entity.FieldTypeInt32, column.Type())
		s.Equal(name, column.Name())
		s.Equal(compactData, column.Data())
		for i := 0; i < len(validData); i++ {
			r, err := column.IsNull(i)
			s.NoError(err)
			s.Equal(validData[i], !r)
		}

		// compact mode
		column, err = NewNullableColumnInt32(name, sparseData, validData, WithSparseNullableMode[int32](true))
		s.NoError(err)

		fd := column.FieldData()
		s.Equal(validData, fd.GetValidData())
		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnInt32)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(sparseData, parsed.Data())
			s.Equal(entity.FieldTypeInt32, column.Type())
		}

		_, err = NewNullableColumnInt32(name, compactData, []bool{false, false})
		s.Error(err)
	})

	s.Run("nullable_int64", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		compactData := []int64{1, 3}
		sparseData := []int64{1, 0, 3}
		validData := []bool{true, false, true}
		// compact mode
		column, err := NewNullableColumnInt64(name, compactData, validData)
		s.NoError(err)
		s.Equal(entity.FieldTypeInt64, column.Type())
		s.Equal(name, column.Name())
		s.Equal(compactData, column.Data())
		for i := 0; i < len(validData); i++ {
			r, err := column.IsNull(i)
			s.NoError(err)
			s.Equal(validData[i], !r)
		}

		// compact mode
		column, err = NewNullableColumnInt64(name, sparseData, validData, WithSparseNullableMode[int64](true))
		s.NoError(err)

		fd := column.FieldData()
		s.Equal(validData, fd.GetValidData())
		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnInt64)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(sparseData, parsed.Data())
			s.Equal(entity.FieldTypeInt64, column.Type())
		}

		_, err = NewNullableColumnInt64(name, compactData, []bool{false, false})
		s.Error(err)
	})

	s.Run("nullable_float", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		compactData := []float32{0.1, 0.3}
		sparseData := []float32{0.1, 0, 0.3}
		validData := []bool{true, false, true}
		// compact mode
		column, err := NewNullableColumnFloat(name, compactData, validData)
		s.NoError(err)
		s.Equal(entity.FieldTypeFloat, column.Type())
		s.Equal(name, column.Name())
		s.Equal(compactData, column.Data())
		for i := 0; i < len(validData); i++ {
			r, err := column.IsNull(i)
			s.NoError(err)
			s.Equal(validData[i], !r)
		}

		// sparse mode
		column, err = NewNullableColumnFloat(name, sparseData, validData, WithSparseNullableMode[float32](true))
		s.NoError(err)

		fd := column.FieldData()
		s.Equal(validData, fd.GetValidData())
		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnFloat)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(sparseData, parsed.Data())
			s.Equal(entity.FieldTypeFloat, column.Type())
		}

		_, err = NewNullableColumnFloat(name, compactData, []bool{false, false})
		s.Error(err)
	})

	s.Run("nullable_double", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		compactData := []float64{0.1, 0.3}
		sparseData := []float64{0.1, 0, 0.3}
		validData := []bool{true, false, true}
		// compact data
		column, err := NewNullableColumnDouble(name, compactData, validData)
		s.NoError(err)
		s.Equal(entity.FieldTypeDouble, column.Type())
		s.Equal(name, column.Name())
		s.Equal(compactData, column.Data())
		for i := 0; i < len(validData); i++ {
			r, err := column.IsNull(i)
			s.NoError(err)
			s.Equal(validData[i], !r)
		}

		// sparse data
		column, err = NewNullableColumnDouble(name, sparseData, validData, WithSparseNullableMode[float64](true))
		s.NoError(err)

		fd := column.FieldData()
		s.Equal(validData, fd.GetValidData())
		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnDouble)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(sparseData, parsed.Data())
			s.Equal(entity.FieldTypeDouble, column.Type())
		}

		_, err = NewNullableColumnDouble(name, compactData, []bool{false, false})
		s.Error(err)
	})
}

func TestNullableScalar(t *testing.T) {
	suite.Run(t, new(NullableScalarSuite))
}



---
File: /column/nullable.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

var (
	// scalars
	NewNullableColumnBool      NullableColumnCreateFunc[bool, *ColumnBool]        = NewNullableColumnCreator(NewColumnBool).New
	NewNullableColumnInt8      NullableColumnCreateFunc[int8, *ColumnInt8]        = NewNullableColumnCreator(NewColumnInt8).New
	NewNullableColumnInt16     NullableColumnCreateFunc[int16, *ColumnInt16]      = NewNullableColumnCreator(NewColumnInt16).New
	NewNullableColumnInt32     NullableColumnCreateFunc[int32, *ColumnInt32]      = NewNullableColumnCreator(NewColumnInt32).New
	NewNullableColumnInt64     NullableColumnCreateFunc[int64, *ColumnInt64]      = NewNullableColumnCreator(NewColumnInt64).New
	NewNullableColumnVarChar   NullableColumnCreateFunc[string, *ColumnVarChar]   = NewNullableColumnCreator(NewColumnVarChar).New
	NewNullableColumnString    NullableColumnCreateFunc[string, *ColumnString]    = NewNullableColumnCreator(NewColumnString).New
	NewNullableColumnFloat     NullableColumnCreateFunc[float32, *ColumnFloat]    = NewNullableColumnCreator(NewColumnFloat).New
	NewNullableColumnDouble    NullableColumnCreateFunc[float64, *ColumnDouble]   = NewNullableColumnCreator(NewColumnDouble).New
	NewNullableColumnJSONBytes NullableColumnCreateFunc[[]byte, *ColumnJSONBytes] = NewNullableColumnCreator(NewColumnJSONBytes).New
	// array
	NewNullableColumnBoolArray    NullableColumnCreateFunc[[]bool, *ColumnBoolArray]      = NewNullableColumnCreator(NewColumnBoolArray).New
	NewNullableColumnInt8Array    NullableColumnCreateFunc[[]int8, *ColumnInt8Array]      = NewNullableColumnCreator(NewColumnInt8Array).New
	NewNullableColumnInt16Array   NullableColumnCreateFunc[[]int16, *ColumnInt16Array]    = NewNullableColumnCreator(NewColumnInt16Array).New
	NewNullableColumnInt32Array   NullableColumnCreateFunc[[]int32, *ColumnInt32Array]    = NewNullableColumnCreator(NewColumnInt32Array).New
	NewNullableColumnInt64Array   NullableColumnCreateFunc[[]int64, *ColumnInt64Array]    = NewNullableColumnCreator(NewColumnInt64Array).New
	NewNullableColumnVarCharArray NullableColumnCreateFunc[[]string, *ColumnVarCharArray] = NewNullableColumnCreator(NewColumnVarCharArray).New
	NewNullableColumnFloatArray   NullableColumnCreateFunc[[]float32, *ColumnFloatArray]  = NewNullableColumnCreator(NewColumnFloatArray).New
	NewNullableColumnDoubleArray  NullableColumnCreateFunc[[]float64, *ColumnDoubleArray] = NewNullableColumnCreator(NewColumnDoubleArray).New
)

type NullableColumnCreateFunc[T any, Col interface {
	Column
	Data() []T
}] func(name string, values []T, validData []bool, opts ...ColumnOption[T]) (Col, error)

type NullableColumnCreator[col interface {
	Column
	withValidData([]bool)
	base() *genericColumnBase[T]
}, T any] struct {
	base func(name string, values []T) col
}

func (c NullableColumnCreator[col, T]) New(name string, values []T, validData []bool, opts ...ColumnOption[T]) (col, error) {
	result := c.base(name, values)
	result.withValidData(validData)
	base := result.base()

	for _, opt := range opts {
		opt(base)
	}

	return result, result.ValidateNullable()
}

func NewNullableColumnCreator[col interface {
	Column
	withValidData([]bool)
	base() *genericColumnBase[T]
}, T any](base func(name string, values []T) col) NullableColumnCreator[col, T] {
	return NullableColumnCreator[col, T]{
		base: base,
	}
}



---
File: /column/scalar_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"fmt"
	"math"
	"math/rand"
	"testing"

	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus/client/v2/entity"
)

type ScalarSuite struct {
	suite.Suite
}

func (s *ScalarSuite) TestBasic() {
	s.Run("column_bool", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := []bool{true, false}
		column := NewColumnBool(name, data)
		s.Equal(entity.FieldTypeBool, column.Type())
		s.Equal(name, column.Name())
		s.Equal(data, column.Data())

		fd := column.FieldData()
		s.Equal(name, fd.GetFieldName())
		s.Equal(data, fd.GetScalars().GetBoolData().GetData())

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnBool)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeBool, column.Type())
		}
	})

	s.Run("column_int8", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := []int8{1, 2, 3}
		column := NewColumnInt8(name, data)
		s.Equal(entity.FieldTypeInt8, column.Type())
		s.Equal(name, column.Name())
		s.Equal(data, column.Data())

		fd := column.FieldData()
		s.Equal(name, fd.GetFieldName())
		fdData := fd.GetScalars().GetIntData().GetData()
		for i, row := range data {
			s.EqualValues(row, fdData[i])
		}

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnInt8)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeInt8, column.Type())
		}
	})

	s.Run("column_int16", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := []int16{1, 2, 3}
		column := NewColumnInt16(name, data)
		s.Equal(entity.FieldTypeInt16, column.Type())
		s.Equal(name, column.Name())
		s.Equal(data, column.Data())

		fd := column.FieldData()
		s.Equal(name, fd.GetFieldName())
		fdData := fd.GetScalars().GetIntData().GetData()
		for i, row := range data {
			s.EqualValues(row, fdData[i])
		}

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnInt16)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeInt16, column.Type())
		}
	})

	s.Run("column_int32", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := []int32{1, 2, 3}
		column := NewColumnInt32(name, data)
		s.Equal(entity.FieldTypeInt32, column.Type())
		s.Equal(name, column.Name())
		s.Equal(data, column.Data())

		fd := column.FieldData()
		s.Equal(name, fd.GetFieldName())
		s.Equal(data, fd.GetScalars().GetIntData().GetData())

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnInt32)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeInt32, column.Type())
		}
	})

	s.Run("column_int64", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := []int64{1, 2, 3}
		column := NewColumnInt64(name, data)
		s.Equal(entity.FieldTypeInt64, column.Type())
		s.Equal(name, column.Name())
		s.Equal(data, column.Data())

		fd := column.FieldData()
		s.Equal(name, fd.GetFieldName())
		s.Equal(data, fd.GetScalars().GetLongData().GetData())

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnInt64)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeInt64, column.Type())
		}
	})

	s.Run("column_float", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := []float32{1.1, 2.2, 3.3}
		column := NewColumnFloat(name, data)
		s.Equal(entity.FieldTypeFloat, column.Type())
		s.Equal(name, column.Name())
		s.Equal(data, column.Data())

		fd := column.FieldData()
		s.Equal(name, fd.GetFieldName())
		s.Equal(data, fd.GetScalars().GetFloatData().GetData())

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnFloat)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeFloat, column.Type())
		}
	})

	s.Run("column_double", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := []float64{1.1, 2.2, 3.3}
		column := NewColumnDouble(name, data)
		s.Equal(entity.FieldTypeDouble, column.Type())
		s.Equal(name, column.Name())
		s.Equal(data, column.Data())

		fd := column.FieldData()
		s.Equal(name, fd.GetFieldName())
		s.Equal(data, fd.GetScalars().GetDoubleData().GetData())

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnDouble)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeDouble, column.Type())
		}
	})

	s.Run("column_varchar", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := []string{"a", "b", "c"}
		column := NewColumnVarChar(name, data)
		s.Equal(entity.FieldTypeVarChar, column.Type())
		s.Equal(name, column.Name())
		s.Equal(data, column.Data())

		fd := column.FieldData()
		s.Equal(name, fd.GetFieldName())
		s.Equal(data, fd.GetScalars().GetStringData().GetData())

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnVarChar)
		if s.True(ok) {
			s.Equal(name, parsed.Name())
			s.Equal(data, parsed.Data())
			s.Equal(entity.FieldTypeVarChar, column.Type())
		}
	})
}

func (s *ScalarSuite) TestSlice() {
	n := 100
	s.Run("column_bool", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := make([]bool, 0, n)
		for i := 0; i < 100; i++ {
			data = append(data, rand.Int()%2 == 0)
		}
		column := NewColumnBool(name, data)

		l := rand.Intn(n)
		sliced := column.Slice(0, l)
		slicedColumn, ok := sliced.(*ColumnBool)
		if s.True(ok) {
			s.Equal(column.Type(), slicedColumn.Type())
			s.Equal(data[:l], slicedColumn.Data())
		}
	})

	s.Run("column_int8", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := make([]int8, 0, n)
		for i := 0; i < 100; i++ {
			data = append(data, int8(rand.Intn(math.MaxInt8)))
		}
		column := NewColumnInt8(name, data)

		l := rand.Intn(n)
		sliced := column.Slice(0, l)
		slicedColumn, ok := sliced.(*ColumnInt8)
		if s.True(ok) {
			s.Equal(column.Type(), slicedColumn.Type())
			s.Equal(data[:l], slicedColumn.Data())
		}
	})

	s.Run("column_int16", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := make([]int16, 0, n)
		for i := 0; i < 100; i++ {
			data = append(data, int16(rand.Intn(math.MaxInt16)))
		}
		column := NewColumnInt16(name, data)

		l := rand.Intn(n)
		sliced := column.Slice(0, l)
		slicedColumn, ok := sliced.(*ColumnInt16)
		if s.True(ok) {
			s.Equal(column.Type(), slicedColumn.Type())
			s.Equal(data[:l], slicedColumn.Data())
		}
	})

	s.Run("column_int32", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := make([]int32, 0, n)
		for i := 0; i < 100; i++ {
			data = append(data, rand.Int31())
		}
		column := NewColumnInt32(name, data)

		l := rand.Intn(n)
		sliced := column.Slice(0, l)
		slicedColumn, ok := sliced.(*ColumnInt32)
		if s.True(ok) {
			s.Equal(column.Type(), slicedColumn.Type())
			s.Equal(data[:l], slicedColumn.Data())
		}
	})

	s.Run("column_int64", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := make([]int64, 0, n)
		for i := 0; i < 100; i++ {
			data = append(data, rand.Int63())
		}
		column := NewColumnInt64(name, data)

		l := rand.Intn(n)
		sliced := column.Slice(0, l)
		slicedColumn, ok := sliced.(*ColumnInt64)
		if s.True(ok) {
			s.Equal(column.Type(), slicedColumn.Type())
			s.Equal(data[:l], slicedColumn.Data())
		}
	})

	s.Run("column_float", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := make([]float32, 0, n)
		for i := 0; i < 100; i++ {
			data = append(data, rand.Float32())
		}
		column := NewColumnFloat(name, data)

		l := rand.Intn(n)
		sliced := column.Slice(0, l)
		slicedColumn, ok := sliced.(*ColumnFloat)
		if s.True(ok) {
			s.Equal(column.Type(), slicedColumn.Type())
			s.Equal(data[:l], slicedColumn.Data())
		}
	})

	s.Run("column_double", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := make([]float64, 0, n)
		for i := 0; i < 100; i++ {
			data = append(data, rand.Float64())
		}
		column := NewColumnDouble(name, data)

		l := rand.Intn(n)
		sliced := column.Slice(0, l)
		slicedColumn, ok := sliced.(*ColumnDouble)
		if s.True(ok) {
			s.Equal(column.Type(), slicedColumn.Type())
			s.Equal(data[:l], slicedColumn.Data())
		}
	})

	s.Run("column_varchar", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		data := make([]string, 0, n)
		for i := 0; i < 100; i++ {
			data = append(data, fmt.Sprintf("%d", rand.Int()))
		}
		column := NewColumnVarChar(name, data)

		l := rand.Intn(n)
		sliced := column.Slice(0, l)
		slicedColumn, ok := sliced.(*ColumnVarChar)
		if s.True(ok) {
			s.Equal(column.Type(), slicedColumn.Type())
			s.Equal(data[:l], slicedColumn.Data())
		}
	})
}

func TestScalarColumn(t *testing.T) {
	suite.Run(t, new(ScalarSuite))
}



---
File: /column/scalar.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"github.com/milvus-io/milvus/client/v2/entity"
)

/* bool */

var _ Column = (*ColumnBool)(nil)

type ColumnBool struct {
	*genericColumnBase[bool]
}

func NewColumnBool(name string, values []bool) *ColumnBool {
	return &ColumnBool{
		genericColumnBase: &genericColumnBase[bool]{
			name:      name,
			fieldType: entity.FieldTypeBool,
			values:    values,
		},
	}
}

func (c *ColumnBool) Slice(start, end int) Column {
	return &ColumnBool{
		genericColumnBase: c.genericColumnBase.slice(start, end),
	}
}

/* Int8 */

var _ Column = (*ColumnInt8)(nil)

type ColumnInt8 struct {
	*genericColumnBase[int8]
}

func NewColumnInt8(name string, values []int8) *ColumnInt8 {
	return &ColumnInt8{
		genericColumnBase: &genericColumnBase[int8]{
			name:      name,
			fieldType: entity.FieldTypeInt8,
			values:    values,
		},
	}
}

func (c *ColumnInt8) Slice(start, end int) Column {
	return &ColumnInt8{
		genericColumnBase: c.genericColumnBase.slice(start, end),
	}
}

func (c *ColumnInt8) GetAsInt64(idx int) (int64, error) {
	v, err := c.Value(idx)
	return int64(v), err
}

/* Int16 */

var _ Column = (*ColumnInt16)(nil)

type ColumnInt16 struct {
	*genericColumnBase[int16]
}

func NewColumnInt16(name string, values []int16) *ColumnInt16 {
	return &ColumnInt16{
		genericColumnBase: &genericColumnBase[int16]{
			name:      name,
			fieldType: entity.FieldTypeInt16,
			values:    values,
		},
	}
}

func (c *ColumnInt16) Slice(start, end int) Column {
	return &ColumnInt16{
		genericColumnBase: c.genericColumnBase.slice(start, end),
	}
}

func (c *ColumnInt16) GetAsInt64(idx int) (int64, error) {
	v, err := c.Value(idx)
	return int64(v), err
}

/* Int32 */

var _ Column = (*ColumnInt32)(nil)

type ColumnInt32 struct {
	*genericColumnBase[int32]
}

func NewColumnInt32(name string, values []int32) *ColumnInt32 {
	return &ColumnInt32{
		genericColumnBase: &genericColumnBase[int32]{
			name:      name,
			fieldType: entity.FieldTypeInt32,
			values:    values,
		},
	}
}

func (c *ColumnInt32) Slice(start, end int) Column {
	return &ColumnInt32{
		genericColumnBase: c.genericColumnBase.slice(start, end),
	}
}

func (c *ColumnInt32) GetAsInt64(idx int) (int64, error) {
	v, err := c.Value(idx)
	return int64(v), err
}

/* Int64 */

var _ Column = (*ColumnInt64)(nil)

type ColumnInt64 struct {
	*genericColumnBase[int64]
}

func NewColumnInt64(name string, values []int64) *ColumnInt64 {
	return &ColumnInt64{
		genericColumnBase: &genericColumnBase[int64]{
			name:      name,
			fieldType: entity.FieldTypeInt64,
			values:    values,
		},
	}
}

func (c *ColumnInt64) Slice(start, end int) Column {
	return &ColumnInt64{
		genericColumnBase: c.genericColumnBase.slice(start, end),
	}
}

/* Float */

var _ Column = (*ColumnFloat)(nil)

type ColumnFloat struct {
	*genericColumnBase[float32]
}

func NewColumnFloat(name string, values []float32) *ColumnFloat {
	return &ColumnFloat{
		genericColumnBase: &genericColumnBase[float32]{
			name:      name,
			fieldType: entity.FieldTypeFloat,
			values:    values,
		},
	}
}

func (c *ColumnFloat) Slice(start, end int) Column {
	return &ColumnFloat{
		genericColumnBase: c.genericColumnBase.slice(start, end),
	}
}

func (c *ColumnFloat) GetAsDouble(idx int) (float64, error) {
	v, err := c.Value(idx)
	return float64(v), err
}

/* Double */

var _ Column = (*ColumnFloat)(nil)

type ColumnDouble struct {
	*genericColumnBase[float64]
}

func NewColumnDouble(name string, values []float64) *ColumnDouble {
	return &ColumnDouble{
		genericColumnBase: &genericColumnBase[float64]{
			name:      name,
			fieldType: entity.FieldTypeDouble,
			values:    values,
		},
	}
}

func (c *ColumnDouble) Slice(start, end int) Column {
	return &ColumnDouble{
		genericColumnBase: c.genericColumnBase.slice(start, end),
	}
}

/* Varchar */

var _ (Column) = (*ColumnVarChar)(nil)

type ColumnVarChar struct {
	*genericColumnBase[string]
}

func NewColumnVarChar(name string, values []string) *ColumnVarChar {
	return &ColumnVarChar{
		genericColumnBase: &genericColumnBase[string]{
			name:      name,
			fieldType: entity.FieldTypeVarChar,
			values:    values,
		},
	}
}

func (c *ColumnVarChar) Slice(start, end int) Column {
	return &ColumnVarChar{
		genericColumnBase: c.genericColumnBase.slice(start, end),
	}
}

/* String */
/* NOT USED */

var _ (Column) = (*ColumnString)(nil)

type ColumnString struct {
	*genericColumnBase[string]
}

func NewColumnString(name string, values []string) *ColumnString {
	return &ColumnString{
		genericColumnBase: &genericColumnBase[string]{
			name:      name,
			fieldType: entity.FieldTypeString,
			values:    values,
		},
	}
}

func (c *ColumnString) Slice(start, end int) Column {
	return &ColumnString{
		genericColumnBase: c.genericColumnBase.slice(start, end),
	}
}



---
File: /column/sparse_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"fmt"
	"math/rand"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/milvus-io/milvus/client/v2/entity"
)

func TestColumnSparseEmbedding(t *testing.T) {
	columnName := fmt.Sprintf("column_sparse_embedding_%d", rand.Int())
	columnLen := 8 + rand.Intn(10)

	v := make([]entity.SparseEmbedding, 0, columnLen)
	for i := 0; i < columnLen; i++ {
		length := 1 + rand.Intn(5)
		positions := make([]uint32, length)
		values := make([]float32, length)
		for j := 0; j < length; j++ {
			positions[j] = uint32(j)
			values[j] = rand.Float32()
		}
		se, err := entity.NewSliceSparseEmbedding(positions, values)
		require.NoError(t, err)
		v = append(v, se)
	}
	column := NewColumnSparseVectors(columnName, v)

	t.Run("test column attribute", func(t *testing.T) {
		assert.Equal(t, columnName, column.Name())
		assert.Equal(t, entity.FieldTypeSparseVector, column.Type())
		assert.Equal(t, columnLen, column.Len())
		assert.EqualValues(t, v, column.Data())
	})

	t.Run("test column field data", func(t *testing.T) {
		fd := column.FieldData()
		assert.NotNil(t, fd)
		assert.Equal(t, fd.GetFieldName(), columnName)

		result, err := FieldDataColumn(fd, 0, -1)
		assert.NoError(t, err)

		parsed, ok := result.(*ColumnSparseFloatVector)
		if assert.True(t, ok) {
			assert.Equal(t, columnName, parsed.Name())
			assert.Equal(t, entity.FieldTypeSparseVector, parsed.Type())
			assert.Equal(t, columnLen, parsed.Len())
			// dim not equal
			// assert.EqualValues(t, v, parsed.Data())
		}
	})

	t.Run("test column value by idx", func(t *testing.T) {
		_, err := column.Value(-1)
		assert.Error(t, err)
		_, err = column.Value(columnLen)
		assert.Error(t, err)

		_, err = column.Get(-1)
		assert.Error(t, err)
		_, err = column.Get(columnLen)
		assert.Error(t, err)

		for i := 0; i < columnLen; i++ {
			v, err := column.Value(i)
			assert.NoError(t, err)
			assert.Equal(t, column.values[i], v)
			getV, err := column.Get(i)
			assert.NoError(t, err)
			assert.Equal(t, v, getV)
		}
	})

	t.Run("test_column_slice", func(t *testing.T) {
		l := rand.Intn(columnLen)
		sliced := column.Slice(0, l)
		slicedColumn, ok := sliced.(*ColumnSparseFloatVector)
		if assert.True(t, ok) {
			assert.Equal(t, column.Data()[:l], slicedColumn.Data())
		}
	})
}



---
File: /column/sparse.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"github.com/samber/lo"

	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

var _ (Column) = (*ColumnSparseFloatVector)(nil)

type ColumnSparseFloatVector struct {
	*vectorBase[entity.SparseEmbedding]
}

func NewColumnSparseVectors(name string, values []entity.SparseEmbedding) *ColumnSparseFloatVector {
	return &ColumnSparseFloatVector{
		// sparse embedding need not specify dimension
		vectorBase: newVectorBase(name, 0, values, entity.FieldTypeSparseVector),
	}
}

func (c *ColumnSparseFloatVector) FieldData() *schemapb.FieldData {
	fd := c.vectorBase.FieldData()
	max := lo.MaxBy(c.values, func(a, b entity.SparseEmbedding) bool {
		return a.Dim() > b.Dim()
	})
	vectors := fd.GetVectors()
	vectors.Dim = int64(max.Dim())
	return fd
}

func (c *ColumnSparseFloatVector) Slice(start, end int) Column {
	return &ColumnSparseFloatVector{
		vectorBase: c.vectorBase.slice(start, end),
	}
}



---
File: /column/vector_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"fmt"
	"math"
	"math/rand"
	"testing"

	"github.com/samber/lo"
	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus/client/v2/entity"
)

type VectorSuite struct {
	suite.Suite
}

func (s *VectorSuite) TestBasic() {
	s.Run("float_vector", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		n := 3
		dim := rand.Intn(10) + 2
		data := make([][]float32, 0, n)
		for i := 0; i < n; i++ {
			row := lo.RepeatBy(dim, func(i int) float32 {
				return rand.Float32()
			})
			data = append(data, row)
		}
		column := NewColumnFloatVector(name, dim, data)
		s.Equal(entity.FieldTypeFloatVector, column.Type())
		s.Equal(name, column.Name())
		s.Equal(lo.Map(data, func(row []float32, _ int) entity.FloatVector { return entity.FloatVector(row) }), column.Data())
		s.Equal(dim, column.Dim())

		fd := column.FieldData()
		s.Equal(name, fd.GetFieldName())
		s.Equal(lo.Flatten(data), fd.GetVectors().GetFloatVector().GetData())

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnFloatVector)
		if s.True(ok) {
			s.Equal(entity.FieldTypeFloatVector, parsed.Type())
			s.Equal(name, parsed.Name())
			s.Equal(lo.Map(data, func(row []float32, _ int) entity.FloatVector { return entity.FloatVector(row) }), parsed.Data())
			s.Equal(dim, parsed.Dim())
		}
	})

	s.Run("binary_vector", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		n := 3
		dim := (rand.Intn(10) + 1) * 8
		data := make([][]byte, 0, n)
		for i := 0; i < n; i++ {
			row := lo.RepeatBy(dim/8, func(i int) byte {
				return byte(rand.Intn(math.MaxUint8))
			})
			data = append(data, row)
		}
		column := NewColumnBinaryVector(name, dim, data)
		s.Equal(entity.FieldTypeBinaryVector, column.Type())
		s.Equal(name, column.Name())
		s.Equal(lo.Map(data, func(row []byte, _ int) entity.BinaryVector { return entity.BinaryVector(row) }), column.Data())
		s.Equal(dim, column.Dim())

		fd := column.FieldData()
		s.Equal(name, fd.GetFieldName())
		s.Equal(lo.Flatten(data), fd.GetVectors().GetBinaryVector())

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnBinaryVector)
		if s.True(ok) {
			s.Equal(entity.FieldTypeBinaryVector, parsed.Type())
			s.Equal(name, parsed.Name())
			s.Equal(lo.Map(data, func(row []byte, _ int) entity.BinaryVector { return entity.BinaryVector(row) }), parsed.Data())
			s.Equal(dim, parsed.Dim())
		}
	})

	s.Run("fp16_vector", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		n := 3
		dim := rand.Intn(10) + 1
		data := make([][]byte, 0, n)
		for i := 0; i < n; i++ {
			row := lo.RepeatBy(dim*2, func(i int) byte {
				return byte(rand.Intn(math.MaxUint8))
			})
			data = append(data, row)
		}
		column := NewColumnFloat16Vector(name, dim, data)
		s.Equal(entity.FieldTypeFloat16Vector, column.Type())
		s.Equal(name, column.Name())
		s.Equal(lo.Map(data, func(row []byte, _ int) entity.Float16Vector { return entity.Float16Vector(row) }), column.Data())
		s.Equal(dim, column.Dim())

		fd := column.FieldData()
		s.Equal(name, fd.GetFieldName())
		s.Equal(lo.Flatten(data), fd.GetVectors().GetFloat16Vector())

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnFloat16Vector)
		if s.True(ok) {
			s.Equal(entity.FieldTypeFloat16Vector, parsed.Type())
			s.Equal(name, parsed.Name())
			s.Equal(lo.Map(data, func(row []byte, _ int) entity.Float16Vector { return entity.Float16Vector(row) }), parsed.Data())
			s.Equal(dim, parsed.Dim())
		}
	})

	s.Run("bf16_vector", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		n := 3
		dim := rand.Intn(10) + 1
		data := make([][]byte, 0, n)
		for i := 0; i < n; i++ {
			row := lo.RepeatBy(dim*2, func(i int) byte {
				return byte(rand.Intn(math.MaxUint8))
			})
			data = append(data, row)
		}
		column := NewColumnBFloat16Vector(name, dim, data)
		s.Equal(entity.FieldTypeBFloat16Vector, column.Type())
		s.Equal(name, column.Name())
		s.Equal(lo.Map(data, func(row []byte, _ int) entity.BFloat16Vector { return entity.BFloat16Vector(row) }), column.Data())
		s.Equal(dim, column.Dim())

		fd := column.FieldData()
		s.Equal(name, fd.GetFieldName())
		s.Equal(lo.Flatten(data), fd.GetVectors().GetBfloat16Vector())

		result, err := FieldDataColumn(fd, 0, -1)
		s.NoError(err)
		parsed, ok := result.(*ColumnBFloat16Vector)
		if s.True(ok) {
			s.Equal(entity.FieldTypeBFloat16Vector, parsed.Type())
			s.Equal(name, parsed.Name())
			s.Equal(lo.Map(data, func(row []byte, _ int) entity.BFloat16Vector { return entity.BFloat16Vector(row) }), parsed.Data())
			s.Equal(dim, parsed.Dim())
		}
	})

	s.Run("fp32 <-> fp16/bf16 vector conversion", func() {
		dim := 3
		data := [][]float32{{0.1, 0.2, 0.3}, {0.4, 0.5, 0.6}, {0.7, 0.8, 0.9}, {1.0, 1.1, 1.2}}

		fp16Vector := NewColumnFloat16VectorFromFp32Vector("fp16_vector", dim, data[:2])
		fp16Vector.AppendValue(data[2])
		fp16Vector.AppendValue(data[3])
		for i, vec := range fp16Vector.Data() {
			fp32Vector := vec.ToFloat32Vector()
			s.Equal(dim, len(fp32Vector))
			for j := 0; j < dim; j++ {
				s.InDelta(data[i][j], fp32Vector[j], 7e-3)
			}
		}

		bf16Vector := NewColumnBFloat16VectorFromFp32Vector("bf16_vector", dim, data[:2])
		bf16Vector.AppendValue(data[2])
		bf16Vector.AppendValue(data[3])
		for i, vec := range bf16Vector.Data() {
			fp32Vector := vec.ToFloat32Vector()
			s.Equal(dim, len(fp32Vector))
			for j := 0; j < dim; j++ {
				s.InDelta(data[i][j], fp32Vector[j], 7e-3)
			}
		}
	})
}

func (s *VectorSuite) TestSlice() {
	s.Run("float_vector", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		n := 100
		dim := rand.Intn(10) + 2
		data := make([][]float32, 0, n)
		for i := 0; i < n; i++ {
			row := lo.RepeatBy(dim, func(i int) float32 {
				return rand.Float32()
			})
			data = append(data, row)
		}
		column := NewColumnFloatVector(name, dim, data)

		l := rand.Intn(n)
		sliced := column.Slice(0, l)
		slicedColumn, ok := sliced.(*ColumnFloatVector)
		if s.True(ok) {
			s.Equal(dim, slicedColumn.Dim())
			s.Equal(lo.Map(data[:l], func(row []float32, _ int) entity.FloatVector { return entity.FloatVector(row) }), slicedColumn.Data())
		}
	})

	s.Run("binary_vector", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		n := 100
		dim := (rand.Intn(10) + 1) * 8
		data := make([][]byte, 0, n)
		for i := 0; i < n; i++ {
			row := lo.RepeatBy(dim/8, func(i int) byte {
				return byte(rand.Intn(math.MaxUint8))
			})
			data = append(data, row)
		}
		column := NewColumnBinaryVector(name, dim, data)

		l := rand.Intn(n)
		sliced := column.Slice(0, l)
		slicedColumn, ok := sliced.(*ColumnBinaryVector)
		if s.True(ok) {
			s.Equal(dim, slicedColumn.Dim())
			s.Equal(lo.Map(data[:l], func(row []byte, _ int) entity.BinaryVector { return entity.BinaryVector(row) }), slicedColumn.Data())
		}
	})

	s.Run("fp16_vector", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		n := 3
		dim := rand.Intn(10) + 1
		data := make([][]byte, 0, n)
		for i := 0; i < n; i++ {
			row := lo.RepeatBy(dim*2, func(i int) byte {
				return byte(rand.Intn(math.MaxUint8))
			})
			data = append(data, row)
		}
		column := NewColumnFloat16Vector(name, dim, data)

		l := rand.Intn(n)
		sliced := column.Slice(0, l)
		slicedColumn, ok := sliced.(*ColumnFloat16Vector)
		if s.True(ok) {
			s.Equal(dim, slicedColumn.Dim())
			s.Equal(lo.Map(data[:l], func(row []byte, _ int) entity.Float16Vector { return entity.Float16Vector(row) }), slicedColumn.Data())
		}
	})

	s.Run("bf16_vector", func() {
		name := fmt.Sprintf("field_%d", rand.Intn(1000))
		n := 3
		dim := rand.Intn(10) + 1
		data := make([][]byte, 0, n)
		for i := 0; i < n; i++ {
			row := lo.RepeatBy(dim*2, func(i int) byte {
				return byte(rand.Intn(math.MaxUint8))
			})
			data = append(data, row)
		}
		column := NewColumnBFloat16Vector(name, dim, data)

		l := rand.Intn(n)
		sliced := column.Slice(0, l)
		slicedColumn, ok := sliced.(*ColumnBFloat16Vector)
		if s.True(ok) {
			s.Equal(dim, slicedColumn.Dim())
			s.Equal(lo.Map(data[:l], func(row []byte, _ int) entity.BFloat16Vector { return entity.BFloat16Vector(row) }), slicedColumn.Data())
		}
	})
}

func TestVectors(t *testing.T) {
	suite.Run(t, new(VectorSuite))
}



---
File: /column/vector.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package column

import (
	"github.com/cockroachdb/errors"
	"github.com/samber/lo"

	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

type vectorBase[T entity.Vector] struct {
	*genericColumnBase[T]
	dim int
}

func (b *vectorBase[T]) Dim() int {
	return b.dim
}

func (b *vectorBase[T]) FieldData() *schemapb.FieldData {
	fd := b.genericColumnBase.FieldData()
	vectors := fd.GetVectors()
	vectors.Dim = int64(b.dim)
	return fd
}

func (b *vectorBase[T]) slice(start, end int) *vectorBase[T] {
	return &vectorBase[T]{
		genericColumnBase: b.genericColumnBase.slice(start, end),
		dim:               b.dim,
	}
}

func newVectorBase[T entity.Vector](fieldName string, dim int, vectors []T, fieldType entity.FieldType) *vectorBase[T] {
	return &vectorBase[T]{
		genericColumnBase: &genericColumnBase[T]{
			name:      fieldName,
			fieldType: fieldType,
			values:    vectors,
		},
		dim: dim,
	}
}

/* float vector */

type ColumnFloatVector struct {
	*vectorBase[entity.FloatVector]
}

func NewColumnFloatVector(fieldName string, dim int, data [][]float32) *ColumnFloatVector {
	vectors := lo.Map(data, func(row []float32, _ int) entity.FloatVector { return entity.FloatVector(row) })
	return &ColumnFloatVector{
		vectorBase: newVectorBase(fieldName, dim, vectors, entity.FieldTypeFloatVector),
	}
}

// AppendValue appends vector value into values.
// override default type constrains, add `[]float32` conversion
func (c *ColumnFloatVector) AppendValue(i interface{}) error {
	switch vector := i.(type) {
	case entity.FloatVector:
		c.values = append(c.values, vector)
	case []float32:
		c.values = append(c.values, vector)
	default:
		return errors.Newf("unexpected append value type %T, field type %v", vector, c.fieldType)
	}
	return nil
}

func (c *ColumnFloatVector) Slice(start, end int) Column {
	return &ColumnFloatVector{
		vectorBase: c.vectorBase.slice(start, end),
	}
}

/* binary vector */

type ColumnBinaryVector struct {
	*vectorBase[entity.BinaryVector]
}

func NewColumnBinaryVector(fieldName string, dim int, data [][]byte) *ColumnBinaryVector {
	vectors := lo.Map(data, func(row []byte, _ int) entity.BinaryVector { return entity.BinaryVector(row) })
	return &ColumnBinaryVector{
		vectorBase: newVectorBase(fieldName, dim, vectors, entity.FieldTypeBinaryVector),
	}
}

// AppendValue appends vector value into values.
// override default type constrains, add `[]byte` conversion
func (c *ColumnBinaryVector) AppendValue(i interface{}) error {
	switch vector := i.(type) {
	case entity.BinaryVector:
		c.values = append(c.values, vector)
	case []byte:
		c.values = append(c.values, vector)
	default:
		return errors.Newf("unexpected append value type %T, field type %v", vector, c.fieldType)
	}
	return nil
}

func (c *ColumnBinaryVector) Slice(start, end int) Column {
	return &ColumnBinaryVector{
		vectorBase: c.vectorBase.slice(start, end),
	}
}

/* fp16 vector */

type ColumnFloat16Vector struct {
	*vectorBase[entity.Float16Vector]
}

func NewColumnFloat16Vector(fieldName string, dim int, data [][]byte) *ColumnFloat16Vector {
	vectors := lo.Map(data, func(row []byte, _ int) entity.Float16Vector { return entity.Float16Vector(row) })
	return &ColumnFloat16Vector{
		vectorBase: newVectorBase(fieldName, dim, vectors, entity.FieldTypeFloat16Vector),
	}
}

func NewColumnFloat16VectorFromFp32Vector(fieldName string, dim int, data [][]float32) *ColumnFloat16Vector {
	vectors := lo.Map(data, func(row []float32, _ int) entity.Float16Vector { return entity.FloatVector(row).ToFloat16Vector() })
	return &ColumnFloat16Vector{
		vectorBase: newVectorBase(fieldName, dim, vectors, entity.FieldTypeFloat16Vector),
	}
}

// AppendValue appends vector value into values.
// Override default type constrains, add `[]byte`, `entity.FloatVector` and
// `[]float32` conversion.
func (c *ColumnFloat16Vector) AppendValue(i interface{}) error {
	switch vector := i.(type) {
	case entity.Float16Vector:
		c.values = append(c.values, vector)
	case []byte:
		c.values = append(c.values, vector)
	case entity.FloatVector:
		c.values = append(c.values, vector.ToFloat16Vector())
	case []float32:
		c.values = append(c.values, entity.FloatVector(vector).ToFloat16Vector())
	default:
		return errors.Newf("unexpected append value type %T, field type %v", vector, c.fieldType)
	}
	return nil
}

func (c *ColumnFloat16Vector) Slice(start, end int) Column {
	return &ColumnFloat16Vector{
		vectorBase: c.vectorBase.slice(start, end),
	}
}

/* bf16 vector */

type ColumnBFloat16Vector struct {
	*vectorBase[entity.BFloat16Vector]
}

func NewColumnBFloat16Vector(fieldName string, dim int, data [][]byte) *ColumnBFloat16Vector {
	vectors := lo.Map(data, func(row []byte, _ int) entity.BFloat16Vector { return entity.BFloat16Vector(row) })
	return &ColumnBFloat16Vector{
		vectorBase: newVectorBase(fieldName, dim, vectors, entity.FieldTypeBFloat16Vector),
	}
}

func NewColumnBFloat16VectorFromFp32Vector(fieldName string, dim int, data [][]float32) *ColumnBFloat16Vector {
	vectors := lo.Map(data, func(row []float32, _ int) entity.BFloat16Vector { return entity.FloatVector(row).ToBFloat16Vector() })
	return &ColumnBFloat16Vector{
		vectorBase: newVectorBase(fieldName, dim, vectors, entity.FieldTypeBFloat16Vector),
	}
}

// AppendValue appends vector value into values.
// Override default type constrains, add `[]byte`, `entity.FloatVector` and
// `[]float32` conversion.
func (c *ColumnBFloat16Vector) AppendValue(i interface{}) error {
	switch vector := i.(type) {
	case entity.BFloat16Vector:
		c.values = append(c.values, vector)
	case []byte:
		c.values = append(c.values, vector)
	case entity.FloatVector:
		c.values = append(c.values, vector.ToBFloat16Vector())
	case []float32:
		c.values = append(c.values, entity.FloatVector(vector).ToBFloat16Vector())
	default:
		return errors.Newf("unexpected append value type %T, field type %v", vector, c.fieldType)
	}
	return nil
}

func (c *ColumnBFloat16Vector) Slice(start, end int) Column {
	return &ColumnBFloat16Vector{
		vectorBase: c.vectorBase.slice(start, end),
	}
}



---
File: /common/version_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package common

import (
	"testing"

	"github.com/blang/semver/v4"
	"github.com/stretchr/testify/assert"
)

func TestVersion(t *testing.T) {
	_, err := semver.Parse(SDKVersion)
	assert.NoError(t, err)
}



---
File: /common/version.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package common

const (
	// SDKVersion const value for current version
	SDKVersion = `2.5.3`
)



---
File: /entity/alias.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

// Alias is the entity model for collection alias.
type Alias struct {
	DbName         string
	Alias          string
	CollectionName string
}



---
File: /entity/analyzer.go
---

package entity

type Token struct {
	Text           string
	StartOffset    int64
	EndOffset      int64
	Position       int64
	PositionLength int64
	Hash           uint32
}

type AnalyzerResult struct {
	Tokens []*Token
}



---
File: /entity/collection_attr_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import (
	"fmt"
	"strconv"
	"testing"

	"github.com/stretchr/testify/suite"
)

type CollectionTTLSuite struct {
	suite.Suite
}

func (s *CollectionTTLSuite) TestValid() {
	type testCase struct {
		input     string
		expectErr bool
	}

	cases := []testCase{
		{input: "a", expectErr: true},
		{input: "1000", expectErr: false},
		{input: "0", expectErr: false},
		{input: "-10", expectErr: true},
	}

	for _, tc := range cases {
		s.Run(tc.input, func() {
			ca := ttlCollAttr{}
			ca.value = tc.input
			err := ca.Valid()
			if tc.expectErr {
				s.Error(err)
			} else {
				s.NoError(err)
			}
		})
	}
}

func (s *CollectionTTLSuite) TestCollectionTTL() {
	type testCase struct {
		input     int64
		expectErr bool
	}

	cases := []testCase{
		{input: 1000, expectErr: false},
		{input: 0, expectErr: false},
		{input: -10, expectErr: true},
	}

	for _, tc := range cases {
		s.Run(fmt.Sprintf("%d", tc.input), func() {
			ca := CollectionTTL(tc.input)
			key, value := ca.KeyValue()
			s.Equal(cakTTL, key)
			s.Equal(strconv.FormatInt(tc.input, 10), value)
			err := ca.Valid()
			if tc.expectErr {
				s.Error(err)
			} else {
				s.NoError(err)
			}
		})
	}
}

func TestCollectionTTL(t *testing.T) {
	suite.Run(t, new(CollectionTTLSuite))
}

type CollectionAutoCompactionSuite struct {
	suite.Suite
}

func (s *CollectionAutoCompactionSuite) TestValid() {
	type testCase struct {
		input     string
		expectErr bool
	}

	cases := []testCase{
		{input: "a", expectErr: true},
		{input: "true", expectErr: false},
		{input: "false", expectErr: false},
		{input: "", expectErr: true},
	}

	for _, tc := range cases {
		s.Run(tc.input, func() {
			ca := autoCompactionCollAttr{}
			ca.value = tc.input
			err := ca.Valid()
			if tc.expectErr {
				s.Error(err)
			} else {
				s.NoError(err)
			}
		})
	}
}

func (s *CollectionAutoCompactionSuite) TestCollectionAutoCompactionEnabled() {
	cases := []bool{true, false}

	for _, tc := range cases {
		s.Run(fmt.Sprintf("%v", tc), func() {
			ca := CollectionAutoCompactionEnabled(tc)
			key, value := ca.KeyValue()
			s.Equal(cakAutoCompaction, key)
			s.Equal(strconv.FormatBool(tc), value)
		})
	}
}

func TestCollectionAutoCompaction(t *testing.T) {
	suite.Run(t, new(CollectionAutoCompactionSuite))
}



---
File: /entity/collection_attr.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import (
	"strconv"

	"github.com/cockroachdb/errors"
)

const (
	// cakTTL const for collection attribute key TTL in seconds.
	cakTTL = `collection.ttl.seconds`
	// cakAutoCompaction const for collection attribute key autom compaction enabled.
	cakAutoCompaction = `collection.autocompaction.enabled`
)

// CollectionAttribute is the interface for altering collection attributes.
type CollectionAttribute interface {
	KeyValue() (string, string)
	Valid() error
}

type collAttrBase struct {
	key   string
	value string
}

// KeyValue implements CollectionAttribute.
func (ca collAttrBase) KeyValue() (string, string) {
	return ca.key, ca.value
}

type ttlCollAttr struct {
	collAttrBase
}

// Valid implements CollectionAttribute.
// checks ttl seconds is valid positive integer.
func (ca collAttrBase) Valid() error {
	val, err := strconv.ParseInt(ca.value, 10, 64)
	if err != nil {
		return errors.Wrap(err, "ttl is not a valid positive integer")
	}

	if val < 0 {
		return errors.New("ttl needs to be a positive integer")
	}

	return nil
}

// CollectionTTL returns collection attribute to set collection ttl in seconds.
func CollectionTTL(ttl int64) ttlCollAttr {
	ca := ttlCollAttr{}
	ca.key = cakTTL
	ca.value = strconv.FormatInt(ttl, 10)
	return ca
}

type autoCompactionCollAttr struct {
	collAttrBase
}

// Valid implements CollectionAttribute.
// checks collection auto compaction is valid bool.
func (ca autoCompactionCollAttr) Valid() error {
	_, err := strconv.ParseBool(ca.value)
	if err != nil {
		return errors.Wrap(err, "auto compaction setting is not valid boolean")
	}

	return nil
}

// CollectionAutoCompactionEnabled returns collection attribute to set collection auto compaction enabled.
func CollectionAutoCompactionEnabled(enabled bool) autoCompactionCollAttr {
	ca := autoCompactionCollAttr{}
	ca.key = cakAutoCompaction
	ca.value = strconv.FormatBool(enabled)
	return ca
}



---
File: /entity/collection.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

// DefaultShardNumber const value for using Milvus default shard number.
const DefaultShardNumber int32 = 0

// DefaultConsistencyLevel const value for using Milvus default consistency level setting.
const DefaultConsistencyLevel ConsistencyLevel = ClBounded

// Collection represent collection meta in Milvus
type Collection struct {
	ID               int64   // collection id
	Name             string  // collection name
	Schema           *Schema // collection schema, with fields schema and primary key definition
	PhysicalChannels []string
	VirtualChannels  []string
	Loaded           bool
	ConsistencyLevel ConsistencyLevel
	ShardNum         int32
	Properties       map[string]string

	// collection update timestamp, usually used for internal change detection
	UpdateTimestamp uint64
}

// Partition represent partition meta in Milvus
type Partition struct {
	ID     int64  // partition id
	Name   string // partition name
	Loaded bool   // partition loaded
}

// ReplicaGroup represents a replica group
type ReplicaGroup struct {
	ReplicaID     int64
	NodeIDs       []int64
	ShardReplicas []*ShardReplica
}

// ShardReplica represents a shard in the ReplicaGroup
type ShardReplica struct {
	LeaderID      int64
	NodesIDs      []int64
	DmChannelName string
}



---
File: /entity/common.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import "github.com/milvus-io/milvus-proto/go-api/v2/commonpb"

// MetricType metric type
type MetricType string

// Metric Constants
const (
	L2             MetricType = "L2"
	IP             MetricType = "IP"
	COSINE         MetricType = "COSINE"
	HAMMING        MetricType = "HAMMING"
	JACCARD        MetricType = "JACCARD"
	TANIMOTO       MetricType = "TANIMOTO"
	SUBSTRUCTURE   MetricType = "SUBSTRUCTURE"
	SUPERSTRUCTURE MetricType = "SUPERSTRUCTURE"
	BM25           MetricType = "BM25"
)

// CompactionState enum type for compaction state
type CompactionState commonpb.CompactionState

// CompactionState Constants
const (
	CompactionStateRunning   CompactionState = CompactionState(commonpb.CompactionState_Executing)
	CompactionStateCompleted CompactionState = CompactionState(commonpb.CompactionState_Completed)
)



---
File: /entity/database.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

type Database struct {
	Name       string
	Properties map[string]string
}



---
File: /entity/field_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestFieldSchema(t *testing.T) {
	fields := []*Field{
		NewField().WithName("int_field").WithDataType(FieldTypeInt64).WithIsAutoID(true).WithIsPrimaryKey(true).WithDescription("int_field desc"),
		NewField().WithName("string_field").WithDataType(FieldTypeString).WithIsAutoID(false).WithIsPrimaryKey(true).WithIsDynamic(false).WithTypeParams("max_len", "32").WithDescription("string_field desc"),
		NewField().WithName("partition_key").WithDataType(FieldTypeInt32).WithIsPartitionKey(true),
		NewField().WithName("array_field").WithDataType(FieldTypeArray).WithElementType(FieldTypeBool).WithMaxCapacity(128),
		NewField().WithName("clustering_key").WithDataType(FieldTypeInt32).WithIsClusteringKey(true),
		NewField().WithName("varchar_text").WithDataType(FieldTypeVarChar).WithMaxLength(65535).WithEnableAnalyzer(true).WithAnalyzerParams(map[string]any{}).WithEnableMatch(true),

		NewField().WithName("default_value_bool").WithDataType(FieldTypeBool).WithDefaultValueBool(true),
		NewField().WithName("default_value_int").WithDataType(FieldTypeInt32).WithDefaultValueInt(1),
		NewField().WithName("default_value_long").WithDataType(FieldTypeInt64).WithDefaultValueLong(1),
		NewField().WithName("default_value_float").WithDataType(FieldTypeFloat).WithDefaultValueFloat(1),
		NewField().WithName("default_value_double").WithDataType(FieldTypeDouble).WithDefaultValueDouble(1),
		NewField().WithName("default_value_string").WithDataType(FieldTypeString).WithDefaultValueString("a"),
	}

	for _, field := range fields {
		fieldSchema := field.ProtoMessage()
		assert.Equal(t, field.ID, fieldSchema.GetFieldID())
		assert.Equal(t, field.Name, fieldSchema.GetName())
		assert.EqualValues(t, field.DataType, fieldSchema.GetDataType())
		assert.Equal(t, field.AutoID, fieldSchema.GetAutoID())
		assert.Equal(t, field.PrimaryKey, fieldSchema.GetIsPrimaryKey())
		assert.Equal(t, field.IsPartitionKey, fieldSchema.GetIsPartitionKey())
		assert.Equal(t, field.IsClusteringKey, fieldSchema.GetIsClusteringKey())
		assert.Equal(t, field.IsDynamic, fieldSchema.GetIsDynamic())
		assert.Equal(t, field.Description, fieldSchema.GetDescription())
		assert.Equal(t, field.TypeParams, KvPairsMap(fieldSchema.GetTypeParams()))
		assert.EqualValues(t, field.ElementType, fieldSchema.GetElementType())
		// marshal & unmarshal, still equals
		nf := &Field{}
		nf = nf.ReadProto(fieldSchema)
		assert.Equal(t, field.ID, nf.ID)
		assert.Equal(t, field.Name, nf.Name)
		assert.EqualValues(t, field.DataType, nf.DataType)
		assert.Equal(t, field.AutoID, nf.AutoID)
		assert.Equal(t, field.PrimaryKey, nf.PrimaryKey)
		assert.Equal(t, field.Description, nf.Description)
		assert.Equal(t, field.IsDynamic, nf.IsDynamic)
		assert.Equal(t, field.IsPartitionKey, nf.IsPartitionKey)
		assert.Equal(t, field.IsClusteringKey, nf.IsClusteringKey)
		assert.EqualValues(t, field.TypeParams, nf.TypeParams)
		assert.EqualValues(t, field.ElementType, nf.ElementType)
	}

	assert.NotPanics(t, func() {
		(&Field{}).WithTypeParams("a", "b")
	})
}



---
File: /entity/field.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import (
	"encoding/json"
	"strconv"

	"github.com/cockroachdb/errors"

	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
)

// FieldType field data type alias type
// used in go:generate trick, DO NOT modify names & string
type FieldType int32

// Name returns field type name
func (t FieldType) Name() string {
	switch t {
	case FieldTypeBool:
		return "Bool"
	case FieldTypeInt8:
		return "Int8"
	case FieldTypeInt16:
		return "Int16"
	case FieldTypeInt32:
		return "Int32"
	case FieldTypeInt64:
		return "Int64"
	case FieldTypeFloat:
		return "Float"
	case FieldTypeDouble:
		return "Double"
	case FieldTypeString:
		return "String"
	case FieldTypeVarChar:
		return "VarChar"
	case FieldTypeArray:
		return "Array"
	case FieldTypeJSON:
		return "JSON"
	case FieldTypeBinaryVector:
		return "BinaryVector"
	case FieldTypeFloatVector:
		return "FloatVector"
	case FieldTypeFloat16Vector:
		return "Float16Vector"
	case FieldTypeBFloat16Vector:
		return "BFloat16Vector"
	default:
		return "undefined"
	}
}

// String returns field type
func (t FieldType) String() string {
	switch t {
	case FieldTypeBool:
		return "bool"
	case FieldTypeInt8:
		return "int8"
	case FieldTypeInt16:
		return "int16"
	case FieldTypeInt32:
		return "int32"
	case FieldTypeInt64:
		return "int64"
	case FieldTypeFloat:
		return "float32"
	case FieldTypeDouble:
		return "float64"
	case FieldTypeString:
		return "string"
	case FieldTypeVarChar:
		return "string"
	case FieldTypeArray:
		return "Array"
	case FieldTypeJSON:
		return "JSON"
	case FieldTypeBinaryVector:
		return "[]byte"
	case FieldTypeFloatVector:
		return "[]float32"
	case FieldTypeFloat16Vector:
		return "[]byte"
	case FieldTypeBFloat16Vector:
		return "[]byte"
	default:
		return "undefined"
	}
}

// PbFieldType represents FieldType corresponding schema pb type
func (t FieldType) PbFieldType() (string, string) {
	switch t {
	case FieldTypeBool:
		return "Bool", "bool"
	case FieldTypeInt8:
		fallthrough
	case FieldTypeInt16:
		fallthrough
	case FieldTypeInt32:
		return "Int", "int32"
	case FieldTypeInt64:
		return "Long", "int64"
	case FieldTypeFloat:
		return "Float", "float32"
	case FieldTypeDouble:
		return "Double", "float64"
	case FieldTypeString:
		return "String", "string"
	case FieldTypeVarChar:
		return "VarChar", "string"
	case FieldTypeJSON:
		return "JSON", "JSON"
	case FieldTypeBinaryVector:
		return "[]byte", ""
	case FieldTypeFloatVector:
		return "[]float32", ""
	case FieldTypeFloat16Vector:
		return "[]byte", ""
	case FieldTypeBFloat16Vector:
		return "[]byte", ""
	default:
		return "undefined", ""
	}
}

// Match schema definition
const (
	// FieldTypeNone zero value place holder
	FieldTypeNone FieldType = 0 // zero value place holder
	// FieldTypeBool field type boolean
	FieldTypeBool FieldType = 1
	// FieldTypeInt8 field type int8
	FieldTypeInt8 FieldType = 2
	// FieldTypeInt16 field type int16
	FieldTypeInt16 FieldType = 3
	// FieldTypeInt32 field type int32
	FieldTypeInt32 FieldType = 4
	// FieldTypeInt64 field type int64
	FieldTypeInt64 FieldType = 5
	// FieldTypeFloat field type float
	FieldTypeFloat FieldType = 10
	// FieldTypeDouble field type double
	FieldTypeDouble FieldType = 11
	// FieldTypeString field type string
	FieldTypeString FieldType = 20
	// FieldTypeVarChar field type varchar
	FieldTypeVarChar FieldType = 21 // variable-length strings with a specified maximum length
	// FieldTypeArray field type Array
	FieldTypeArray FieldType = 22
	// FieldTypeJSON field type JSON
	FieldTypeJSON FieldType = 23
	// FieldTypeBinaryVector field type binary vector
	FieldTypeBinaryVector FieldType = 100
	// FieldTypeFloatVector field type float vector
	FieldTypeFloatVector FieldType = 101
	// FieldTypeBinaryVector field type float16 vector
	FieldTypeFloat16Vector FieldType = 102
	// FieldTypeBinaryVector field type bf16 vector
	FieldTypeBFloat16Vector FieldType = 103
	// FieldTypeBinaryVector field type sparse vector
	FieldTypeSparseVector FieldType = 104
)

// Field represent field schema in milvus
type Field struct {
	ID              int64  // field id, generated when collection is created, input value is ignored
	Name            string // field name
	PrimaryKey      bool   // is primary key
	AutoID          bool   // is auto id
	Description     string
	DataType        FieldType
	TypeParams      map[string]string
	IndexParams     map[string]string
	IsDynamic       bool
	IsPartitionKey  bool
	IsClusteringKey bool
	ElementType     FieldType
	DefaultValue    *schemapb.ValueField
	Nullable        bool
}

// ProtoMessage generates corresponding FieldSchema
func (f *Field) ProtoMessage() *schemapb.FieldSchema {
	return &schemapb.FieldSchema{
		FieldID:         f.ID,
		Name:            f.Name,
		Description:     f.Description,
		IsPrimaryKey:    f.PrimaryKey,
		AutoID:          f.AutoID,
		DataType:        schemapb.DataType(f.DataType),
		TypeParams:      MapKvPairs(f.TypeParams),
		IndexParams:     MapKvPairs(f.IndexParams),
		IsDynamic:       f.IsDynamic,
		IsPartitionKey:  f.IsPartitionKey,
		IsClusteringKey: f.IsClusteringKey,
		ElementType:     schemapb.DataType(f.ElementType),
		Nullable:        f.Nullable,
		DefaultValue:    f.DefaultValue,
	}
}

// NewField creates a new Field with map initialized.
func NewField() *Field {
	return &Field{
		TypeParams:  make(map[string]string),
		IndexParams: make(map[string]string),
	}
}

func (f *Field) WithName(name string) *Field {
	f.Name = name
	return f
}

func (f *Field) WithDescription(desc string) *Field {
	f.Description = desc
	return f
}

func (f *Field) WithDataType(dataType FieldType) *Field {
	f.DataType = dataType
	return f
}

func (f *Field) WithIsPrimaryKey(isPrimaryKey bool) *Field {
	f.PrimaryKey = isPrimaryKey
	return f
}

func (f *Field) WithIsAutoID(isAutoID bool) *Field {
	f.AutoID = isAutoID
	return f
}

func (f *Field) WithIsDynamic(isDynamic bool) *Field {
	f.IsDynamic = isDynamic
	return f
}

func (f *Field) WithIsPartitionKey(isPartitionKey bool) *Field {
	f.IsPartitionKey = isPartitionKey
	return f
}

func (f *Field) WithIsClusteringKey(isClusteringKey bool) *Field {
	f.IsClusteringKey = isClusteringKey
	return f
}

func (f *Field) WithNullable(nullable bool) *Field {
	f.Nullable = nullable
	return f
}

func (f *Field) WithDefaultValueBool(defaultValue bool) *Field {
	f.DefaultValue = &schemapb.ValueField{
		Data: &schemapb.ValueField_BoolData{
			BoolData: defaultValue,
		},
	}
	return f
}

func (f *Field) WithDefaultValueInt(defaultValue int32) *Field {
	f.DefaultValue = &schemapb.ValueField{
		Data: &schemapb.ValueField_IntData{
			IntData: defaultValue,
		},
	}
	return f
}

func (f *Field) WithDefaultValueLong(defaultValue int64) *Field {
	f.DefaultValue = &schemapb.ValueField{
		Data: &schemapb.ValueField_LongData{
			LongData: defaultValue,
		},
	}
	return f
}

func (f *Field) WithDefaultValueFloat(defaultValue float32) *Field {
	f.DefaultValue = &schemapb.ValueField{
		Data: &schemapb.ValueField_FloatData{
			FloatData: defaultValue,
		},
	}
	return f
}

func (f *Field) WithDefaultValueDouble(defaultValue float64) *Field {
	f.DefaultValue = &schemapb.ValueField{
		Data: &schemapb.ValueField_DoubleData{
			DoubleData: defaultValue,
		},
	}
	return f
}

func (f *Field) WithDefaultValueString(defaultValue string) *Field {
	f.DefaultValue = &schemapb.ValueField{
		Data: &schemapb.ValueField_StringData{
			StringData: defaultValue,
		},
	}
	return f
}

func (f *Field) WithTypeParams(key string, value string) *Field {
	if f.TypeParams == nil {
		f.TypeParams = make(map[string]string)
	}
	f.TypeParams[key] = value
	return f
}

func (f *Field) WithDim(dim int64) *Field {
	if f.TypeParams == nil {
		f.TypeParams = make(map[string]string)
	}
	f.TypeParams[TypeParamDim] = strconv.FormatInt(dim, 10)
	return f
}

func (f *Field) GetDim() (int64, error) {
	dimStr, has := f.TypeParams[TypeParamDim]
	if !has {
		return -1, errors.New("field with no dim")
	}
	dim, err := strconv.ParseInt(dimStr, 10, 64)
	if err != nil {
		return -1, errors.Newf("field with bad format dim: %s", err.Error())
	}
	return dim, nil
}

func (f *Field) WithMaxLength(maxLen int64) *Field {
	if f.TypeParams == nil {
		f.TypeParams = make(map[string]string)
	}
	f.TypeParams[TypeParamMaxLength] = strconv.FormatInt(maxLen, 10)
	return f
}

func (f *Field) WithElementType(eleType FieldType) *Field {
	f.ElementType = eleType
	return f
}

func (f *Field) WithMaxCapacity(maxCap int64) *Field {
	if f.TypeParams == nil {
		f.TypeParams = make(map[string]string)
	}
	f.TypeParams[TypeParamMaxCapacity] = strconv.FormatInt(maxCap, 10)
	return f
}

func (f *Field) WithEnableAnalyzer(enable bool) *Field {
	if f.TypeParams == nil {
		f.TypeParams = make(map[string]string)
	}
	f.TypeParams["enable_analyzer"] = strconv.FormatBool(enable)
	return f
}

func (f *Field) WithAnalyzerParams(params map[string]any) *Field {
	if f.TypeParams == nil {
		f.TypeParams = make(map[string]string)
	}
	bs, _ := json.Marshal(params)
	f.TypeParams["analyzer_params"] = string(bs)
	return f
}

func (f *Field) WithEnableMatch(enable bool) *Field {
	if f.TypeParams == nil {
		f.TypeParams = make(map[string]string)
	}
	f.TypeParams[TypeParamEnableMatch] = strconv.FormatBool(enable)
	return f
}

// ReadProto parses FieldSchema
func (f *Field) ReadProto(p *schemapb.FieldSchema) *Field {
	f.ID = p.GetFieldID()
	f.Name = p.GetName()
	f.PrimaryKey = p.GetIsPrimaryKey()
	f.AutoID = p.GetAutoID()
	f.Description = p.GetDescription()
	f.DataType = FieldType(p.GetDataType())
	f.TypeParams = KvPairsMap(p.GetTypeParams())
	f.IndexParams = KvPairsMap(p.GetIndexParams())
	f.IsDynamic = p.GetIsDynamic()
	f.IsPartitionKey = p.GetIsPartitionKey()
	f.IsClusteringKey = p.GetIsClusteringKey()
	f.ElementType = FieldType(p.GetElementType())
	f.DefaultValue = p.GetDefaultValue()
	f.Nullable = p.GetNullable()

	return f
}



---
File: /entity/function_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestFunctionSchema(t *testing.T) {
	functions := []*Function{
		NewFunction().WithName("text_bm25_emb").WithType(FunctionTypeBM25).WithInputFields("a", "b").WithOutputFields("c").WithParam("key", "value"),
		NewFunction().WithName("other_emb").WithType(FunctionTypeTextEmbedding).WithInputFields("c").WithOutputFields("b", "a"),
	}

	for _, function := range functions {
		funcSchema := function.ProtoMessage()
		assert.Equal(t, function.Name, funcSchema.Name)
		assert.Equal(t, function.Type, funcSchema.Type)
		assert.Equal(t, function.InputFieldNames, funcSchema.InputFieldNames)
		assert.Equal(t, function.OutputFieldNames, funcSchema.OutputFieldNames)
		assert.Equal(t, function.Params, KvPairsMap(funcSchema.GetParams()))

		nf := NewFunction()
		nf.ReadProto(funcSchema)

		assert.Equal(t, function.Name, nf.Name)
		assert.Equal(t, function.Type, nf.Type)
		assert.Equal(t, function.InputFieldNames, nf.InputFieldNames)
		assert.Equal(t, function.OutputFieldNames, nf.OutputFieldNames)
		assert.Equal(t, function.Params, nf.Params)
	}
}



---
File: /entity/function.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import (
	"fmt"

	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
)

type FunctionType = schemapb.FunctionType

// provide package alias
const (
	FunctionTypeUnknown       = schemapb.FunctionType_Unknown
	FunctionTypeBM25          = schemapb.FunctionType_BM25
	FunctionTypeTextEmbedding = schemapb.FunctionType_TextEmbedding
)

type Function struct {
	Name        string
	Description string
	Type        FunctionType

	InputFieldNames  []string
	OutputFieldNames []string
	Params           map[string]string

	// ids shall be private
	id             int64
	inputFieldIDs  []int64
	outputFieldIDs []int64
}

func NewFunction() *Function {
	return &Function{
		Params: make(map[string]string),
	}
}

func (f *Function) WithName(name string) *Function {
	f.Name = name
	return f
}

func (f *Function) WithInputFields(inputFields ...string) *Function {
	f.InputFieldNames = inputFields
	return f
}

func (f *Function) WithOutputFields(outputFields ...string) *Function {
	f.OutputFieldNames = outputFields
	return f
}

func (f *Function) WithType(funcType FunctionType) *Function {
	f.Type = funcType
	return f
}

func (f *Function) WithParam(key string, value any) *Function {
	f.Params[key] = fmt.Sprintf("%v", value)
	return f
}

// ProtoMessage returns corresponding schemapb.FunctionSchema
func (f *Function) ProtoMessage() *schemapb.FunctionSchema {
	r := &schemapb.FunctionSchema{
		Name:             f.Name,
		Description:      f.Description,
		Type:             f.Type,
		InputFieldNames:  f.InputFieldNames,
		OutputFieldNames: f.OutputFieldNames,
		Params:           MapKvPairs(f.Params),
	}

	return r
}

// ReadProto parses proto Collection Schema
func (f *Function) ReadProto(p *schemapb.FunctionSchema) *Function {
	f.Name = p.GetName()
	f.Description = p.GetDescription()
	f.Type = p.GetType()

	f.InputFieldNames = p.GetInputFieldNames()
	f.OutputFieldNames = p.GetOutputFieldNames()
	f.Params = KvPairsMap(p.GetParams())

	f.id = p.GetId()
	f.inputFieldIDs = p.GetInputFieldIds()
	f.outputFieldIDs = p.GetOutputFieldIds()

	return f
}



---
File: /entity/load_state.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import "github.com/milvus-io/milvus-proto/go-api/v2/commonpb"

type LoadStateCode commonpb.LoadState

const (
	// LoadStateNone      LoadStateCode = LoadStateCode(commonpb.LoadState)
	LoadStateLoading   LoadStateCode = LoadStateCode(commonpb.LoadState_LoadStateLoading)
	LoadStateLoaded    LoadStateCode = LoadStateCode(commonpb.LoadState_LoadStateLoaded)
	LoadStateUnloading LoadStateCode = LoadStateCode(commonpb.LoadState_LoadStateNotExist)
	LoadStateNotLoad   LoadStateCode = LoadStateCode(commonpb.LoadState_LoadStateNotLoad)
)

type LoadState struct {
	State    LoadStateCode
	Progress int64
}



---
File: /entity/privilege_group.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

// PrivilegeGroup is the entity model for custom privilege group.
type PrivilegeGroup struct {
	GroupName  string
	Privileges []string
}



---
File: /entity/rbac.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

type User struct {
	UserName string
	Roles    []string
}

type Role struct {
	RoleName   string
	Privileges []GrantItem
}

type GrantItem struct {
	Object     string
	ObjectName string
	RoleName   string
	Grantor    string
	Privilege  string
	DbName     string
}

type UserInfo struct {
	UserDescription
	Password string
}

// UserDescription is the model for RBAC user description object.
type UserDescription struct {
	Name  string
	Roles []string
}

type RBACMeta struct {
	Users           []*UserInfo
	Roles           []*Role
	RoleGrants      []*RoleGrants
	PrivilegeGroups []*PrivilegeGroup
}

// RoleGrants is the model for RBAC role description object.
type RoleGrants struct {
	Object        string
	ObjectName    string
	RoleName      string
	GrantorName   string
	PrivilegeName string
	DbName        string
}



---
File: /entity/resource_group.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

type ResourceGroup struct {
	Name             string
	Capacity         int32
	NumAvailableNode int32
	NumLoadedReplica map[string]int32
	NumOutgoingNode  map[string]int32
	NumIncomingNode  map[string]int32
	Config           *ResourceGroupConfig
	Nodes            []NodeInfo
}

type NodeInfo struct {
	NodeID   int64
	Address  string
	HostName string
}

type ResourceGroupLimit struct {
	NodeNum int32
}

type ResourceGroupTransfer struct {
	ResourceGroup string
}

type ResourceGroupNodeFilter struct {
	NodeLabels map[string]string
}

type ResourceGroupConfig struct {
	Requests     ResourceGroupLimit
	Limits       ResourceGroupLimit
	TransferFrom []*ResourceGroupTransfer
	TransferTo   []*ResourceGroupTransfer
	NodeFilter   ResourceGroupNodeFilter
}

type ReplicaInfo struct {
	ReplicaID         int64
	Shards            []*Shard
	Nodes             []int64
	ResourceGroupName string
	NumOutboundNode   map[string]int32
}

type Shard struct {
	ChannelName string
	ShardNodes  []int64
	ShardLeader int64
}



---
File: /entity/schema_example_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// nolint
package entity_test

import (
	"log"

	"github.com/milvus-io/milvus/client/v2/entity"
)

func ExampleNewSchema() {
	schema := entity.NewSchema()
	log.Println(schema)
}

func ExampleSchema_WithField_primaryKey() {
	schema := entity.NewSchema()
	schema.WithField(entity.NewField().WithName("my_id").
		WithDataType(entity.FieldTypeInt64).
		WithIsPrimaryKey(true).
		WithIsAutoID(false),
	)
}

func ExampleSchema_WithField_varcharPK() {
	schema := entity.NewSchema()
	schema.WithField(entity.NewField().WithName("my_id").
		WithDataType(entity.FieldTypeVarChar).
		WithIsPrimaryKey(true).
		WithMaxLength(100),
	)
}

func ExampleSchema_WithField_vectorField() {
	schema := entity.NewSchema()
	schema.WithField(entity.NewField().WithName("my_vector").
		WithDataType(entity.FieldTypeFloatVector).
		WithDim(5),
	)
}

func ExampleSchema_WithField_varcharField() {
	schema := entity.NewSchema()
	schema.WithField(entity.NewField().WithName("my_varchar").
		WithDataType(entity.FieldTypeVarChar).
		WithMaxLength(512),
	)
}

func ExampleSchema_WithField_int64Field() {
	schema := entity.NewSchema()
	schema.WithField(entity.NewField().WithName("my_int64").
		WithDataType(entity.FieldTypeInt64),
	)
}

func ExampleSchema_WithField_boolField() {
	schema := entity.NewSchema()
	schema.WithField(entity.NewField().WithName("my_bool").
		WithDataType(entity.FieldTypeBool),
	)
}

func ExampleSchema_WithField_jsonField() {
	schema := entity.NewSchema()
	schema.WithField(entity.NewField().WithName("my_json").
		WithDataType(entity.FieldTypeJSON),
	)
}

func ExampleSchema_WithField_arrayField() {
	schema := entity.NewSchema()
	schema.WithField(entity.NewField().WithName("my_array").
		WithDataType(entity.FieldTypeArray).
		WithElementType(entity.FieldTypeInt64).
		WithMaxLength(512).
		WithMaxCapacity(5),
	)
}

func ExampleSchema_WithField_pkAndVector() {
	schema := entity.NewSchema()
	schema.WithField(entity.NewField().
		WithName("pk").
		WithDataType(entity.FieldTypeVarChar).
		WithMaxLength(100),
	).WithField(entity.NewField().
		WithName("dense_vector").
		WithDataType(entity.FieldTypeFloatVector).
		WithDim(4),
	)
}

func ExampleSchema_WithField_binaryVector() {
	schema := entity.NewSchema()
	schema.WithField(entity.NewField().
		WithName("pk").
		WithDataType(entity.FieldTypeVarChar).
		WithMaxLength(100).
		WithIsAutoID(true),
	).WithField(entity.NewField().
		WithName("binary_vector").
		WithDataType(entity.FieldTypeBinaryVector).
		WithDim(128),
	)
}



---
File: /entity/schema_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
)

func TestCL_CommonCL(t *testing.T) {
	cls := []ConsistencyLevel{
		ClStrong,
		ClBounded,
		ClSession,
		ClEventually,
	}
	for _, cl := range cls {
		assert.EqualValues(t, commonpb.ConsistencyLevel(cl), cl.CommonConsistencyLevel())
	}
}

type SchemaSuite struct {
	suite.Suite
}

func (s *SchemaSuite) TestBasic() {
	cases := []struct {
		tag    string
		input  *Schema
		pkName string
	}{
		{
			"test_collection",
			NewSchema().WithName("test_collection_1").WithDescription("test_collection_1 desc").WithAutoID(false).
				WithField(NewField().WithName("ID").WithDataType(FieldTypeInt64).WithIsPrimaryKey(true)).
				WithField(NewField().WithName("vector").WithDataType(FieldTypeFloatVector).WithDim(128)).
				WithFunction(NewFunction()),
			"ID",
		},
		{
			"dynamic_schema",
			NewSchema().WithName("dynamic_schema").WithDescription("dynamic_schema desc").WithAutoID(true).WithDynamicFieldEnabled(true).
				WithField(NewField().WithName("ID").WithDataType(FieldTypeVarChar).WithMaxLength(256)).
				WithField(NewField().WithName("$meta").WithIsDynamic(true)),
			"",
		},
	}

	for _, c := range cases {
		s.Run(c.tag, func() {
			sch := c.input
			p := sch.ProtoMessage()
			s.Equal(sch.CollectionName, p.GetName())
			s.Equal(sch.AutoID, p.GetAutoID())
			s.Equal(sch.Description, p.GetDescription())
			s.Equal(sch.EnableDynamicField, p.GetEnableDynamicField())
			s.Equal(len(sch.Fields), len(p.GetFields()))
			s.Equal(len(sch.Functions), len(p.GetFunctions()))

			nsch := &Schema{}
			nsch = nsch.ReadProto(p)

			s.Equal(sch.CollectionName, nsch.CollectionName)
			s.Equal(sch.Description, nsch.Description)
			s.Equal(sch.EnableDynamicField, nsch.EnableDynamicField)
			s.Equal(len(sch.Fields), len(nsch.Fields))
			s.Equal(len(sch.Functions), len(nsch.Functions))
			s.Equal(c.pkName, sch.PKFieldName())
			s.Equal(c.pkName, nsch.PKFieldName())
		})
	}
}

func TestSchema(t *testing.T) {
	suite.Run(t, new(SchemaSuite))
}



---
File: /entity/schema.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import (
	"github.com/samber/lo"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
)

const (
	// TypeParamDim is the const for field type param dimension
	TypeParamDim = "dim"

	// TypeParamMaxLength is the const for varchar type maximal length
	TypeParamMaxLength = "max_length"

	// TypeParamMaxCapacity is the const for array type max capacity
	TypeParamMaxCapacity = `max_capacity`

	// TypeParamEnableMatch is the const for enable text match
	TypeParamEnableMatch = `enable_match`

	// ClStrong strong consistency level
	ClStrong ConsistencyLevel = ConsistencyLevel(commonpb.ConsistencyLevel_Strong)
	// ClBounded bounded consistency level with default tolerance of 5 seconds
	ClBounded ConsistencyLevel = ConsistencyLevel(commonpb.ConsistencyLevel_Bounded)
	// ClSession session consistency level
	ClSession ConsistencyLevel = ConsistencyLevel(commonpb.ConsistencyLevel_Session)
	// ClEvenually eventually consistency level
	ClEventually ConsistencyLevel = ConsistencyLevel(commonpb.ConsistencyLevel_Eventually)
	// ClCustomized customized consistency level and users pass their own `guarantee_timestamp`.
	ClCustomized ConsistencyLevel = ConsistencyLevel(commonpb.ConsistencyLevel_Customized)
)

// ConsistencyLevel enum type for collection Consistency Level
type ConsistencyLevel commonpb.ConsistencyLevel

// CommonConsistencyLevel returns corresponding commonpb.ConsistencyLevel
func (cl ConsistencyLevel) CommonConsistencyLevel() commonpb.ConsistencyLevel {
	return commonpb.ConsistencyLevel(cl)
}

// Schema represents schema info of collection in milvus
type Schema struct {
	CollectionName     string
	Description        string
	AutoID             bool
	Fields             []*Field
	EnableDynamicField bool
	Functions          []*Function

	pkField *Field
}

// NewSchema creates an empty schema object.
func NewSchema() *Schema {
	return &Schema{}
}

// WithName sets the name value of schema, returns schema itself.
func (s *Schema) WithName(name string) *Schema {
	s.CollectionName = name
	return s
}

// WithDescription sets the description value of schema, returns schema itself.
func (s *Schema) WithDescription(desc string) *Schema {
	s.Description = desc
	return s
}

func (s *Schema) WithAutoID(autoID bool) *Schema {
	s.AutoID = autoID
	return s
}

func (s *Schema) WithDynamicFieldEnabled(dynamicEnabled bool) *Schema {
	s.EnableDynamicField = dynamicEnabled
	return s
}

// WithField adds a field into schema and returns schema itself.
func (s *Schema) WithField(f *Field) *Schema {
	if f.PrimaryKey {
		s.pkField = f
	}
	s.Fields = append(s.Fields, f)
	return s
}

func (s *Schema) WithFunction(f *Function) *Schema {
	s.Functions = append(s.Functions, f)
	return s
}

// ProtoMessage returns corresponding server.CollectionSchema
func (s *Schema) ProtoMessage() *schemapb.CollectionSchema {
	r := &schemapb.CollectionSchema{
		Name:               s.CollectionName,
		Description:        s.Description,
		AutoID:             s.AutoID,
		EnableDynamicField: s.EnableDynamicField,
	}
	r.Fields = lo.Map(s.Fields, func(field *Field, _ int) *schemapb.FieldSchema {
		return field.ProtoMessage()
	})

	r.Functions = lo.Map(s.Functions, func(function *Function, _ int) *schemapb.FunctionSchema {
		return function.ProtoMessage()
	})

	return r
}

// ReadProto parses proto Collection Schema
func (s *Schema) ReadProto(p *schemapb.CollectionSchema) *Schema {
	s.Description = p.GetDescription()
	s.CollectionName = p.GetName()
	s.EnableDynamicField = p.GetEnableDynamicField()
	// fields
	s.Fields = make([]*Field, 0, len(p.GetFields()))
	for _, fp := range p.GetFields() {
		field := NewField().ReadProto(fp)
		if fp.GetAutoID() {
			s.AutoID = true
		}
		if field.PrimaryKey {
			s.pkField = field
		}
		s.Fields = append(s.Fields, field)
	}
	// functions
	s.Functions = lo.Map(p.GetFunctions(), func(fn *schemapb.FunctionSchema, _ int) *Function {
		return NewFunction().ReadProto(fn)
	})

	return s
}

// PKFieldName returns pk field name for this schemapb.
func (s *Schema) PKFieldName() string {
	if s.pkField == nil {
		return ""
	}
	return s.pkField.Name
}

// PKField returns PK Field schema for this schema.
func (s *Schema) PKField() *Field {
	return s.pkField
}

// MapKvPairs converts map into commonpb.KeyValuePair slice
func MapKvPairs(m map[string]string) []*commonpb.KeyValuePair {
	pairs := make([]*commonpb.KeyValuePair, 0, len(m))
	for k, v := range m {
		pairs = append(pairs, &commonpb.KeyValuePair{
			Key:   k,
			Value: v,
		})
	}
	return pairs
}

// KvPairsMap converts commonpb.KeyValuePair slices into map
func KvPairsMap(kvps []*commonpb.KeyValuePair) map[string]string {
	m := make(map[string]string)
	for _, kvp := range kvps {
		m[kvp.Key] = kvp.Value
	}
	return m
}



---
File: /entity/segment.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import "github.com/milvus-io/milvus-proto/go-api/v2/commonpb"

// Segment represent segment in milvus
type Segment struct {
	ID           int64
	CollectionID int64
	ParititionID int64

	NumRows int64
	State   commonpb.SegmentState
}

// Flushed indicates segment is flushed
func (s Segment) Flushed() bool {
	return s.State == commonpb.SegmentState_Flushed
}



---
File: /entity/sparse_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import (
	"math/rand"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSliceSparseEmbedding(t *testing.T) {
	t.Run("normal_case", func(t *testing.T) {
		length := 1 + rand.Intn(5)
		positions := make([]uint32, length)
		values := make([]float32, length)
		for i := 0; i < length; i++ {
			positions[i] = uint32(i)
			values[i] = rand.Float32()
		}
		se, err := NewSliceSparseEmbedding(positions, values)
		require.NoError(t, err)

		assert.EqualValues(t, length, se.Dim())
		assert.EqualValues(t, length, se.Len())

		bs := se.Serialize()
		nv, err := DeserializeSliceSparseEmbedding(bs)
		require.NoError(t, err)

		for i := 0; i < length; i++ {
			pos, val, ok := se.Get(i)
			require.True(t, ok)
			assert.Equal(t, positions[i], pos)
			assert.Equal(t, values[i], val)

			npos, nval, ok := nv.Get(i)
			require.True(t, ok)
			assert.Equal(t, positions[i], npos)
			assert.Equal(t, values[i], nval)
		}

		_, _, ok := se.Get(-1)
		assert.False(t, ok)
		_, _, ok = se.Get(length)
		assert.False(t, ok)
	})

	t.Run("position values not match", func(t *testing.T) {
		_, err := NewSliceSparseEmbedding([]uint32{1}, []float32{})
		assert.Error(t, err)
	})
}



---
File: /entity/sparse.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import (
	"encoding/binary"
	"math"
	"sort"

	"github.com/cockroachdb/errors"
)

type SparseEmbedding interface {
	Dim() int // the dimension
	Len() int // the actual items in this vector
	Get(idx int) (pos uint32, value float32, ok bool)
	Serialize() []byte
	FieldType() FieldType
}

var (
	_ SparseEmbedding = sliceSparseEmbedding{}
	_ Vector          = sliceSparseEmbedding{}
)

type sliceSparseEmbedding struct {
	positions []uint32
	values    []float32
	dim       int
	len       int
}

func (e sliceSparseEmbedding) Dim() int {
	return e.dim
}

func (e sliceSparseEmbedding) Len() int {
	return e.len
}

func (e sliceSparseEmbedding) FieldType() FieldType {
	return FieldTypeSparseVector
}

func (e sliceSparseEmbedding) Get(idx int) (uint32, float32, bool) {
	if idx < 0 || idx >= e.len {
		return 0, 0, false
	}
	return e.positions[idx], e.values[idx], true
}

func (e sliceSparseEmbedding) Serialize() []byte {
	row := make([]byte, 8*e.Len())
	for idx := 0; idx < e.Len(); idx++ {
		pos, value, _ := e.Get(idx)
		binary.LittleEndian.PutUint32(row[idx*8:], pos)
		binary.LittleEndian.PutUint32(row[idx*8+4:], math.Float32bits(value))
	}
	return row
}

// Less implements sort.Interce
func (e sliceSparseEmbedding) Less(i, j int) bool {
	return e.positions[i] < e.positions[j]
}

func (e sliceSparseEmbedding) Swap(i, j int) {
	e.positions[i], e.positions[j] = e.positions[j], e.positions[i]
	e.values[i], e.values[j] = e.values[j], e.values[i]
}

func DeserializeSliceSparseEmbedding(bs []byte) (sliceSparseEmbedding, error) {
	length := len(bs)
	if length%8 != 0 {
		return sliceSparseEmbedding{}, errors.New("not valid sparse embedding bytes")
	}

	length /= 8

	result := sliceSparseEmbedding{
		positions: make([]uint32, length),
		values:    make([]float32, length),
		len:       length,
	}

	for i := 0; i < length; i++ {
		result.positions[i] = binary.LittleEndian.Uint32(bs[i*8 : i*8+4])
		result.values[i] = math.Float32frombits(binary.LittleEndian.Uint32(bs[i*8+4 : i*8+8]))
	}
	return result, nil
}

func NewSliceSparseEmbedding(positions []uint32, values []float32) (SparseEmbedding, error) {
	if len(positions) != len(values) {
		return nil, errors.New("invalid sparse embedding input, positions shall have same number of values")
	}

	se := sliceSparseEmbedding{
		positions: positions,
		values:    values,
		len:       len(positions),
	}

	sort.Sort(se)

	if se.len > 0 {
		se.dim = int(se.positions[se.len-1]) + 1
	}

	return se, nil
}



---
File: /entity/vectors_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import (
	"math/rand"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestVectors(t *testing.T) {
	dim := rand.Intn(127) + 1

	t.Run("test float vector", func(t *testing.T) {
		raw := make([]float32, dim)
		for i := 0; i < dim; i++ {
			raw[i] = rand.Float32()
		}

		fv := FloatVector(raw)
		assert.Equal(t, dim, fv.Dim())
		assert.Equal(t, dim*4, len(fv.Serialize()))

		var fvConverted FloatVector

		fp16v := fv.ToFloat16Vector()
		assert.Equal(t, dim, fp16v.Dim())
		assert.Equal(t, dim*2, len(fp16v.Serialize()))
		fvConverted = fp16v.ToFloat32Vector()
		assert.Equal(t, dim, fvConverted.Dim())
		assert.Equal(t, dim*4, len(fvConverted.Serialize()))

		bf16v := fv.ToBFloat16Vector()
		assert.Equal(t, dim, bf16v.Dim())
		assert.Equal(t, dim*2, len(bf16v.Serialize()))
		fvConverted = bf16v.ToFloat32Vector()
		assert.Equal(t, dim, fvConverted.Dim())
		assert.Equal(t, dim*4, len(fvConverted.Serialize()))
	})

	t.Run("test fp32 <-> fp16/bf16 vector conversion", func(t *testing.T) {
		raw := make([]float32, dim)
		for i := 0; i < dim; i++ {
			raw[i] = rand.Float32() // rand result [0.1, 1.0)
		}

		fv := FloatVector(raw)
		fp16v := fv.ToFloat16Vector()
		bf16v := fv.ToBFloat16Vector()

		assert.Equal(t, dim, fp16v.Dim())
		assert.Equal(t, dim*2, len(fp16v.Serialize()))
		assert.Equal(t, dim, bf16v.Dim())
		assert.Equal(t, dim*2, len(bf16v.Serialize()))

		// TODO calculate max precision loss
		maxDelta := float64(0.4)

		fp32vFromfp16v := fp16v.ToFloat32Vector()
		for i := 0; i < dim; i++ {
			assert.InDelta(t, fv[i], fp32vFromfp16v[i], maxDelta)
		}

		fp32vFrombf16v := bf16v.ToFloat32Vector()
		for i := 0; i < dim; i++ {
			assert.InDelta(t, fp32vFromfp16v[i], fp32vFrombf16v[i], maxDelta)
		}
	})

	t.Run("test binary vector", func(t *testing.T) {
		raw := make([]byte, dim)
		_, err := rand.Read(raw)
		assert.Nil(t, err)

		bv := BinaryVector(raw)

		assert.Equal(t, dim*8, bv.Dim())
		assert.ElementsMatch(t, raw, bv.Serialize())
	})
}



---
File: /entity/vectors.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package entity

import (
	"github.com/milvus-io/milvus/pkg/v2/util/typeutil"
)

// Vector interface vector used int search
type Vector interface {
	Dim() int
	Serialize() []byte
	FieldType() FieldType
}

// FloatVector float32 vector wrapper.
type FloatVector []float32

// Dim returns vector dimension.
func (fv FloatVector) Dim() int {
	return len(fv)
}

// entity.FieldType returns coresponding field type.
func (fv FloatVector) FieldType() FieldType {
	return FieldTypeFloatVector
}

// Serialize serializes vector into byte slice, used in search placeholder
// LittleEndian is used for convention
func (fv FloatVector) Serialize() []byte {
	return typeutil.Float32ArrayToBytes(fv)
}

func (fv FloatVector) ToFloat16Vector() Float16Vector {
	return typeutil.Float32ArrayToFloat16Bytes(fv)
}

// SerializeToBFloat16Bytes serializes vector into bfloat16 byte slice,
// used in search placeholder
func (fv FloatVector) ToBFloat16Vector() BFloat16Vector {
	return typeutil.Float32ArrayToBFloat16Bytes(fv)
}

// FloatVector float32 vector wrapper.
type Float16Vector []byte

// Dim returns vector dimension.
func (fv Float16Vector) Dim() int {
	return len(fv) / 2
}

// entity.FieldType returns coresponding field type.
func (fv Float16Vector) FieldType() FieldType {
	return FieldTypeFloat16Vector
}

func (fv Float16Vector) Serialize() []byte {
	return fv
}

func (fv Float16Vector) ToFloat32Vector() FloatVector {
	return typeutil.Float16BytesToFloat32Vector(fv)
}

// FloatVector float32 vector wrapper.
type BFloat16Vector []byte

// Dim returns vector dimension.
func (fv BFloat16Vector) Dim() int {
	return len(fv) / 2
}

// entity.FieldType returns coresponding field type.
func (fv BFloat16Vector) FieldType() FieldType {
	return FieldTypeBFloat16Vector
}

func (fv BFloat16Vector) Serialize() []byte {
	return fv
}

func (fv BFloat16Vector) ToFloat32Vector() FloatVector {
	return typeutil.BFloat16BytesToFloat32Vector(fv)
}

// BinaryVector []byte vector wrapper
type BinaryVector []byte

// Dim return vector dimension, note that binary vector is bits count
func (bv BinaryVector) Dim() int {
	return 8 * len(bv)
}

// Serialize just return bytes
func (bv BinaryVector) Serialize() []byte {
	return bv
}

// entity.FieldType returns coresponding field type.
func (bv BinaryVector) FieldType() FieldType {
	return FieldTypeBinaryVector
}

type Text string

// Dim returns vector dimension.
func (t Text) Dim() int {
	return 0
}

// entity.FieldType returns coresponding field type.
func (t Text) FieldType() FieldType {
	return FieldTypeVarChar
}

func (t Text) Serialize() []byte {
	return []byte(t)
}



---
File: /index/ann_param_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestAnnParams(t *testing.T) {
	ivfAP := NewIvfAnnParam(16)
	result := ivfAP.Params()
	v, ok := result[ivfNprobeKey]
	assert.True(t, ok)
	assert.Equal(t, 16, v)

	hnswAP := NewHNSWAnnParam(16)
	result = hnswAP.Params()
	v, ok = result[hnswEfKey]
	assert.True(t, ok)
	assert.Equal(t, 16, v)

	diskAP := NewDiskAnnParam(10)
	result = diskAP.Params()
	v, ok = result[diskANNSearchListKey]
	assert.True(t, ok)
	assert.Equal(t, 10, v)

	scannAP := NewSCANNAnnParam(32, 50)
	result = scannAP.Params()
	v, ok = result[scannNProbeKey]
	assert.True(t, ok)
	assert.Equal(t, 32, v)
	v, ok = result[scannReorderKKey]
	assert.True(t, ok)
	assert.Equal(t, 50, v)
}



---
File: /index/ann_param.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

type AnnParam interface {
	Params() map[string]any
}

type baseAnnParam struct {
	params map[string]any
}

func (b baseAnnParam) WithExtraParam(key string, value any) {
	b.params[key] = value
}

func (b baseAnnParam) Params() map[string]any {
	return b.params
}

func (b baseAnnParam) WithRadius(radius float64) {
	b.WithExtraParam("radius", radius)
}

func (b baseAnnParam) WithRangeFilter(rangeFilter float64) {
	b.WithExtraParam("range_filter", rangeFilter)
}

type CustomAnnParam struct {
	baseAnnParam
}

func NewCustomAnnParam() CustomAnnParam {
	return CustomAnnParam{
		baseAnnParam: baseAnnParam{
			params: make(map[string]any),
		},
	}
}



---
File: /index/auto_example_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// nolint
package index_test

import (
	"log"

	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/index"
)

func ExampleNewAutoIndex() {
	index := index.NewAutoIndex(entity.L2)
	log.Println(index)
}



---
File: /index/auto.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

const (
	autoLevelKey = `level`
)

var _ Index = autoIndex{}

type autoIndex struct {
	baseIndex
}

func (idx autoIndex) Params() map[string]string {
	return map[string]string{
		MetricTypeKey: string(idx.metricType),
		IndexTypeKey:  string(AUTOINDEX),
	}
}

func NewAutoIndex(metricType MetricType) Index {
	return autoIndex{
		baseIndex: baseIndex{
			indexType:  AUTOINDEX,
			metricType: metricType,
		},
	}
}

type autoAnnParam struct {
	baseAnnParam
	level int
}

func NewAutoAnnParam(level int) autoAnnParam {
	return autoAnnParam{
		baseAnnParam: baseAnnParam{
			params: make(map[string]any),
		},
		level: level,
	}
}

func (ap autoAnnParam) Params() map[string]any {
	result := ap.baseAnnParam.params
	result[autoLevelKey] = ap.level
	return result
}



---
File: /index/common.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

import (
	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

// index param field tag
const (
	IndexTypeKey  = `index_type`
	MetricTypeKey = `metric_type`
	ParamsKey     = `params`
)

// IndexState export index state
type IndexState commonpb.IndexState

// IndexType index type
type IndexType string

// MetricType alias for `entity.MetricsType`.
type MetricType = entity.MetricType

// Index Constants
const (
	Flat       IndexType = "FLAT" // faiss
	BinFlat    IndexType = "BIN_FLAT"
	IvfFlat    IndexType = "IVF_FLAT" // faiss
	BinIvfFlat IndexType = "BIN_IVF_FLAT"
	IvfPQ      IndexType = "IVF_PQ" // faiss
	IvfSQ8     IndexType = "IVF_SQ8"
	HNSW       IndexType = "HNSW"
	IvfHNSW    IndexType = "IVF_HNSW"
	AUTOINDEX  IndexType = "AUTOINDEX"
	DISKANN    IndexType = "DISKANN"
	SCANN      IndexType = "SCANN"

	// Sparse
	SparseInverted IndexType = "SPARSE_INVERTED_INDEX"
	SparseWAND     IndexType = "SPARSE_WAND"

	GPUIvfFlat IndexType = "GPU_IVF_FLAT"
	GPUIvfPQ   IndexType = "GPU_IVF_PQ"

	GPUCagra      IndexType = "GPU_CAGRA"
	GPUBruteForce IndexType = "GPU_BRUTE_FORCE"

	Trie     IndexType = "Trie"
	Sorted   IndexType = "STL_SORT"
	Inverted IndexType = "INVERTED"
	BITMAP   IndexType = "BITMAP"
)



---
File: /index/disk_ann.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

const (
	diskANNSearchListKey = `search_list`
)

var _ Index = diskANNIndex{}

type diskANNIndex struct {
	baseIndex
}

func (idx diskANNIndex) Params() map[string]string {
	return map[string]string{
		MetricTypeKey: string(idx.metricType),
		IndexTypeKey:  string(DISKANN),
	}
}

func NewDiskANNIndex(metricType MetricType) Index {
	return &diskANNIndex{
		baseIndex: baseIndex{
			metricType: metricType,
			indexType:  DISKANN,
		},
	}
}

type diskANNParam struct {
	baseAnnParam
	searchList int
}

func NewDiskAnnParam(searchList int) diskANNParam {
	return diskANNParam{
		baseAnnParam: baseAnnParam{
			params: make(map[string]any),
		},
		searchList: searchList,
	}
}

func (ap diskANNParam) Params() map[string]any {
	result := ap.baseAnnParam.params
	result[diskANNSearchListKey] = ap.searchList
	return result
}



---
File: /index/flat.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

var _ Index = flatIndex{}

type flatIndex struct {
	baseIndex
}

func (idx flatIndex) Params() map[string]string {
	return map[string]string{
		MetricTypeKey: string(idx.metricType),
		IndexTypeKey:  string(Flat),
	}
}

func NewFlatIndex(metricType MetricType) Index {
	return flatIndex{
		baseIndex: baseIndex{
			metricType: metricType,
			indexType:  Flat,
		},
	}
}

var _ Index = binFlatIndex{}

type binFlatIndex struct {
	baseIndex
}

func (idx binFlatIndex) Params() map[string]string {
	return map[string]string{
		MetricTypeKey: string(idx.metricType),
		IndexTypeKey:  string(BinFlat),
	}
}

func NewBinFlatIndex(metricType MetricType) Index {
	return binFlatIndex{
		baseIndex: baseIndex{
			metricType: metricType,
			indexType:  BinFlat,
		},
	}
}



---
File: /index/gpu.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

import "strconv"

var _ Index = gpuBruteForceIndex{}

type gpuBruteForceIndex struct {
	baseIndex
}

func (idx gpuBruteForceIndex) Params() map[string]string {
	return map[string]string{
		// build meta
		MetricTypeKey: string(idx.metricType),
		IndexTypeKey:  string(GPUBruteForce),
	}
}

func NewGPUBruteForceIndex(metricType MetricType) Index {
	return gpuBruteForceIndex{
		baseIndex: baseIndex{
			metricType: metricType,
		},
	}
}

var _ Index = gpuIVFFlatIndex{}

type gpuIVFFlatIndex struct {
	baseIndex
	nlist int
}

func (idx gpuIVFFlatIndex) Params() map[string]string {
	return map[string]string{
		// build meta
		MetricTypeKey: string(idx.metricType),
		IndexTypeKey:  string(GPUIvfFlat),
		// build param
		ivfNlistKey: strconv.Itoa(idx.nlist),
	}
}

func NewGPUIVPFlatIndex(metricType MetricType) Index {
	return gpuIVFFlatIndex{
		baseIndex: baseIndex{
			metricType: metricType,
		},
	}
}

var _ Index = gpuIVFPQIndex{}

type gpuIVFPQIndex struct {
	baseIndex
	nlist int
	m     int
	nbits int
}

func (idx gpuIVFPQIndex) Params() map[string]string {
	return map[string]string{
		// build meta
		MetricTypeKey: string(idx.metricType),
		IndexTypeKey:  string(GPUIvfFlat),
		// build params
		ivfNlistKey: strconv.Itoa(idx.nlist),
		ivfPQMKey:   strconv.Itoa(idx.m),
		ivfPQNbits:  strconv.Itoa(idx.nbits),
	}
}

func NewGPUIVPPQIndex(metricType MetricType) Index {
	return gpuIVFPQIndex{
		baseIndex: baseIndex{
			metricType: metricType,
		},
	}
}

const (
	cagraInterGraphDegreeKey = `intermediate_graph_degree`
	cagraGraphDegreeKey      = `"graph_degree"`
)

type gpuCagra struct {
	baseIndex
	intermediateGraphDegree int
	graphDegree             int
}

func (idx gpuCagra) Params() map[string]string {
	return map[string]string{
		// build meta
		MetricTypeKey: string(idx.metricType),
		IndexTypeKey:  string(GPUIvfFlat),
		// build params
		cagraInterGraphDegreeKey: strconv.Itoa(idx.intermediateGraphDegree),
		cagraGraphDegreeKey:      strconv.Itoa(idx.graphDegree),
	}
}

func NewGPUCagraIndex(metricType MetricType,
	intermediateGraphDegree,
	graphDegree int,
) Index {
	return gpuCagra{
		baseIndex: baseIndex{
			metricType: metricType,
		},
		intermediateGraphDegree: intermediateGraphDegree,
		graphDegree:             graphDegree,
	}
}



---
File: /index/hnsw.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

import (
	"strconv"
)

const (
	hnswMKey           = `M`
	hsnwEfConstruction = `efConstruction`
	hnswEfKey          = `ef`
)

var _ Index = hnswIndex{}

type hnswIndex struct {
	baseIndex

	m              int
	efConstruction int // exploratory factor when building index
}

func (idx hnswIndex) Params() map[string]string {
	return map[string]string{
		MetricTypeKey:      string(idx.metricType),
		IndexTypeKey:       string(HNSW),
		hnswMKey:           strconv.Itoa(idx.m),
		hsnwEfConstruction: strconv.Itoa(idx.efConstruction),
	}
}

func NewHNSWIndex(metricType MetricType, m int, efConstruction int) Index {
	return hnswIndex{
		baseIndex: baseIndex{
			metricType: metricType,
			indexType:  HNSW,
		},
		m:              m,
		efConstruction: efConstruction,
	}
}

type hsnwAnnParam struct {
	baseAnnParam
	ef int
}

func NewHNSWAnnParam(ef int) hsnwAnnParam {
	return hsnwAnnParam{
		baseAnnParam: baseAnnParam{
			params: make(map[string]any),
		},
		ef: ef,
	}
}

func (ap hsnwAnnParam) Params() map[string]any {
	result := ap.baseAnnParam.params
	result[hnswEfKey] = ap.ef
	return result
}



---
File: /index/index_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index



---
File: /index/index.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

import "encoding/json"

// Index represent index definition in milvus.
type Index interface {
	Name() string
	IndexType() IndexType
	Params() map[string]string
}

type baseIndex struct {
	name       string
	metricType MetricType
	indexType  IndexType
	params     map[string]string
}

func (idx baseIndex) Name() string {
	return idx.name
}

func (idx baseIndex) IndexType() IndexType {
	return idx.indexType
}

func (idx baseIndex) Params() map[string]string {
	return idx.params
}

func (idx baseIndex) getExtraParams(params map[string]any) string {
	bs, _ := json.Marshal(params)
	return string(bs)
}

var _ Index = GenericIndex{}

type GenericIndex struct {
	baseIndex
	params map[string]string
}

// Params implements Index
func (gi GenericIndex) Params() map[string]string {
	m := make(map[string]string)
	if gi.baseIndex.indexType != "" {
		m[IndexTypeKey] = string(gi.IndexType())
	}
	for k, v := range gi.params {
		m[k] = v
	}
	return m
}

func (gi GenericIndex) WithMetricType(metricType MetricType) {
	gi.baseIndex.metricType = metricType
}

// NewGenericIndex create generic index instance
func NewGenericIndex(name string, params map[string]string) GenericIndex {
	return GenericIndex{
		baseIndex: baseIndex{
			name: name,
		},
		params: params,
	}
}



---
File: /index/ivf.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

import "strconv"

const (
	ivfNlistKey  = `nlist`
	ivfPQMKey    = `m`
	ivfPQNbits   = `nbits`
	ivfNprobeKey = `nprobe`
)

var _ Index = ivfFlatIndex{}

type ivfFlatIndex struct {
	baseIndex

	nlist int
}

func (idx ivfFlatIndex) Params() map[string]string {
	return map[string]string{
		MetricTypeKey: string(idx.metricType),
		IndexTypeKey:  string(IvfFlat),
		ivfNlistKey:   strconv.Itoa(idx.nlist),
	}
}

func NewIvfFlatIndex(metricType MetricType, nlist int) Index {
	return ivfFlatIndex{
		baseIndex: baseIndex{
			metricType: metricType,
			indexType:  IvfFlat,
		},

		nlist: nlist,
	}
}

var _ Index = ivfPQIndex{}

type ivfPQIndex struct {
	baseIndex

	nlist int
	m     int
	nbits int
}

func (idx ivfPQIndex) Params() map[string]string {
	return map[string]string{
		MetricTypeKey: string(idx.metricType),
		IndexTypeKey:  string(IvfPQ),
		ivfNlistKey:   strconv.Itoa(idx.nlist),
		ivfPQMKey:     strconv.Itoa(idx.m),
		ivfPQNbits:    strconv.Itoa(idx.nbits),
	}
}

func NewIvfPQIndex(metricType MetricType, nlist int, m int, nbits int) Index {
	return ivfPQIndex{
		baseIndex: baseIndex{
			metricType: metricType,
			indexType:  IvfPQ,
		},

		nlist: nlist,
		m:     m,
		nbits: nbits,
	}
}

var _ Index = ivfSQ8Index{}

type ivfSQ8Index struct {
	baseIndex

	nlist int
}

func (idx ivfSQ8Index) Params() map[string]string {
	return map[string]string{
		MetricTypeKey: string(idx.metricType),
		IndexTypeKey:  string(IvfSQ8),
		ivfNlistKey:   strconv.Itoa(idx.nlist),
	}
}

func NewIvfSQ8Index(metricType MetricType, nlist int) Index {
	return ivfSQ8Index{
		baseIndex: baseIndex{
			metricType: metricType,
			indexType:  IvfSQ8,
		},

		nlist: nlist,
	}
}

var _ Index = binIvfFlat{}

type binIvfFlat struct {
	baseIndex

	nlist int
}

func (idx binIvfFlat) Params() map[string]string {
	return map[string]string{
		MetricTypeKey: string(idx.metricType),
		IndexTypeKey:  string(BinIvfFlat),
		ivfNlistKey:   strconv.Itoa(idx.nlist),
	}
}

func NewBinIvfFlatIndex(metricType MetricType, nlist int) Index {
	return binIvfFlat{
		baseIndex: baseIndex{
			metricType: metricType,
			indexType:  BinIvfFlat,
		},

		nlist: nlist,
	}
}

type ivfAnnParam struct {
	baseAnnParam
	nprobe int
}

func (ap ivfAnnParam) Params() map[string]any {
	result := ap.baseAnnParam.Params()
	result[ivfNprobeKey] = ap.nprobe
	return result
}

func NewIvfAnnParam(nprobe int) ivfAnnParam {
	return ivfAnnParam{
		baseAnnParam: baseAnnParam{
			params: make(map[string]any),
		},
		nprobe: nprobe,
	}
}



---
File: /index/json_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

import (
	"fmt"
	"math/rand"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/milvus-io/milvus/pkg/v2/common"
)

func TestJsonPathIndex(t *testing.T) {
	// for unit test logic only, supported types are determined in milvus server.
	indexTypes := []IndexType{Inverted, BITMAP, Sorted}
	jsonCastTypes := []string{"double", "int", "varchar"}
	jsonPath := fmt.Sprintf("fieldName['%d']", rand.Intn(100))
	indexName := fmt.Sprintf("idx_%d", rand.Intn(100))

	indexType := indexTypes[rand.Intn(len(indexTypes))]
	castType := jsonCastTypes[rand.Intn(len(jsonCastTypes))]

	idx := NewJSONPathIndex(indexType, castType, jsonPath).WithIndexName(indexName)
	assert.Equal(t, indexType, idx.IndexType())
	assert.Equal(t, indexName, idx.Name())

	params := idx.Params()
	assert.Equal(t, castType, params[common.JSONCastTypeKey])
	assert.Equal(t, jsonPath, params[common.JSONPathKey])
}



---
File: /index/json.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

import (
	"github.com/milvus-io/milvus/pkg/v2/common"
)

var _ Index = &JSONPathIndex{}

// JSONPathIndex is the pre-defined index model for json path scalar index.
type JSONPathIndex struct {
	scalarIndex
	jsonCastType string
	jsonPath     string
}

// WithIndexName setup the index name of JsonPathIndex.
func (idx *JSONPathIndex) WithIndexName(name string) *JSONPathIndex {
	idx.name = name
	return idx
}

// Params implements Index interface
// returns the create index related parameters.
func (idx *JSONPathIndex) Params() map[string]string {
	return map[string]string{
		IndexTypeKey:           string(idx.indexType),
		common.JSONCastTypeKey: idx.jsonCastType,
		common.JSONPathKey:     idx.jsonPath,
	}
}

// NewJSONPathIndex creates a `JsonPathIndex` with provided parameters.
func NewJSONPathIndex(indexType IndexType, jsonCastType string, jsonPath string) *JSONPathIndex {
	return &JSONPathIndex{
		scalarIndex: scalarIndex{
			indexType: indexType,
		},
		jsonCastType: jsonCastType,
		jsonPath:     jsonPath,
	}
}



---
File: /index/scalar_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/suite"
)

type ScalarIndexSuite struct {
	suite.Suite
}

func (s *ScalarIndexSuite) TestConstructors() {
	type testCase struct {
		tag             string
		input           Index
		expectIndexType IndexType
	}

	testcases := []testCase{
		{tag: "Trie", input: NewTrieIndex(), expectIndexType: Trie},
		{tag: "Sorted", input: NewSortedIndex(), expectIndexType: Sorted},
		{tag: "Inverted", input: NewInvertedIndex(), expectIndexType: Inverted},
		{tag: "Bitmap", input: NewBitmapIndex(), expectIndexType: BITMAP},
	}

	for _, tc := range testcases {
		s.Run(fmt.Sprintf("%s_indextype", tc.tag), func() {
			s.Equal(tc.expectIndexType, tc.input.IndexType())
		})
	}

	for _, tc := range testcases {
		s.Run(fmt.Sprintf("%s_params", tc.tag), func() {
			params := tc.input.Params()
			itv, ok := params[IndexTypeKey]
			if s.True(ok) {
				s.EqualValues(tc.expectIndexType, itv)
			}
		})
	}
}

func TestScalarIndexes(t *testing.T) {
	suite.Run(t, new(ScalarIndexSuite))
}



---
File: /index/scalar.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

type scalarIndex struct {
	name      string
	indexType IndexType
}

func (idx scalarIndex) Name() string {
	return idx.name
}

func (idx scalarIndex) IndexType() IndexType {
	return idx.indexType
}

func (idx scalarIndex) Params() map[string]string {
	return map[string]string{
		IndexTypeKey: string(idx.indexType),
	}
}

var _ Index = scalarIndex{}

func NewTrieIndex() Index {
	return scalarIndex{
		indexType: Trie,
	}
}

func NewInvertedIndex() Index {
	return scalarIndex{
		indexType: Inverted,
	}
}

func NewSortedIndex() Index {
	return scalarIndex{
		indexType: Sorted,
	}
}

func NewBitmapIndex() Index {
	return scalarIndex{
		indexType: BITMAP,
	}
}



---
File: /index/scann.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package index

import "strconv"

const (
	scannNlistKey       = `nlist`
	scannWithRawDataKey = `with_raw_data`
	scannNProbeKey      = `nprobe`
	scannReorderKKey    = `reorder_k`
)

type scannIndex struct {
	baseIndex

	nlist       int
	withRawData bool
}

func (idx scannIndex) Params() map[string]string {
	return map[string]string{
		MetricTypeKey:       string(idx.metricType),
		IndexTypeKey:        string(SCANN),
		scannNlistKey:       strconv.Itoa(idx.nlist),
		scannWithRawDataKey: strconv.FormatBool(idx.withRawData),
	}
}

func NewSCANNIndex(metricType MetricType, nlist int, withRawData bool) Index {
	return scannIndex{
		baseIndex: baseIndex{
			metricType: metricType,
			indexType:  SCANN,
		},
		nlist:       nlist,
		withRawData: withRawData,
	}
}

type scannAnnParam struct {
	baseAnnParam
	nprobe   int
	reorderK int
}

func NewSCANNAnnParam(nprobe int, reorderK int) scannAnnParam {
	return scannAnnParam{
		baseAnnParam: baseAnnParam{
			params: make(map[string]any),
		},
		nprobe:   nprobe,
		reorderK: reorderK,
	}
}

func (ap scannAnnParam) Params() map[string]any {
	result := ap.baseAnnParam.params
	result[scannNProbeKey] = ap.nprobe
	result[scannReorderKKey] = ap.reorderK
	return result
}



---
File: /index/sparse.go
---

package index

import (
	"fmt"
)

const (
	dropRatio = `drop_ratio_build`
)

var _ Index = sparseInvertedIndex{}

// IndexSparseInverted index type for SPARSE_INVERTED_INDEX
type sparseInvertedIndex struct {
	baseIndex
	dropRatio float64
}

func (idx sparseInvertedIndex) Params() map[string]string {
	return map[string]string{
		MetricTypeKey: string(idx.metricType),
		IndexTypeKey:  string(SparseInverted),
		dropRatio:     fmt.Sprintf("%v", idx.dropRatio),
	}
}

func NewSparseInvertedIndex(metricType MetricType, dropRatio float64) Index {
	return sparseInvertedIndex{
		baseIndex: baseIndex{
			metricType: metricType,
			indexType:  SparseInverted,
		},

		dropRatio: dropRatio,
	}
}

var _ Index = sparseWANDIndex{}

type sparseWANDIndex struct {
	baseIndex
	dropRatio float64
}

func (idx sparseWANDIndex) Params() map[string]string {
	return map[string]string{
		MetricTypeKey: string(idx.metricType),
		IndexTypeKey:  string(SparseWAND),
		dropRatio:     fmt.Sprintf("%v", idx.dropRatio),
	}
}

// IndexSparseWAND index type for SPARSE_WAND, weak-and
func NewSparseWANDIndex(metricType MetricType, dropRatio float64) Index {
	return sparseWANDIndex{
		baseIndex: baseIndex{
			metricType: metricType,
			indexType:  SparseWAND,
		},

		dropRatio: dropRatio,
	}
}

type sparseAnnParam struct {
	baseAnnParam
}

func NewSparseAnnParam() sparseAnnParam {
	return sparseAnnParam{
		baseAnnParam: baseAnnParam{
			params: make(map[string]any),
		},
	}
}

func (b sparseAnnParam) WithDropRatio(dropRatio float64) {
	b.WithExtraParam("drop_ratio_search", dropRatio)
}



---
File: /milvusclient/admin_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"fmt"
	"math/rand"
	"testing"

	"github.com/samber/lo"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type AdminSuite struct {
	MockSuiteBase
}

func (s *AdminSuite) TestGetServerVersion() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		version := fmt.Sprintf("v%s", s.randString(6))

		s.mock.EXPECT().GetVersion(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, gvr *milvuspb.GetVersionRequest) (*milvuspb.GetVersionResponse, error) {
			return &milvuspb.GetVersionResponse{
				Status:  merr.Success(),
				Version: version,
			}, nil
		}).Once()

		v, err := s.client.GetServerVersion(ctx, NewGetServerVersionOption())
		s.NoError(err)
		s.Equal(version, v)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().GetVersion(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.GetServerVersion(ctx, NewGetServerVersionOption())
		s.Error(err)
	})
}

func (s *AdminSuite) TestGetPersistentSegmentInfo() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		segments := []*entity.Segment{
			{ID: rand.Int63(), CollectionID: rand.Int63(), ParititionID: rand.Int63(), NumRows: rand.Int63(), State: commonpb.SegmentState_Flushed},
			{ID: rand.Int63(), CollectionID: rand.Int63(), ParititionID: rand.Int63(), NumRows: rand.Int63(), State: commonpb.SegmentState_Flushed},
		}

		s.mock.EXPECT().GetPersistentSegmentInfo(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, gpsi *milvuspb.GetPersistentSegmentInfoRequest) (*milvuspb.GetPersistentSegmentInfoResponse, error) {
			return &milvuspb.GetPersistentSegmentInfoResponse{
				Status: merr.Success(),
				Infos: lo.Map(segments, func(segment *entity.Segment, _ int) *milvuspb.PersistentSegmentInfo {
					return &milvuspb.PersistentSegmentInfo{
						SegmentID:    segment.ID,
						CollectionID: segment.CollectionID,
						PartitionID:  segment.ParititionID,
						NumRows:      segment.NumRows,
						State:        segment.State,
					}
				}),
			}, nil
		}).Once()

		segments, err := s.client.GetPersistentSegmentInfo(ctx, NewGetPersistentSegmentInfoOption(collectionName))
		s.NoError(err)
		s.Equal(segments, segments)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().GetPersistentSegmentInfo(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.GetPersistentSegmentInfo(ctx, &getPersistentSegmentInfoOption{collectionName: "coll"})
		s.Error(err)
	})
}

func (s *AdminSuite) TestBackupRBAC() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		s.mock.EXPECT().BackupRBAC(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, brr *milvuspb.BackupRBACMetaRequest) (*milvuspb.BackupRBACMetaResponse, error) {
			return &milvuspb.BackupRBACMetaResponse{
				Status: merr.Success(),
				RBACMeta: &milvuspb.RBACMeta{
					Users: []*milvuspb.UserInfo{
						{
							User:     "user1",
							Password: "passwd",
							Roles: []*milvuspb.RoleEntity{
								{Name: "role1"},
							},
						},
					},
					Roles: []*milvuspb.RoleEntity{
						{Name: "role1"},
					},
					Grants: []*milvuspb.GrantEntity{
						{
							Object: &milvuspb.ObjectEntity{
								Name: "testObject",
							},
							ObjectName: "testObjectName",
							Role: &milvuspb.RoleEntity{
								Name: "testRole",
							},
							Grantor: &milvuspb.GrantorEntity{
								User: &milvuspb.UserEntity{
									Name: "grantorUser",
								},
								Privilege: &milvuspb.PrivilegeEntity{
									Name: "testPrivilege",
								},
							},
							DbName: "testDB",
						},
					},
					PrivilegeGroups: []*milvuspb.PrivilegeGroupInfo{
						{
							GroupName: "testGroup",
							Privileges: []*milvuspb.PrivilegeEntity{
								{Name: "testPrivilege"},
							},
						},
					},
				},
			}, nil
		}).Once()

		meta, err := s.client.BackupRBAC(ctx, NewBackupRBACOption())
		s.NoError(err)
		s.Len(meta.Users, 1)
		s.Len(meta.Roles, 1)
		s.Len(meta.RoleGrants, 1)
		s.Len(meta.PrivilegeGroups, 1)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().BackupRBAC(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.BackupRBAC(ctx, NewBackupRBACOption())
		s.Error(err)
	})
}

func (s *AdminSuite) TestRestoreRBAC() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		meta := &entity.RBACMeta{
			Users: []*entity.UserInfo{
				{
					UserDescription: entity.UserDescription{
						Name:  "user1",
						Roles: []string{"role1"},
					},
					Password: "passwd",
				},
			},
			Roles: []*entity.Role{
				{RoleName: "role1"},
			},
			RoleGrants: []*entity.RoleGrants{
				{
					Object:        "testObject",
					ObjectName:    "testObjectName",
					RoleName:      "testRole",
					GrantorName:   "grantorUser",
					PrivilegeName: "testPrivilege",
					DbName:        "testDB",
				},
			},
			PrivilegeGroups: []*entity.PrivilegeGroup{
				{
					GroupName:  "testGroup",
					Privileges: []string{"testPrivilege"},
				},
			},
		}

		s.mock.EXPECT().RestoreRBAC(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, rrr *milvuspb.RestoreRBACMetaRequest) (*commonpb.Status, error) {
			return merr.Success(), nil
		}).Once()

		err := s.client.RestoreRBAC(ctx, NewRestoreRBACOption(meta))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().RestoreRBAC(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.RestoreRBAC(ctx, NewRestoreRBACOption(&entity.RBACMeta{}))
		s.Error(err)
	})
}

func TestAdminAPIs(t *testing.T) {
	suite.Run(t, new(AdminSuite))
}



---
File: /milvusclient/admin.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"

	"github.com/samber/lo"
	"google.golang.org/grpc"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

// GetServerVersionOption is the interface for GetServerVersion request.
type GetServerVersionOption interface {
	Request() *milvuspb.GetVersionRequest
}

type getServerVersionOption struct{}

func (opt *getServerVersionOption) Request() *milvuspb.GetVersionRequest {
	return &milvuspb.GetVersionRequest{}
}

func NewGetServerVersionOption() *getServerVersionOption {
	return &getServerVersionOption{}
}

// GetServerVersion returns connect Milvus instance version.
func (c *Client) GetServerVersion(ctx context.Context, option GetServerVersionOption, callOptions ...grpc.CallOption) (string, error) {
	req := option.Request()

	var version string

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.GetVersion(ctx, req, callOptions...)
		version = resp.GetVersion()
		return merr.CheckRPCCall(resp, err)
	})
	return version, err
}

type GetPersistentSegmentInfoOption interface {
	Request() *milvuspb.GetPersistentSegmentInfoRequest
}

type getPersistentSegmentInfoOption struct {
	collectionName string
}

func (opt *getPersistentSegmentInfoOption) Request() *milvuspb.GetPersistentSegmentInfoRequest {
	return &milvuspb.GetPersistentSegmentInfoRequest{
		CollectionName: opt.collectionName,
	}
}

func NewGetPersistentSegmentInfoOption(collectionName string) GetPersistentSegmentInfoOption {
	return &getPersistentSegmentInfoOption{
		collectionName: collectionName,
	}
}

func (c *Client) GetPersistentSegmentInfo(ctx context.Context, option GetPersistentSegmentInfoOption) ([]*entity.Segment, error) {
	req := option.Request()

	var segments []*entity.Segment

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.GetPersistentSegmentInfo(ctx, req)
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}

		segments = lo.Map(resp.GetInfos(), func(info *milvuspb.PersistentSegmentInfo, _ int) *entity.Segment {
			return &entity.Segment{
				ID:           info.GetSegmentID(),
				CollectionID: info.GetCollectionID(),
				ParititionID: info.GetPartitionID(),
				NumRows:      info.GetNumRows(),
				State:        info.GetState(),
			}
		})
		return nil
	})

	return segments, err
}

type BackupRBACOption interface {
	Request() *milvuspb.BackupRBACMetaRequest
}

type backupRBACOption struct{}

func (opt *backupRBACOption) Request() *milvuspb.BackupRBACMetaRequest {
	return &milvuspb.BackupRBACMetaRequest{}
}

func NewBackupRBACOption() BackupRBACOption {
	return &backupRBACOption{}
}

func (c *Client) BackupRBAC(ctx context.Context, option BackupRBACOption, callOptions ...grpc.CallOption) (*entity.RBACMeta, error) {
	req := option.Request()

	var meta *entity.RBACMeta

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.BackupRBAC(ctx, req, callOptions...)
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}

		rbacMeta := resp.GetRBACMeta()

		meta = &entity.RBACMeta{
			Users: lo.Map(rbacMeta.GetUsers(), func(user *milvuspb.UserInfo, _ int) *entity.UserInfo {
				return &entity.UserInfo{
					UserDescription: entity.UserDescription{
						Name:  user.GetUser(),
						Roles: lo.Map(user.GetRoles(), func(role *milvuspb.RoleEntity, _ int) string { return role.GetName() }),
					},
					Password: user.GetPassword(),
				}
			}),
			Roles: lo.Map(rbacMeta.GetRoles(), func(role *milvuspb.RoleEntity, _ int) *entity.Role {
				return &entity.Role{
					RoleName: role.GetName(),
				}
			}),
			RoleGrants: lo.Map(rbacMeta.GetGrants(), func(grant *milvuspb.GrantEntity, _ int) *entity.RoleGrants {
				return &entity.RoleGrants{
					Object:        grant.GetObject().GetName(),
					ObjectName:    grant.GetObjectName(),
					RoleName:      grant.GetRole().GetName(),
					GrantorName:   grant.GetGrantor().GetUser().GetName(),
					PrivilegeName: grant.GetGrantor().GetPrivilege().GetName(),
					DbName:        grant.GetDbName(),
				}
			}),
			PrivilegeGroups: lo.Map(rbacMeta.GetPrivilegeGroups(), func(group *milvuspb.PrivilegeGroupInfo, _ int) *entity.PrivilegeGroup {
				return &entity.PrivilegeGroup{
					GroupName:  group.GetGroupName(),
					Privileges: lo.Map(group.GetPrivileges(), func(privilege *milvuspb.PrivilegeEntity, _ int) string { return privilege.GetName() }),
				}
			}),
		}

		return nil
	})
	return meta, err
}

type RestoreRBACOption interface {
	Request() *milvuspb.RestoreRBACMetaRequest
}

type restoreRBACOption struct {
	meta *entity.RBACMeta
}

func (opt *restoreRBACOption) Request() *milvuspb.RestoreRBACMetaRequest {
	return &milvuspb.RestoreRBACMetaRequest{
		RBACMeta: &milvuspb.RBACMeta{
			Users: lo.Map(opt.meta.Users, func(user *entity.UserInfo, _ int) *milvuspb.UserInfo {
				return &milvuspb.UserInfo{
					User:     user.Name,
					Roles:    lo.Map(user.Roles, func(role string, _ int) *milvuspb.RoleEntity { return &milvuspb.RoleEntity{Name: role} }),
					Password: user.Password,
				}
			}),
			Roles: lo.Map(opt.meta.Roles, func(role *entity.Role, _ int) *milvuspb.RoleEntity {
				return &milvuspb.RoleEntity{Name: role.RoleName}
			}),
			Grants: lo.Map(opt.meta.RoleGrants, func(grant *entity.RoleGrants, _ int) *milvuspb.GrantEntity {
				return &milvuspb.GrantEntity{
					Object:     &milvuspb.ObjectEntity{Name: grant.Object},
					ObjectName: grant.ObjectName,
					Role:       &milvuspb.RoleEntity{Name: grant.RoleName},
					Grantor: &milvuspb.GrantorEntity{
						User: &milvuspb.UserEntity{
							Name: grant.GrantorName,
						},
						Privilege: &milvuspb.PrivilegeEntity{
							Name: grant.PrivilegeName,
						},
					},
					DbName: grant.DbName,
				}
			}),
			PrivilegeGroups: lo.Map(opt.meta.PrivilegeGroups, func(group *entity.PrivilegeGroup, _ int) *milvuspb.PrivilegeGroupInfo {
				return &milvuspb.PrivilegeGroupInfo{
					GroupName: group.GroupName,
					Privileges: lo.Map(group.Privileges, func(privilege string, _ int) *milvuspb.PrivilegeEntity {
						return &milvuspb.PrivilegeEntity{Name: privilege}
					}),
				}
			}),
		},
	}
}

func NewRestoreRBACOption(meta *entity.RBACMeta) RestoreRBACOption {
	return &restoreRBACOption{meta: meta}
}

func (c *Client) RestoreRBAC(ctx context.Context, option RestoreRBACOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.RestoreRBAC(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}



---
File: /milvusclient/alias_example_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// nolint
package milvusclient_test

import (
	"context"
	"fmt"

	"github.com/milvus-io/milvus/client/v2/milvusclient"
)

func ExampleClient_CreateAlias() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	err = cli.CreateAlias(ctx, milvusclient.NewCreateAliasOption("customized_setup_2", "bob"))
	if err != nil {
		// handle error
	}

	err = cli.CreateAlias(ctx, milvusclient.NewCreateAliasOption("customized_setup_2", "alice"))
	if err != nil {
		// handle error
	}
}

func ExampleClient_ListAliases() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	aliases, err := cli.ListAliases(ctx, milvusclient.NewListAliasesOption("customized_setup_2"))
	if err != nil {
		// handle error
	}
	fmt.Println(aliases)
}

func ExampleClient_DescribeAlias() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	alias, err := cli.DescribeAlias(ctx, milvusclient.NewDescribeAliasOption("bob"))
	if err != nil {
		// handle error
	}
	fmt.Println(alias)
}

func ExampleClient_AlterAlias() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	err = cli.AlterAlias(ctx, milvusclient.NewAlterAliasOption("alice", "customized_setup_1"))
	if err != nil {
		// handle error
	}

	aliases, err := cli.ListAliases(ctx, milvusclient.NewListAliasesOption("customized_setup_1"))
	if err != nil {
		// handle error
	}
	fmt.Println(aliases)

	aliases, err = cli.ListAliases(ctx, milvusclient.NewListAliasesOption("customized_setup_2"))
	if err != nil {
		// handle error
	}
	fmt.Println(aliases)
}

func ExampleClient_DropAlias() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	err = cli.DropAlias(ctx, milvusclient.NewDropAliasOption("alice"))
	if err != nil {
		// handle error
	}
}



---
File: /milvusclient/alias_options.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import "github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"

// CreateCollectionOption is the interface builds CreateAliasRequest.
type CreateAliasOption interface {
	Request() *milvuspb.CreateAliasRequest
}

type createAliasOption struct {
	collectionName string
	alias          string
}

func (opt *createAliasOption) Request() *milvuspb.CreateAliasRequest {
	return &milvuspb.CreateAliasRequest{
		CollectionName: opt.collectionName,
		Alias:          opt.alias,
	}
}

func NewCreateAliasOption(collectionName, alias string) *createAliasOption {
	return &createAliasOption{
		collectionName: collectionName,
		alias:          alias,
	}
}

// DescribeAliasOption is the interface builds DescribeAliasOption.
type DescribeAliasOption interface {
	Request() *milvuspb.DescribeAliasRequest
}

type describeAliasOption struct {
	aliasName string
}

func (opt *describeAliasOption) Request() *milvuspb.DescribeAliasRequest {
	return &milvuspb.DescribeAliasRequest{
		Alias: opt.aliasName,
	}
}

func NewDescribeAliasOption(alias string) *describeAliasOption {
	return &describeAliasOption{
		aliasName: alias,
	}
}

// DropAliasOption is the interface builds DropAliasRequest.
type DropAliasOption interface {
	Request() *milvuspb.DropAliasRequest
}

type dropAliasOption struct {
	aliasName string
}

func (opt *dropAliasOption) Request() *milvuspb.DropAliasRequest {
	return &milvuspb.DropAliasRequest{
		Alias: opt.aliasName,
	}
}

func NewDropAliasOption(alias string) *dropAliasOption {
	return &dropAliasOption{
		aliasName: alias,
	}
}

// AlterAliasOption is the interface builds AlterAliasRequest.
type AlterAliasOption interface {
	Request() *milvuspb.AlterAliasRequest
}

type alterAliasOption struct {
	aliasName      string
	collectionName string
}

func (opt *alterAliasOption) Request() *milvuspb.AlterAliasRequest {
	return &milvuspb.AlterAliasRequest{
		Alias:          opt.aliasName,
		CollectionName: opt.collectionName,
	}
}

func NewAlterAliasOption(alias, collectionName string) *alterAliasOption {
	return &alterAliasOption{
		aliasName:      alias,
		collectionName: collectionName,
	}
}

// ListAliasesOption is the interface builds ListAliasesRequest.
type ListAliasesOption interface {
	Request() *milvuspb.ListAliasesRequest
}

type listAliasesOption struct {
	collectionName string
}

func (opt *listAliasesOption) Request() *milvuspb.ListAliasesRequest {
	return &milvuspb.ListAliasesRequest{
		CollectionName: opt.collectionName,
	}
}

func NewListAliasesOption(collectionName string) *listAliasesOption {
	return &listAliasesOption{
		collectionName: collectionName,
	}
}



---
File: /milvusclient/alias_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"fmt"
	"testing"

	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type AliasSuite struct {
	MockSuiteBase
}

func (s *AliasSuite) TestCreateAlias() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	aliasName := fmt.Sprintf("test_alias_%s", s.randString(6))
	collectionName := fmt.Sprintf("test_collection_%s", s.randString(6))

	s.Run("success", func() {
		s.mock.EXPECT().CreateAlias(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, car *milvuspb.CreateAliasRequest) (*commonpb.Status, error) {
			s.Equal(aliasName, car.GetAlias())
			s.Equal(collectionName, car.GetCollectionName())
			return merr.Success(), nil
		}).Once()

		err := s.client.CreateAlias(ctx, NewCreateAliasOption(collectionName, aliasName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().CreateAlias(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.CreateAlias(ctx, NewCreateAliasOption(collectionName, aliasName))
		s.Error(err)
	})
}

func (s *AliasSuite) TestDropAlias() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	aliasName := fmt.Sprintf("test_alias_%s", s.randString(6))

	s.Run("success", func() {
		s.mock.EXPECT().DropAlias(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, dar *milvuspb.DropAliasRequest) (*commonpb.Status, error) {
			s.Equal(aliasName, dar.GetAlias())
			return merr.Success(), nil
		}).Once()

		err := s.client.DropAlias(ctx, NewDropAliasOption(aliasName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().DropAlias(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.DropAlias(ctx, NewDropAliasOption(aliasName))
		s.Error(err)
	})
}

func (s *AliasSuite) TestDescribeAlias() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	aliasName := fmt.Sprintf("test_alias_%s", s.randString(6))
	collectionName := fmt.Sprintf("test_collection_%s", s.randString(6))

	s.Run("success", func() {
		s.mock.EXPECT().DescribeAlias(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, car *milvuspb.DescribeAliasRequest) (*milvuspb.DescribeAliasResponse, error) {
			s.Equal(aliasName, car.GetAlias())
			return &milvuspb.DescribeAliasResponse{
				Alias:      aliasName,
				Collection: collectionName,
			}, nil
		}).Once()

		alias, err := s.client.DescribeAlias(ctx, NewDescribeAliasOption(aliasName))
		s.NoError(err)
		s.Equal(aliasName, alias.Alias)
		s.Equal(collectionName, alias.CollectionName)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().DescribeAlias(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.DescribeAlias(ctx, NewDescribeAliasOption(aliasName))
		s.Error(err)
	})
}

func (s *AliasSuite) TestAlterAlias() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	aliasName := fmt.Sprintf("test_alias_%s", s.randString(6))
	collectionName := fmt.Sprintf("test_collection_%s", s.randString(6))

	s.Run("success", func() {
		s.mock.EXPECT().AlterAlias(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, dar *milvuspb.AlterAliasRequest) (*commonpb.Status, error) {
			s.Equal(aliasName, dar.GetAlias())
			s.Equal(collectionName, dar.GetCollectionName())
			return merr.Success(), nil
		}).Once()

		err := s.client.AlterAlias(ctx, NewAlterAliasOption(aliasName, collectionName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().AlterAlias(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.AlterAlias(ctx, NewAlterAliasOption(aliasName, collectionName))
		s.Error(err)
	})
}

func (s *AliasSuite) TestListAliases() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collectionName := fmt.Sprintf("test_collection_%s", s.randString(6))

	s.Run("success", func() {
		s.mock.EXPECT().ListAliases(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, lar *milvuspb.ListAliasesRequest) (*milvuspb.ListAliasesResponse, error) {
			s.Equal(collectionName, lar.GetCollectionName())
			return &milvuspb.ListAliasesResponse{
				Aliases: []string{"test1", "test2", "test3"},
			}, nil
		}).Once()

		names, err := s.client.ListAliases(ctx, NewListAliasesOption(collectionName))
		s.NoError(err)
		s.ElementsMatch([]string{"test1", "test2", "test3"}, names)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().ListAliases(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.ListAliases(ctx, NewListAliasesOption(collectionName))
		s.Error(err)
	})
}

func TestAlias(t *testing.T) {
	suite.Run(t, new(AliasSuite))
}



---
File: /milvusclient/alias.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"

	"google.golang.org/grpc"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

func (c *Client) CreateAlias(ctx context.Context, option CreateAliasOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.CreateAlias(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) DescribeAlias(ctx context.Context, option DescribeAliasOption, callOptions ...grpc.CallOption) (*entity.Alias, error) {
	req := option.Request()

	var alias *entity.Alias
	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DescribeAlias(ctx, req, callOptions...)
		if err := merr.CheckRPCCall(resp, err); err != nil {
			return err
		}
		alias = &entity.Alias{
			DbName:         resp.GetDbName(),
			Alias:          resp.GetAlias(),
			CollectionName: resp.GetCollection(),
		}

		return nil
	})

	return alias, err
}

func (c *Client) DropAlias(ctx context.Context, option DropAliasOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DropAlias(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) AlterAlias(ctx context.Context, option AlterAliasOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.AlterAlias(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) ListAliases(ctx context.Context, option ListAliasesOption, callOptions ...grpc.CallOption) ([]string, error) {
	req := option.Request()

	var aliases []string
	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.ListAliases(ctx, req, callOptions...)
		if err := merr.CheckRPCCall(resp, err); err != nil {
			return err
		}

		aliases = resp.GetAliases()
		return nil
	})

	return aliases, err
}



---
File: /milvusclient/client_config.go
---

package milvusclient

import (
	"context"
	"fmt"
	"math"
	"net/url"
	"regexp"
	"strings"
	"time"

	"github.com/cockroachdb/errors"
	"google.golang.org/grpc"
	"google.golang.org/grpc/backoff"
	"google.golang.org/grpc/keepalive"
)

const (
	disableDatabase uint64 = 1 << iota
	disableJSON
	disableDynamicSchema
	disableParitionKey
)

var regexValidScheme = regexp.MustCompile(`^https?:\/\/`)

// DefaultGrpcOpts is GRPC options for milvus client.
var DefaultGrpcOpts = []grpc.DialOption{
	grpc.WithBlock(),
	grpc.WithKeepaliveParams(keepalive.ClientParameters{
		Time:                5 * time.Second,
		Timeout:             10 * time.Second,
		PermitWithoutStream: true,
	}),
	grpc.WithConnectParams(grpc.ConnectParams{
		Backoff: backoff.Config{
			BaseDelay:  100 * time.Millisecond,
			Multiplier: 1.6,
			Jitter:     0.2,
			MaxDelay:   3 * time.Second,
		},
		MinConnectTimeout: 3 * time.Second,
	}),
	grpc.WithDefaultCallOptions(
		grpc.MaxCallRecvMsgSize(math.MaxInt32), // math.MaxInt32 = 2147483647, 2GB - 1
	),
}

// ClientConfig for milvus client.
type ClientConfig struct {
	Address  string // Remote address, "localhost:19530".
	Username string // Username for auth.
	Password string // Password for auth.
	DBName   string // DBName for this client.

	EnableTLSAuth bool   // Enable TLS Auth for transport security.
	APIKey        string // API key

	DialOptions []grpc.DialOption // Dial options for GRPC.

	RetryRateLimit *RetryRateLimitOption // option for retry on rate limit inteceptor

	DisableConn bool

	ServerVersion string // ServerVersion
	parsedAddress *url.URL
	flags         uint64 // internal flags
}

type RetryRateLimitOption struct {
	MaxRetry   uint
	MaxBackoff time.Duration
}

func (cfg *ClientConfig) parse() error {
	// Prepend default fake tcp:// scheme for remote address.
	address := cfg.Address
	if !regexValidScheme.MatchString(address) {
		address = fmt.Sprintf("tcp://%s", address)
	}

	remoteURL, err := url.Parse(address)
	if err != nil {
		return errors.Wrap(err, "milvus address parse fail")
	}
	// Remote Host should never be empty.
	if remoteURL.Host == "" {
		return errors.New("empty remote host of milvus address")
	}
	// Use DBName in remote url path.
	if cfg.DBName == "" {
		cfg.DBName = strings.TrimLeft(remoteURL.Path, "/")
	}
	// Always enable tls auth for https remote url.
	if remoteURL.Scheme == "https" {
		cfg.EnableTLSAuth = true
	}
	if remoteURL.Port() == "" && cfg.EnableTLSAuth {
		remoteURL.Host += ":443"
	}
	cfg.parsedAddress = remoteURL
	return nil
}

// Get parsed remote milvus address, should be called after parse was called.
func (c *ClientConfig) getParsedAddress() string {
	return c.parsedAddress.Host
}

// useDatabase change the inner db name.
func (c *ClientConfig) useDatabase(dbName string) {
	c.DBName = dbName
}

func (c *ClientConfig) setServerInfo(serverInfo string) {
	c.ServerVersion = serverInfo
}

func (c *ClientConfig) getRetryOnRateLimitInterceptor() grpc.UnaryClientInterceptor {
	if c.RetryRateLimit == nil {
		c.RetryRateLimit = c.defaultRetryRateLimitOption()
	}

	return RetryOnRateLimitInterceptor(c.RetryRateLimit.MaxRetry, c.RetryRateLimit.MaxBackoff, func(ctx context.Context, attempt uint) time.Duration {
		return 10 * time.Millisecond * time.Duration(math.Pow(3, float64(attempt)))
	})
}

func (c *ClientConfig) defaultRetryRateLimitOption() *RetryRateLimitOption {
	return &RetryRateLimitOption{
		MaxRetry:   75,
		MaxBackoff: 3 * time.Second,
	}
}

// addFlags set internal flags
func (c *ClientConfig) addFlags(flags uint64) {
	c.flags |= flags
}

// hasFlags check flags is set
func (c *ClientConfig) hasFlags(flags uint64) bool {
	return (c.flags & flags) > 0
}

func (c *ClientConfig) resetFlags(flags uint64) {
	c.flags &= ^flags
}



---
File: /milvusclient/client_suite_test.go
---

package milvusclient

import (
	"context"
	"math/rand"
	"net"
	"strings"

	mock "github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/test/bufconn"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

const (
	bufSize = 1024 * 1024
)

type MockSuiteBase struct {
	suite.Suite

	lis  *bufconn.Listener
	svr  *grpc.Server
	mock *MilvusServiceServer

	client *Client
}

func (s *MockSuiteBase) SetupSuite() {
	s.lis = bufconn.Listen(bufSize)
	s.svr = grpc.NewServer()

	s.mock = &MilvusServiceServer{}

	milvuspb.RegisterMilvusServiceServer(s.svr, s.mock)

	go func() {
		s.T().Log("start mock server")
		if err := s.svr.Serve(s.lis); err != nil {
			s.Fail("failed to start mock server", err.Error())
		}
	}()
	s.setupConnect()
}

func (s *MockSuiteBase) TearDownSuite() {
	s.svr.Stop()
	s.lis.Close()
}

func (s *MockSuiteBase) mockDialer(context.Context, string) (net.Conn, error) {
	return s.lis.Dial()
}

func (s *MockSuiteBase) SetupTest() {
	c, err := New(context.Background(), &ClientConfig{
		Address: "bufnet",
		DialOptions: []grpc.DialOption{
			grpc.WithBlock(),
			grpc.WithTransportCredentials(insecure.NewCredentials()),
			grpc.WithContextDialer(s.mockDialer),
		},
	})
	s.Require().NoError(err)
	s.setupConnect()

	s.client = c
}

func (s *MockSuiteBase) TearDownTest() {
	s.client.Close(context.Background())
	s.client = nil
}

func (s *MockSuiteBase) resetMock() {
	// MetaCache.reset()
	if s.mock != nil {
		s.mock.Calls = nil
		s.mock.ExpectedCalls = nil
		s.setupConnect()
	}
}

func (s *MockSuiteBase) setupConnect() {
	s.mock.EXPECT().Connect(mock.Anything, mock.AnythingOfType("*milvuspb.ConnectRequest")).
		Return(&milvuspb.ConnectResponse{
			Status:     &commonpb.Status{},
			Identifier: 1,
		}, nil).Maybe()
}

func (s *MockSuiteBase) setupCache(collName string, schema *entity.Schema) {
	s.client.collCache.collections.Insert(collName, &entity.Collection{
		Name:   collName,
		Schema: schema,
	})
}

func (s *MockSuiteBase) setupHasCollection(collNames ...string) {
	s.mock.EXPECT().HasCollection(mock.Anything, mock.AnythingOfType("*milvuspb.HasCollectionRequest")).
		Call.Return(func(ctx context.Context, req *milvuspb.HasCollectionRequest) *milvuspb.BoolResponse {
		resp := &milvuspb.BoolResponse{Status: &commonpb.Status{}}
		for _, collName := range collNames {
			if req.GetCollectionName() == collName {
				resp.Value = true
				break
			}
		}
		return resp
	}, nil)
}

func (s *MockSuiteBase) setupHasCollectionError(errorCode commonpb.ErrorCode, err error) {
	s.mock.EXPECT().HasCollection(mock.Anything, mock.AnythingOfType("*milvuspb.HasCollectionRequest")).
		Return(&milvuspb.BoolResponse{
			Status: &commonpb.Status{ErrorCode: errorCode},
		}, err)
}

func (s *MockSuiteBase) setupHasPartition(collName string, partNames ...string) {
	s.mock.EXPECT().HasPartition(mock.Anything, mock.AnythingOfType("*milvuspb.HasPartitionRequest")).
		Call.Return(func(ctx context.Context, req *milvuspb.HasPartitionRequest) *milvuspb.BoolResponse {
		resp := &milvuspb.BoolResponse{Status: &commonpb.Status{}}
		if req.GetCollectionName() == collName {
			for _, partName := range partNames {
				if req.GetPartitionName() == partName {
					resp.Value = true
					break
				}
			}
		}
		return resp
	}, nil)
}

func (s *MockSuiteBase) setupHasPartitionError(errorCode commonpb.ErrorCode, err error) {
	s.mock.EXPECT().HasPartition(mock.Anything, mock.AnythingOfType("*milvuspb.HasPartitionRequest")).
		Return(&milvuspb.BoolResponse{
			Status: &commonpb.Status{ErrorCode: errorCode},
		}, err)
}

func (s *MockSuiteBase) setupDescribeCollection(_ string, schema *entity.Schema) {
	s.mock.EXPECT().DescribeCollection(mock.Anything, mock.AnythingOfType("*milvuspb.DescribeCollectionRequest")).
		Call.Return(func(ctx context.Context, req *milvuspb.DescribeCollectionRequest) *milvuspb.DescribeCollectionResponse {
		return &milvuspb.DescribeCollectionResponse{
			Status: &commonpb.Status{ErrorCode: commonpb.ErrorCode_Success},
			Schema: schema.ProtoMessage(),
		}
	}, nil)
}

func (s *MockSuiteBase) setupDescribeCollectionError(errorCode commonpb.ErrorCode, err error) {
	s.mock.EXPECT().DescribeCollection(mock.Anything, mock.AnythingOfType("*milvuspb.DescribeCollectionRequest")).
		Return(&milvuspb.DescribeCollectionResponse{
			Status: &commonpb.Status{ErrorCode: errorCode},
		}, err)
}

func (s *MockSuiteBase) getInt64FieldData(name string, data []int64) *schemapb.FieldData {
	return &schemapb.FieldData{
		Type:      schemapb.DataType_Int64,
		FieldName: name,
		Field: &schemapb.FieldData_Scalars{
			Scalars: &schemapb.ScalarField{
				Data: &schemapb.ScalarField_LongData{
					LongData: &schemapb.LongArray{
						Data: data,
					},
				},
			},
		},
	}
}

func (s *MockSuiteBase) getVarcharFieldData(name string, data []string) *schemapb.FieldData {
	return &schemapb.FieldData{
		Type:      schemapb.DataType_VarChar,
		FieldName: name,
		Field: &schemapb.FieldData_Scalars{
			Scalars: &schemapb.ScalarField{
				Data: &schemapb.ScalarField_StringData{
					StringData: &schemapb.StringArray{
						Data: data,
					},
				},
			},
		},
	}
}

func (s *MockSuiteBase) getJSONBytesFieldData(name string, data [][]byte, isDynamic bool) *schemapb.FieldData {
	return &schemapb.FieldData{
		Type:      schemapb.DataType_JSON,
		FieldName: name,
		Field: &schemapb.FieldData_Scalars{
			Scalars: &schemapb.ScalarField{
				Data: &schemapb.ScalarField_JsonData{
					JsonData: &schemapb.JSONArray{
						Data: data,
					},
				},
			},
		},
		IsDynamic: isDynamic,
	}
}

func (s *MockSuiteBase) getFloatVectorFieldData(name string, dim int64, data []float32) *schemapb.FieldData {
	return &schemapb.FieldData{
		Type:      schemapb.DataType_FloatVector,
		FieldName: name,
		Field: &schemapb.FieldData_Vectors{
			Vectors: &schemapb.VectorField{
				Dim: dim,
				Data: &schemapb.VectorField_FloatVector{
					FloatVector: &schemapb.FloatArray{
						Data: data,
					},
				},
			},
		},
	}
}

func (s *MockSuiteBase) getSuccessStatus() *commonpb.Status {
	return s.getStatus(commonpb.ErrorCode_Success, "")
}

func (s *MockSuiteBase) getStatus(code commonpb.ErrorCode, reason string) *commonpb.Status {
	return &commonpb.Status{
		ErrorCode: code,
		Reason:    reason,
	}
}

var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

func (s *MockSuiteBase) randString(l int) string {
	builder := strings.Builder{}
	for i := 0; i < l; i++ {
		builder.WriteRune(letters[rand.Intn(len(letters))])
	}
	return builder.String()
}



---
File: /milvusclient/client_test.go
---

package milvusclient

import (
	"context"
	"testing"

	"github.com/stretchr/testify/suite"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

type ClientSuite struct {
	MockSuiteBase
}

func (s *ClientSuite) TestNewClient() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("Use bufconn dailer, testing case", func() {
		c, err := New(ctx,
			&ClientConfig{
				Address: "bufnet",
				DialOptions: []grpc.DialOption{
					grpc.WithBlock(),
					grpc.WithTransportCredentials(insecure.NewCredentials()),
					grpc.WithContextDialer(s.mockDialer),
				},
			})
		s.NoError(err)
		s.NotNil(c)
	})

	s.Run("empty_addr", func() {
		_, err := New(ctx, &ClientConfig{})
		s.Error(err)
		s.T().Log(err)
	})
}

func TestClient(t *testing.T) {
	suite.Run(t, new(ClientSuite))
}



---
File: /milvusclient/client.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"crypto/tls"
	"fmt"
	"math"
	"os"
	"strconv"
	"sync"
	"time"

	"github.com/cockroachdb/errors"
	grpc_retry "github.com/grpc-ecosystem/go-grpc-middleware/retry"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/status"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/common"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/crypto"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type Client struct {
	conn    *grpc.ClientConn
	service milvuspb.MilvusServiceClient
	config  *ClientConfig

	// mutable status
	stateMut   sync.RWMutex
	currentDB  string
	identifier string // Identifier for this connection

	metadataHeaders map[string]string

	collCache *CollectionCache
}

func New(ctx context.Context, config *ClientConfig) (*Client, error) {
	if err := config.parse(); err != nil {
		return nil, err
	}

	c := &Client{
		config:    config,
		currentDB: config.DBName,
	}

	// Parse remote address.
	addr := c.config.getParsedAddress()

	// parse authentication parameters
	c.parseAuthentication()
	// Parse grpc options
	options := c.dialOptions()

	// Connect the grpc server.
	if err := c.connect(ctx, addr, options...); err != nil {
		return nil, err
	}

	c.collCache = NewCollectionCache(func(ctx context.Context, collName string) (*entity.Collection, error) {
		return c.DescribeCollection(ctx, NewDescribeCollectionOption(collName))
	})

	return c, nil
}

func (c *Client) dialOptions() []grpc.DialOption {
	var options []grpc.DialOption
	// Construct dial option.
	if c.config.EnableTLSAuth {
		options = append(options, grpc.WithTransportCredentials(credentials.NewTLS(&tls.Config{})))
	} else {
		options = append(options, grpc.WithTransportCredentials(insecure.NewCredentials()))
	}

	if c.config.DialOptions == nil {
		// Add default connection options.
		options = append(options, DefaultGrpcOpts...)
	} else {
		options = append(options, c.config.DialOptions...)
	}

	options = append(options,
		grpc.WithChainUnaryInterceptor(grpc_retry.UnaryClientInterceptor(
			grpc_retry.WithMax(6),
			grpc_retry.WithBackoff(func(attempt uint) time.Duration {
				return 60 * time.Millisecond * time.Duration(math.Pow(3, float64(attempt)))
			}),
			grpc_retry.WithCodes(codes.Unavailable, codes.ResourceExhausted)),

		// c.getRetryOnRateLimitInterceptor(),
		))

	options = append(options, grpc.WithChainUnaryInterceptor(
		c.MetadataUnaryInterceptor(),
	))

	return options
}

// parseAuthentication prepares authentication headers for grpc inteceptors based on the provided username, password or API key.
func (c *Client) parseAuthentication() {
	cfg := c.config
	c.metadataHeaders = make(map[string]string)
	if cfg.Username != "" || cfg.Password != "" {
		value := crypto.Base64Encode(fmt.Sprintf("%s:%s", cfg.Username, cfg.Password))
		c.metadataHeaders[authorizationHeader] = value
	}
	// API overwrites username & passwd
	if cfg.APIKey != "" {
		value := crypto.Base64Encode(cfg.APIKey)
		c.metadataHeaders[authorizationHeader] = value
	}
}

func (c *Client) Close(ctx context.Context) error {
	if c.conn == nil {
		return nil
	}
	err := c.conn.Close()
	if err != nil {
		return err
	}
	c.conn = nil
	c.service = nil
	return nil
}

func (c *Client) usingDatabase(dbName string) {
	c.stateMut.Lock()
	defer c.stateMut.Unlock()
	c.currentDB = dbName
}

func (c *Client) setIdentifier(identifier string) {
	c.stateMut.Lock()
	defer c.stateMut.Unlock()
	c.identifier = identifier
}

func (c *Client) connect(ctx context.Context, addr string, options ...grpc.DialOption) error {
	if addr == "" {
		return errors.New("address is empty")
	}
	conn, err := grpc.DialContext(ctx, addr, options...)
	if err != nil {
		return err
	}

	c.conn = conn
	c.service = milvuspb.NewMilvusServiceClient(c.conn)

	if !c.config.DisableConn {
		err = c.connectInternal(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func (c *Client) connectInternal(ctx context.Context) error {
	hostName, err := os.Hostname()
	if err != nil {
		return err
	}

	req := &milvuspb.ConnectRequest{
		ClientInfo: &commonpb.ClientInfo{
			SdkType:    "GoMilvusClient",
			SdkVersion: common.SDKVersion,
			LocalTime:  time.Now().String(),
			User:       c.config.Username,
			Host:       hostName,
		},
	}

	resp, err := c.service.Connect(ctx, req)
	if err != nil {
		status, ok := status.FromError(err)
		if ok {
			if status.Code() == codes.Unimplemented {
				// disable unsupported feature
				c.config.addFlags(
					disableDatabase |
						disableJSON |
						disableParitionKey |
						disableDynamicSchema)
				return nil
			}
		}
		return err
	}

	if !merr.Ok(resp.GetStatus()) {
		return merr.Error(resp.GetStatus())
	}

	c.config.setServerInfo(resp.GetServerInfo().GetBuildTags())
	c.setIdentifier(strconv.FormatInt(resp.GetIdentifier(), 10))
	if c.collCache != nil {
		c.collCache.Reset()
	}

	return nil
}

func (c *Client) callService(fn func(milvusService milvuspb.MilvusServiceClient) error) error {
	service := c.service
	if service == nil {
		return merr.WrapErrServiceNotReady("SDK", 0, "not connected")
	}

	return fn(c.service)
}



---
File: /milvusclient/collection_example_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// nolint
package milvusclient_test

import (
	"context"
	"fmt"
	"log"

	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/index"
	"github.com/milvus-io/milvus/client/v2/milvusclient"
	"github.com/milvus-io/milvus/pkg/v2/common"
)

const (
	milvusAddr = `127.0.0.1:19530`
)

func ExampleClient_CreateCollection_normal() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collectionName := `customized_setup_1`

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	indexOptions := []milvusclient.CreateIndexOption{
		milvusclient.NewCreateIndexOption(collectionName, "my_vector", index.NewAutoIndex(entity.COSINE)).WithIndexName("my_vector"),
		milvusclient.NewCreateIndexOption(collectionName, "my_id", index.NewSortedIndex()).WithIndexName("my_id"),
	}

	schema := entity.NewSchema().WithDynamicFieldEnabled(true).
		WithField(entity.NewField().WithName("my_id").WithIsAutoID(true).WithDataType(entity.FieldTypeInt64).WithIsPrimaryKey(true)).
		WithField(entity.NewField().WithName("my_vector").WithDataType(entity.FieldTypeFloatVector).WithDim(5)).
		WithField(entity.NewField().WithName("my_varchar").WithDataType(entity.FieldTypeVarChar).WithMaxLength(512))

	err = cli.CreateCollection(ctx, milvusclient.NewCreateCollectionOption(collectionName, schema).
		WithIndexOptions(indexOptions...),
	)
	if err != nil {
		// handle error
	}
}

func ExampleClient_CreateCollection_quick() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collectionName := `quick_setup`

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	err = cli.CreateCollection(ctx, milvusclient.SimpleCreateCollectionOptions(collectionName, 5))
	if err != nil {
		// handle error
	}
}

func ExampleClient_CreateCollection_shardNum() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collectionName := `customized_setup_3`

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	schema := entity.NewSchema().WithDynamicFieldEnabled(true).
		WithField(entity.NewField().WithName("my_id").WithIsAutoID(true).WithDataType(entity.FieldTypeInt64).WithIsPrimaryKey(true)).
		WithField(entity.NewField().WithName("my_vector").WithDataType(entity.FieldTypeFloatVector).WithDim(5)).
		WithField(entity.NewField().WithName("my_varchar").WithDataType(entity.FieldTypeVarChar).WithMaxLength(512))

	err = cli.CreateCollection(ctx, milvusclient.NewCreateCollectionOption(collectionName, schema).WithShardNum(1))
	if err != nil {
		// handle error
	}
}

func ExampleClient_CreateCollection_enableMmap() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collectionName := `customized_setup_4`

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	schema := entity.NewSchema().WithDynamicFieldEnabled(true).
		WithField(entity.NewField().WithName("my_id").WithIsAutoID(true).WithDataType(entity.FieldTypeInt64).WithIsPrimaryKey(true)).
		WithField(entity.NewField().WithName("my_vector").WithDataType(entity.FieldTypeFloatVector).WithDim(5)).
		WithField(entity.NewField().WithName("my_varchar").WithDataType(entity.FieldTypeVarChar).WithMaxLength(512))

	err = cli.CreateCollection(ctx, milvusclient.NewCreateCollectionOption(collectionName, schema).WithProperty(common.MmapEnabledKey, true))
	if err != nil {
		// handle error
	}
}

func ExampleClient_CreateCollection_ttl() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collectionName := `customized_setup_5`

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	schema := entity.NewSchema().WithDynamicFieldEnabled(true).
		WithField(entity.NewField().WithName("my_id").WithIsAutoID(true).WithDataType(entity.FieldTypeInt64).WithIsPrimaryKey(true)).
		WithField(entity.NewField().WithName("my_vector").WithDataType(entity.FieldTypeFloatVector).WithDim(5)).
		WithField(entity.NewField().WithName("my_varchar").WithDataType(entity.FieldTypeVarChar).WithMaxLength(512))

	err = cli.CreateCollection(ctx, milvusclient.NewCreateCollectionOption(collectionName, schema).WithProperty(common.CollectionTTLConfigKey, 86400))
	if err != nil {
		// handle error
	}
}

func ExampleClient_CreateCollection_quickSetup() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collectionName := `quick_setup_1`
	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	err = cli.CreateCollection(ctx, milvusclient.SimpleCreateCollectionOptions(collectionName, 512))
	if err != nil {
		// handle error
	}
}

func ExampleClient_CreateCollection_quickSetupWithIndexParams() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collectionName := `quick_setup_2`
	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	err = cli.CreateCollection(ctx, milvusclient.SimpleCreateCollectionOptions(collectionName, 512).WithIndexOptions(
		milvusclient.NewCreateIndexOption(collectionName, "vector", index.NewHNSWIndex(entity.L2, 64, 128)),
	))
	if err != nil {
		log.Println(err.Error())
		// handle error
	}
}

func ExampleClient_CreateCollection_quickSetupCustomize() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	err = cli.CreateCollection(ctx, milvusclient.SimpleCreateCollectionOptions("custom_quick_setup", 512).
		WithPKFieldName("my_id").
		WithVarcharPK(true, 512).
		WithVectorFieldName("my_vector").
		WithMetricType(entity.L2).
		WithShardNum(5).
		WithAutoID(true),
	)
	if err != nil {
		log.Println(err.Error())
		// handle error
	}
}

func ExampleClient_CreateCollection_consistencyLevel() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collectionName := `customized_setup_5`

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	schema := entity.NewSchema().WithDynamicFieldEnabled(true).
		WithField(entity.NewField().WithName("my_id").WithIsAutoID(true).WithDataType(entity.FieldTypeInt64).WithIsPrimaryKey(true)).
		WithField(entity.NewField().WithName("my_vector").WithDataType(entity.FieldTypeFloatVector).WithDim(5)).
		WithField(entity.NewField().WithName("my_varchar").WithDataType(entity.FieldTypeVarChar).WithMaxLength(512))

	err = cli.CreateCollection(ctx, milvusclient.NewCreateCollectionOption(collectionName, schema).WithConsistencyLevel(entity.ClBounded))
	if err != nil {
		// handle error
	}
}

func ExampleClient_CreateCollection_withIndexes() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collectionName := `customized_setup_5`

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	schema := entity.NewSchema().WithDynamicFieldEnabled(true).
		WithField(entity.NewField().WithName("my_id").WithIsAutoID(true).WithDataType(entity.FieldTypeInt64).WithIsPrimaryKey(true)).
		WithField(entity.NewField().WithName("my_vector").WithDataType(entity.FieldTypeFloatVector).WithDim(5)).
		WithField(entity.NewField().WithName("my_varchar").WithDataType(entity.FieldTypeVarChar).WithMaxLength(512))

	idx := index.NewAutoIndex(entity.IP)
	indexOption := milvusclient.NewCreateIndexOption("my_dense_collection", "dense_vector", idx)

	err = cli.CreateCollection(ctx,
		milvusclient.NewCreateCollectionOption(collectionName, schema).
			WithIndexOptions(indexOption))
	if err != nil {
		// handle error
	}
}

func ExampleClient_CreateCollection_binaryVector() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collectionName := `my_binary_collection`

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	schema := entity.NewSchema()
	schema.WithField(entity.NewField().
		WithName("pk").
		WithDataType(entity.FieldTypeVarChar).
		WithMaxLength(100).
		WithIsAutoID(true),
	).WithField(entity.NewField().
		WithName("binary_vector").
		WithDataType(entity.FieldTypeBinaryVector).
		WithDim(128),
	)

	idx := index.NewAutoIndex(entity.HAMMING)
	indexOption := milvusclient.NewCreateIndexOption("my_binary_collection", "binary_vector", idx)

	err = cli.CreateCollection(ctx,
		milvusclient.NewCreateCollectionOption(collectionName, schema).
			WithIndexOptions(indexOption))
	if err != nil {
		// handle error
	}
}

func ExampleClient_CreateCollection_jsonField() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	schema := entity.NewSchema()
	schema.WithField(entity.NewField().
		WithName("pk").
		WithDataType(entity.FieldTypeInt64).
		WithIsAutoID(true),
	).WithField(entity.NewField().
		WithName("embedding").
		WithDataType(entity.FieldTypeFloatVector).
		WithDim(3),
	).WithField(entity.NewField().
		WithName("metadata").
		WithDataType(entity.FieldTypeJSON),
	)

	jsonIndex1 := index.NewJSONPathIndex(index.Inverted, "varchar", `metadata["product_info"]["category"]`)
	jsonIndex2 := index.NewJSONPathIndex(index.Inverted, "double", `metadata["price"]`)
	indexOpt1 := milvusclient.NewCreateIndexOption("my_json_collection", "meta", jsonIndex1)
	indexOpt2 := milvusclient.NewCreateIndexOption("my_json_collection", "meta", jsonIndex2)

	vectorIndex := index.NewAutoIndex(entity.COSINE)
	indexOpt := milvusclient.NewCreateIndexOption("my_json_collection", "embedding", vectorIndex)

	err = cli.CreateCollection(ctx, milvusclient.NewCreateCollectionOption("my_json_collection", schema).
		WithIndexOptions(indexOpt1, indexOpt2, indexOpt))
	if err != nil {
		// handler err
	}
}

func ExampleClient_CreateCollection_dynamicSchema() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// collectionName := `my_dynamic_collection`

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	err = cli.CreateCollection(ctx,
		milvusclient.SimpleCreateCollectionOptions("my_dynamic_collection", 5).
			WithDynamicSchema(true))
	if err != nil {
		// handle error
	}
}

func ExampleClient_ListCollections() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	collectionNames, err := cli.ListCollections(ctx, milvusclient.NewListCollectionOption())
	if err != nil {
		// handle error
	}

	fmt.Println(collectionNames)
}

func ExampleClient_DescribeCollection() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	collection, err := cli.DescribeCollection(ctx, milvusclient.NewDescribeCollectionOption("quick_setup"))
	if err != nil {
		// handle error
	}

	fmt.Println(collection)
}

func ExampleClient_RenameCollection() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	err = cli.RenameCollection(ctx, milvusclient.NewRenameCollectionOption("my_collection", "my_new_collection"))
	if err != nil {
		// handle error
	}
}

func ExampleClient_AlterCollectionProperties_setTTL() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	err = cli.AlterCollectionProperties(ctx, milvusclient.NewAlterCollectionPropertiesOption("my_collection").WithProperty(common.CollectionTTLConfigKey, 60))
	if err != nil {
		// handle error
	}
}

func ExampleClient_LoadCollection() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	loadTask, err := cli.LoadCollection(ctx, milvusclient.NewLoadCollectionOption("customized_setup_1"))
	if err != nil {
		// handle error
	}

	// sync wait collection to be loaded
	err = loadTask.Await(ctx)
	if err != nil {
		// handle error
	}
}

func ExampleClient_ReleaseCollection() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	err = cli.ReleaseCollection(ctx, milvusclient.NewReleaseCollectionOption("custom_quick_setup"))
	if err != nil {
		// handle error
	}
}

func ExampleClient_DropCollection() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	err = cli.DropCollection(ctx, milvusclient.NewDropCollectionOption("customized_setup_2"))
	if err != nil {
		// handle err
	}
}



---
File: /milvusclient/collection_options.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"fmt"

	"google.golang.org/protobuf/proto"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/index"
)

// CreateCollectionOption is the interface builds CreateCollectionRequest.
type CreateCollectionOption interface {
	// Request is the method returns the composed request.
	Request() *milvuspb.CreateCollectionRequest
	// Indexes is the method returns IndexOption to create
	Indexes() []CreateIndexOption
	IsFast() bool
}

// createCollectionOption contains all the parameters to create collection.
type createCollectionOption struct {
	name     string
	shardNum int32

	// fast create collection params
	varcharPK            bool
	varcharPKMaxLength   int
	pkFieldName          string
	vectorFieldName      string
	dim                  int64
	autoID               bool
	enabledDynamicSchema bool

	// advanced create collection params
	schema           *entity.Schema
	consistencyLevel entity.ConsistencyLevel
	properties       map[string]string

	// partition key
	numPartitions int64

	indexOptions []CreateIndexOption

	// is fast create collection
	isFast bool
	// fast creation with index
	metricType entity.MetricType
}

func (opt *createCollectionOption) WithAutoID(autoID bool) *createCollectionOption {
	opt.autoID = autoID
	return opt
}

func (opt *createCollectionOption) WithShardNum(shardNum int32) *createCollectionOption {
	opt.shardNum = shardNum
	return opt
}

func (opt *createCollectionOption) WithDynamicSchema(dynamicSchema bool) *createCollectionOption {
	opt.enabledDynamicSchema = dynamicSchema
	return opt
}

func (opt *createCollectionOption) WithVarcharPK(varcharPK bool, maxLen int) *createCollectionOption {
	opt.varcharPK = varcharPK
	opt.varcharPKMaxLength = maxLen
	return opt
}

func (opt *createCollectionOption) WithIndexOptions(indexOpts ...CreateIndexOption) *createCollectionOption {
	opt.indexOptions = indexOpts
	return opt
}

func (opt *createCollectionOption) WithProperty(key string, value any) *createCollectionOption {
	opt.properties[key] = fmt.Sprintf("%v", value)
	return opt
}

func (opt *createCollectionOption) WithConsistencyLevel(cl entity.ConsistencyLevel) *createCollectionOption {
	opt.consistencyLevel = cl
	return opt
}

func (opt *createCollectionOption) WithMetricType(metricType entity.MetricType) *createCollectionOption {
	opt.metricType = metricType
	return opt
}

func (opt *createCollectionOption) WithPKFieldName(name string) *createCollectionOption {
	opt.pkFieldName = name
	return opt
}

func (opt *createCollectionOption) WithVectorFieldName(name string) *createCollectionOption {
	opt.vectorFieldName = name
	return opt
}

func (opt *createCollectionOption) WithNumPartitions(numPartitions int64) *createCollectionOption {
	opt.numPartitions = numPartitions
	return opt
}

func (opt *createCollectionOption) Request() *milvuspb.CreateCollectionRequest {
	// fast create collection
	if opt.isFast {
		var pkField *entity.Field
		if opt.varcharPK {
			pkField = entity.NewField().WithDataType(entity.FieldTypeVarChar).WithMaxLength(int64(opt.varcharPKMaxLength))
		} else {
			pkField = entity.NewField().WithDataType(entity.FieldTypeInt64)
		}
		pkField = pkField.WithName(opt.pkFieldName).WithIsPrimaryKey(true).WithIsAutoID(opt.autoID)
		opt.schema = entity.NewSchema().
			WithName(opt.name).
			WithAutoID(opt.autoID).
			WithDynamicFieldEnabled(opt.enabledDynamicSchema).
			WithField(pkField).
			WithField(entity.NewField().WithName(opt.vectorFieldName).WithDataType(entity.FieldTypeFloatVector).WithDim(opt.dim))
	}

	var schemaBytes []byte
	if opt.schema != nil {
		opt.schema.WithName(opt.name)
		schemaProto := opt.schema.ProtoMessage()
		schemaBytes, _ = proto.Marshal(schemaProto)
	}

	return &milvuspb.CreateCollectionRequest{
		DbName:           "", // reserved fields, not used for now
		CollectionName:   opt.name,
		Schema:           schemaBytes,
		ShardsNum:        opt.shardNum,
		ConsistencyLevel: commonpb.ConsistencyLevel(opt.consistencyLevel),
		NumPartitions:    opt.numPartitions,
		Properties:       entity.MapKvPairs(opt.properties),
	}
}

func (opt *createCollectionOption) Indexes() []CreateIndexOption {
	// fast create
	if opt.isFast && opt.indexOptions == nil {
		return []CreateIndexOption{
			NewCreateIndexOption(opt.name, opt.vectorFieldName, index.NewGenericIndex("", map[string]string{})),
		}
	}
	return opt.indexOptions
}

func (opt *createCollectionOption) IsFast() bool {
	return opt.isFast
}

// SimpleCreateCollectionOptions returns a CreateCollectionOption with default fast collection options.
func SimpleCreateCollectionOptions(name string, dim int64) *createCollectionOption {
	return &createCollectionOption{
		name:     name,
		shardNum: 1,

		pkFieldName:          "id",
		vectorFieldName:      "vector",
		autoID:               true,
		dim:                  dim,
		enabledDynamicSchema: true,
		consistencyLevel:     entity.DefaultConsistencyLevel,
		properties:           make(map[string]string),

		isFast:     true,
		metricType: entity.COSINE,
	}
}

// NewCreateCollectionOption returns a CreateCollectionOption with customized collection schema
func NewCreateCollectionOption(name string, collectionSchema *entity.Schema) *createCollectionOption {
	return &createCollectionOption{
		name:             name,
		shardNum:         1,
		schema:           collectionSchema,
		consistencyLevel: entity.DefaultConsistencyLevel,
		properties:       make(map[string]string),

		metricType: entity.COSINE,
	}
}

type ListCollectionOption interface {
	Request() *milvuspb.ShowCollectionsRequest
}

type listCollectionOption struct{}

func (opt *listCollectionOption) Request() *milvuspb.ShowCollectionsRequest {
	return &milvuspb.ShowCollectionsRequest{}
}

func NewListCollectionOption() *listCollectionOption {
	return &listCollectionOption{}
}

// DescribeCollectionOption is the interface builds DescribeCollection request.
type DescribeCollectionOption interface {
	// Request is the method returns the composed request.
	Request() *milvuspb.DescribeCollectionRequest
}

type describeCollectionOption struct {
	name string
}

func (opt *describeCollectionOption) Request() *milvuspb.DescribeCollectionRequest {
	return &milvuspb.DescribeCollectionRequest{
		CollectionName: opt.name,
	}
}

// NewDescribeCollectionOption composes a describeCollectionOption with provided collection name.
func NewDescribeCollectionOption(name string) *describeCollectionOption {
	return &describeCollectionOption{
		name: name,
	}
}

// HasCollectionOption is the interface to build DescribeCollectionRequest.
type HasCollectionOption interface {
	Request() *milvuspb.DescribeCollectionRequest
}

type hasCollectionOpt struct {
	name string
}

func (opt *hasCollectionOpt) Request() *milvuspb.DescribeCollectionRequest {
	return &milvuspb.DescribeCollectionRequest{
		CollectionName: opt.name,
	}
}

func NewHasCollectionOption(name string) HasCollectionOption {
	return &hasCollectionOpt{
		name: name,
	}
}

// The DropCollectionOption interface builds DropCollectionRequest.
type DropCollectionOption interface {
	Request() *milvuspb.DropCollectionRequest
}

type dropCollectionOption struct {
	name string
}

func (opt *dropCollectionOption) Request() *milvuspb.DropCollectionRequest {
	return &milvuspb.DropCollectionRequest{
		CollectionName: opt.name,
	}
}

func NewDropCollectionOption(name string) *dropCollectionOption {
	return &dropCollectionOption{
		name: name,
	}
}

type RenameCollectionOption interface {
	Request() *milvuspb.RenameCollectionRequest
}

type renameCollectionOption struct {
	oldCollectionName string
	newCollectionName string
}

func (opt *renameCollectionOption) Request() *milvuspb.RenameCollectionRequest {
	return &milvuspb.RenameCollectionRequest{
		OldName: opt.oldCollectionName,
		NewName: opt.newCollectionName,
	}
}

func NewRenameCollectionOption(oldName, newName string) *renameCollectionOption {
	return &renameCollectionOption{
		oldCollectionName: oldName,
		newCollectionName: newName,
	}
}

type AlterCollectionPropertiesOption interface {
	Request() *milvuspb.AlterCollectionRequest
}

type alterCollectionPropertiesOption struct {
	collectionName string
	properties     map[string]string
}

func (opt *alterCollectionPropertiesOption) WithProperty(key string, value any) *alterCollectionPropertiesOption {
	opt.properties[key] = fmt.Sprintf("%v", value)
	return opt
}

func (opt *alterCollectionPropertiesOption) Request() *milvuspb.AlterCollectionRequest {
	return &milvuspb.AlterCollectionRequest{
		CollectionName: opt.collectionName,
		Properties:     entity.MapKvPairs(opt.properties),
	}
}

func NewAlterCollectionPropertiesOption(collection string) *alterCollectionPropertiesOption {
	return &alterCollectionPropertiesOption{collectionName: collection, properties: make(map[string]string)}
}

type DropCollectionPropertiesOption interface {
	Request() *milvuspb.AlterCollectionRequest
}

type dropCollectionPropertiesOption struct {
	collectionName string
	keys           []string
}

func (opt *dropCollectionPropertiesOption) Request() *milvuspb.AlterCollectionRequest {
	return &milvuspb.AlterCollectionRequest{
		CollectionName: opt.collectionName,
		DeleteKeys:     opt.keys,
	}
}

func NewDropCollectionPropertiesOption(collection string, propertyKeys ...string) *dropCollectionPropertiesOption {
	return &dropCollectionPropertiesOption{
		collectionName: collection,
		keys:           propertyKeys,
	}
}

type AlterCollectionFieldPropertiesOption interface {
	Request() *milvuspb.AlterCollectionFieldRequest
}

type alterCollectionFieldPropertiesOption struct {
	collectionName string
	fieldName      string
	properties     map[string]string
}

func (opt *alterCollectionFieldPropertiesOption) WithProperty(key string, value any) *alterCollectionFieldPropertiesOption {
	opt.properties[key] = fmt.Sprintf("%v", value)
	return opt
}

func (opt *alterCollectionFieldPropertiesOption) Request() *milvuspb.AlterCollectionFieldRequest {
	return &milvuspb.AlterCollectionFieldRequest{
		CollectionName: opt.collectionName,
		FieldName:      opt.fieldName,
		Properties:     entity.MapKvPairs(opt.properties),
	}
}

func NewAlterCollectionFieldPropertiesOption(collectionName string, fieldName string) *alterCollectionFieldPropertiesOption {
	return &alterCollectionFieldPropertiesOption{
		collectionName: collectionName,
		fieldName:      fieldName,
		properties:     make(map[string]string),
	}
}

type getCollectionStatsOption struct {
	collectionName string
}

func (opt *getCollectionStatsOption) Request() *milvuspb.GetCollectionStatisticsRequest {
	return &milvuspb.GetCollectionStatisticsRequest{
		CollectionName: opt.collectionName,
	}
}

func NewGetCollectionStatsOption(collectionName string) *getCollectionStatsOption {
	return &getCollectionStatsOption{collectionName: collectionName}
}



---
File: /milvusclient/collection_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"fmt"
	"testing"

	"github.com/cockroachdb/errors"
	"github.com/samber/lo"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"google.golang.org/protobuf/proto"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/common"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type CollectionSuite struct {
	MockSuiteBase
}

func (s *CollectionSuite) TestListCollection() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	s.Run("success", func() {
		s.mock.EXPECT().ShowCollections(mock.Anything, mock.Anything).Return(&milvuspb.ShowCollectionsResponse{
			CollectionNames: []string{"test1", "test2", "test3"},
		}, nil).Once()

		names, err := s.client.ListCollections(ctx, NewListCollectionOption())
		s.NoError(err)
		s.ElementsMatch([]string{"test1", "test2", "test3"}, names)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().ShowCollections(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.ListCollections(ctx, NewListCollectionOption())
		s.Error(err)
	})
}

func (s *CollectionSuite) TestCreateCollection() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		s.mock.EXPECT().CreateCollection(mock.Anything, mock.Anything).Return(merr.Success(), nil).Once()
		s.mock.EXPECT().CreateIndex(mock.Anything, mock.Anything).Return(merr.Success(), nil).Once()
		s.mock.EXPECT().LoadCollection(mock.Anything, mock.Anything).Return(merr.Success(), nil).Once()
		s.mock.EXPECT().DescribeIndex(mock.Anything, mock.Anything).Return(&milvuspb.DescribeIndexResponse{
			Status: merr.Success(),
			IndexDescriptions: []*milvuspb.IndexDescription{
				{FieldName: "vector", State: commonpb.IndexState_Finished},
			},
		}, nil).Once()
		s.mock.EXPECT().GetLoadingProgress(mock.Anything, mock.Anything).Return(&milvuspb.GetLoadingProgressResponse{
			Status:   merr.Success(),
			Progress: 100,
		}, nil).Once()

		err := s.client.CreateCollection(ctx, SimpleCreateCollectionOptions("test_collection", 128))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().CreateCollection(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.CreateCollection(ctx, SimpleCreateCollectionOptions("test_collection", 128))
		s.Error(err)
	})
}

func (s *CollectionSuite) TestCreateCollectionOptions() {
	collectionName := fmt.Sprintf("test_collection_%s", s.randString(6))
	opt := SimpleCreateCollectionOptions(collectionName, 128)
	req := opt.Request()
	s.Equal(collectionName, req.GetCollectionName())
	s.EqualValues(1, req.GetShardsNum())

	collSchema := &schemapb.CollectionSchema{}
	err := proto.Unmarshal(req.GetSchema(), collSchema)
	s.Require().NoError(err)
	s.True(collSchema.GetEnableDynamicField())

	collectionName = fmt.Sprintf("test_collection_%s", s.randString(6))
	opt = SimpleCreateCollectionOptions(collectionName, 128).WithVarcharPK(true, 64).WithAutoID(false).
		WithPKFieldName("pk").WithVectorFieldName("embedding").WithMetricType(entity.L2).
		WithDynamicSchema(false)
	req = opt.Request()
	s.Equal(collectionName, req.GetCollectionName())
	s.EqualValues(1, req.GetShardsNum())

	collSchema = &schemapb.CollectionSchema{}
	err = proto.Unmarshal(req.GetSchema(), collSchema)
	s.Require().NoError(err)
	s.False(collSchema.GetEnableDynamicField())

	collectionName = fmt.Sprintf("test_collection_%s", s.randString(6))
	schema := entity.NewSchema().
		WithField(entity.NewField().WithName("int64").WithDataType(entity.FieldTypeInt64).WithIsPrimaryKey(true)).
		WithField(entity.NewField().WithName("vector").WithDim(128).WithDataType(entity.FieldTypeFloatVector))

	opt = NewCreateCollectionOption(collectionName, schema).
		WithShardNum(2).
		WithConsistencyLevel(entity.ClEventually).
		WithProperty(common.CollectionTTLConfigKey, 86400)

	req = opt.Request()
	s.Equal(collectionName, req.GetCollectionName())
	s.EqualValues(2, req.GetShardsNum())
	s.EqualValues(commonpb.ConsistencyLevel_Eventually, req.GetConsistencyLevel())
	if s.Len(req.GetProperties(), 1) {
		kv := req.GetProperties()[0]
		s.Equal(common.CollectionTTLConfigKey, kv.GetKey())
		s.Equal("86400", kv.GetValue())
	}

	collSchema = &schemapb.CollectionSchema{}
	err = proto.Unmarshal(req.GetSchema(), collSchema)
	s.Require().NoError(err)
}

func (s *CollectionSuite) TestDescribeCollection() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		s.mock.EXPECT().DescribeCollection(mock.Anything, mock.Anything).Return(&milvuspb.DescribeCollectionResponse{
			Status: merr.Success(),
			Schema: &schemapb.CollectionSchema{
				Name: "test_collection",
				Fields: []*schemapb.FieldSchema{
					{FieldID: 100, DataType: schemapb.DataType_Int64, AutoID: true, Name: "ID"},
					{
						FieldID: 101, DataType: schemapb.DataType_FloatVector, Name: "vector",
						TypeParams: []*commonpb.KeyValuePair{
							{Key: "dim", Value: "128"},
						},
					},
				},
			},
			CollectionID:   1000,
			CollectionName: "test_collection",
		}, nil).Once()

		coll, err := s.client.DescribeCollection(ctx, NewDescribeCollectionOption("test_collection"))
		s.NoError(err)

		s.EqualValues(1000, coll.ID)
		s.Equal("test_collection", coll.Name)
		s.Len(coll.Schema.Fields, 2)
		idField, ok := lo.Find(coll.Schema.Fields, func(field *entity.Field) bool {
			return field.ID == 100
		})
		s.Require().True(ok)
		s.Equal("ID", idField.Name)
		s.Equal(entity.FieldTypeInt64, idField.DataType)
		s.True(idField.AutoID)

		vectorField, ok := lo.Find(coll.Schema.Fields, func(field *entity.Field) bool {
			return field.ID == 101
		})
		s.Require().True(ok)
		s.Equal("vector", vectorField.Name)
		s.Equal(entity.FieldTypeFloatVector, vectorField.DataType)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().DescribeCollection(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.DescribeCollection(ctx, NewDescribeCollectionOption("test_collection"))
		s.Error(err)
	})
}

func (s *CollectionSuite) TestHasCollection() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		s.mock.EXPECT().DescribeCollection(mock.Anything, mock.Anything).Return(&milvuspb.DescribeCollectionResponse{
			Status: merr.Success(),
			Schema: &schemapb.CollectionSchema{
				Name: "test_collection",
				Fields: []*schemapb.FieldSchema{
					{FieldID: 100, DataType: schemapb.DataType_Int64, AutoID: true, Name: "ID"},
					{
						FieldID: 101, DataType: schemapb.DataType_FloatVector, Name: "vector",
						TypeParams: []*commonpb.KeyValuePair{
							{Key: "dim", Value: "128"},
						},
					},
				},
			},
			CollectionID:   1000,
			CollectionName: "test_collection",
		}, nil).Once()

		has, err := s.client.HasCollection(ctx, NewHasCollectionOption("test_collection"))
		s.NoError(err)

		s.True(has)
	})

	s.Run("collection_not_exist", func() {
		s.mock.EXPECT().DescribeCollection(mock.Anything, mock.Anything).Return(&milvuspb.DescribeCollectionResponse{
			Status: merr.Status(merr.WrapErrCollectionNotFound("test_collection")),
		}, nil).Once()

		has, err := s.client.HasCollection(ctx, NewHasCollectionOption("test_collection"))
		s.NoError(err)

		s.False(has)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().DescribeCollection(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.HasCollection(ctx, NewHasCollectionOption("test_collection"))
		s.Error(err)
	})
}

func (s *CollectionSuite) TestDropCollection() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		s.mock.EXPECT().DropCollection(mock.Anything, mock.Anything).Return(merr.Success(), nil).Once()

		err := s.client.DropCollection(ctx, NewDropCollectionOption("test_collection"))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().DropCollection(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.DropCollection(ctx, NewDropCollectionOption("test_collection"))
		s.Error(err)
	})
}

func (s *CollectionSuite) TestRenameCollection() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	oldName := fmt.Sprintf("test_collection_%s", s.randString(6))
	newName := fmt.Sprintf("%s_new", oldName)

	s.Run("success", func() {
		s.mock.EXPECT().RenameCollection(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, rcr *milvuspb.RenameCollectionRequest) (*commonpb.Status, error) {
			s.Equal(oldName, rcr.GetOldName())
			s.Equal(newName, rcr.GetNewName())
			return merr.Success(), nil
		}).Once()

		err := s.client.RenameCollection(ctx, NewRenameCollectionOption(oldName, newName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().RenameCollection(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.RenameCollection(ctx, NewRenameCollectionOption(oldName, newName))
		s.Error(err)
	})
}

func (s *CollectionSuite) TestAlterCollectionProperties() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collName := fmt.Sprintf("test_collection_%s", s.randString(6))
	key := s.randString(6)
	value := s.randString(6)

	s.Run("success", func() {
		s.mock.EXPECT().AlterCollection(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, acr *milvuspb.AlterCollectionRequest) (*commonpb.Status, error) {
			s.Equal(collName, acr.GetCollectionName())
			if s.Len(acr.GetProperties(), 1) {
				item := acr.GetProperties()[0]
				s.Equal(key, item.GetKey())
				s.Equal(value, item.GetValue())
			}
			return merr.Success(), nil
		}).Once()

		err := s.client.AlterCollectionProperties(ctx, NewAlterCollectionPropertiesOption(collName).WithProperty(key, value))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().AlterCollection(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.AlterCollectionProperties(ctx, NewAlterCollectionPropertiesOption(collName).WithProperty(key, value))
		s.Error(err)
	})
}

func (s *CollectionSuite) TestDropCollectionProperties() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		dbName := fmt.Sprintf("dt_%s", s.randString(6))
		key := fmt.Sprintf("key_%s", s.randString(4))
		s.mock.EXPECT().AlterCollection(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, adr *milvuspb.AlterCollectionRequest) (*commonpb.Status, error) {
			s.Equal([]string{key}, adr.GetDeleteKeys())
			return merr.Success(), nil
		}).Once()

		err := s.client.DropCollectionProperties(ctx, NewDropCollectionPropertiesOption(dbName, key))
		s.NoError(err)
	})

	s.Run("failure", func() {
		dbName := fmt.Sprintf("dt_%s", s.randString(6))
		s.mock.EXPECT().AlterCollection(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.DropCollectionProperties(ctx, NewDropCollectionPropertiesOption(dbName, "key"))
		s.Error(err)
	})
}

func (s *CollectionSuite) TestAlterCollectionFieldProperties() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collName := fmt.Sprintf("test_collection_%s", s.randString(6))
	fieldName := fmt.Sprintf("field_%s", s.randString(4))
	key := s.randString(6)
	value := s.randString(6)

	s.Run("success", func() {
		s.mock.EXPECT().AlterCollectionField(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, acr *milvuspb.AlterCollectionFieldRequest) (*commonpb.Status, error) {
			s.Equal(collName, acr.GetCollectionName())
			s.Equal(fieldName, acr.GetFieldName())
			if s.Len(acr.GetProperties(), 1) {
				item := acr.GetProperties()[0]
				s.Equal(key, item.GetKey())
				s.Equal(value, item.GetValue())
			}
			return merr.Success(), nil
		}).Once()

		err := s.client.AlterCollectionFieldProperty(ctx, NewAlterCollectionFieldPropertiesOption(collName, fieldName).WithProperty(key, value))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().AlterCollectionField(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.AlterCollectionFieldProperty(ctx, NewAlterCollectionFieldPropertiesOption("coll", "field").WithProperty(key, value))
		s.Error(err)
	})
}

func (s *CollectionSuite) TestGetCollectionStats() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collName := fmt.Sprintf("coll_%s", s.randString(6))
		s.mock.EXPECT().GetCollectionStatistics(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, gcsr *milvuspb.GetCollectionStatisticsRequest) (*milvuspb.GetCollectionStatisticsResponse, error) {
			s.Equal(collName, gcsr.GetCollectionName())
			return &milvuspb.GetCollectionStatisticsResponse{
				Status: &commonpb.Status{ErrorCode: commonpb.ErrorCode_Success},
				Stats: []*commonpb.KeyValuePair{
					{Key: "row_count", Value: "1000"},
				},
			}, nil
		}).Once()

		stats, err := s.client.GetCollectionStats(ctx, NewGetCollectionStatsOption(collName))
		s.NoError(err)

		s.Len(stats, 1)
		s.Equal("1000", stats["row_count"])
	})

	s.Run("failure", func() {
		collName := fmt.Sprintf("coll_%s", s.randString(6))
		s.mock.EXPECT().GetCollectionStatistics(mock.Anything, mock.Anything).Return(nil, errors.New("mocked")).Once()

		_, err := s.client.GetCollectionStats(ctx, NewGetCollectionStatsOption(collName))
		s.Error(err)
	})
}

func TestCollection(t *testing.T) {
	suite.Run(t, new(CollectionSuite))
}



---
File: /milvusclient/collection.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"

	"github.com/cockroachdb/errors"
	"google.golang.org/grpc"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

// CreateCollection is the API for create a collection in Milvus.
func (c *Client) CreateCollection(ctx context.Context, option CreateCollectionOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.CreateCollection(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
	if err != nil {
		return err
	}

	indexes := option.Indexes()
	for _, indexOption := range indexes {
		task, err := c.CreateIndex(ctx, indexOption, callOptions...)
		if err != nil {
			return err
		}
		err = task.Await(ctx)
		if err != nil {
			return nil
		}
	}

	if option.IsFast() {
		task, err := c.LoadCollection(ctx, NewLoadCollectionOption(req.GetCollectionName()))
		if err != nil {
			return err
		}
		return task.Await(ctx)
	}

	return nil
}

func (c *Client) ListCollections(ctx context.Context, option ListCollectionOption, callOptions ...grpc.CallOption) (collectionNames []string, err error) {
	req := option.Request()
	err = c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.ShowCollections(ctx, req, callOptions...)
		err = merr.CheckRPCCall(resp, err)
		if err != nil {
			return err
		}

		collectionNames = resp.GetCollectionNames()
		return nil
	})

	return collectionNames, err
}

func (c *Client) DescribeCollection(ctx context.Context, option DescribeCollectionOption, callOptions ...grpc.CallOption) (collection *entity.Collection, err error) {
	req := option.Request()
	err = c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DescribeCollection(ctx, req, callOptions...)
		err = merr.CheckRPCCall(resp, err)
		if err != nil {
			return err
		}

		collection = &entity.Collection{
			ID:               resp.GetCollectionID(),
			Schema:           entity.NewSchema().ReadProto(resp.GetSchema()),
			PhysicalChannels: resp.GetPhysicalChannelNames(),
			VirtualChannels:  resp.GetVirtualChannelNames(),
			ConsistencyLevel: entity.ConsistencyLevel(resp.ConsistencyLevel),
			ShardNum:         resp.GetShardsNum(),
			Properties:       entity.KvPairsMap(resp.GetProperties()),
			UpdateTimestamp:  resp.GetUpdateTimestamp(),
		}
		collection.Name = collection.Schema.CollectionName
		return nil
	})

	return collection, err
}

func (c *Client) HasCollection(ctx context.Context, option HasCollectionOption, callOptions ...grpc.CallOption) (has bool, err error) {
	req := option.Request()
	err = c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DescribeCollection(ctx, req, callOptions...)
		err = merr.CheckRPCCall(resp, err)
		if err != nil {
			// ErrCollectionNotFound for collection not exist
			if errors.Is(err, merr.ErrCollectionNotFound) {
				return nil
			}
			return err
		}
		has = true
		return nil
	})
	return has, err
}

func (c *Client) DropCollection(ctx context.Context, option DropCollectionOption, callOptions ...grpc.CallOption) error {
	req := option.Request()
	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DropCollection(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
	return err
}

func (c *Client) RenameCollection(ctx context.Context, option RenameCollectionOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.RenameCollection(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) AlterCollectionProperties(ctx context.Context, option AlterCollectionPropertiesOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.AlterCollection(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) DropCollectionProperties(ctx context.Context, option DropCollectionPropertiesOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.AlterCollection(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) AlterCollectionFieldProperty(ctx context.Context, option AlterCollectionFieldPropertiesOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.AlterCollectionField(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

type GetCollectionOption interface {
	Request() *milvuspb.GetCollectionStatisticsRequest
}

func (c *Client) GetCollectionStats(ctx context.Context, opt GetCollectionOption) (map[string]string, error) {
	var stats map[string]string
	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.GetCollectionStatistics(ctx, opt.Request())
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}
		stats = entity.KvPairsMap(resp.GetStats())
		return nil
	})
	if err != nil {
		return nil, err
	}
	return stats, nil
}



---
File: /milvusclient/common_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"sync/atomic"
	"testing"

	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type CommonSuite struct {
	MockSuiteBase
}

func (s *CommonSuite) TestRetryIfSchemaError() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	s.Run("normal_no_error", func() {
		counter := atomic.Int32{}
		err := s.client.retryIfSchemaError(ctx, "test_coll", func(ctx context.Context) (uint64, error) {
			counter.Add(1)
			return 10, nil
		})
		s.NoError(err)
		s.EqualValues(1, counter.Load())
	})

	s.Run("other_error", func() {
		counter := atomic.Int32{}
		err := s.client.retryIfSchemaError(ctx, "test_coll", func(ctx context.Context) (uint64, error) {
			counter.Add(1)
			return 10, merr.WrapErrServiceInternal("mocked")
		})
		s.Error(err)
		s.EqualValues(1, counter.Load())
	})

	s.Run("transient_schema_err", func() {
		counter := atomic.Int32{}
		err := s.client.retryIfSchemaError(ctx, "test_coll", func(ctx context.Context) (uint64, error) {
			epoch := counter.Load()
			counter.Add(1)
			if epoch == 0 {
				return 10, merr.WrapErrCollectionSchemaMisMatch("mocked")
			}
			return 11, nil
		})
		s.NoError(err)
		s.EqualValues(2, counter.Load())
	})

	s.Run("consistent_schema_err", func() {
		counter := atomic.Int32{}
		err := s.client.retryIfSchemaError(ctx, "test_coll", func(ctx context.Context) (uint64, error) {
			counter.Add(1)
			return 10, merr.WrapErrCollectionSchemaMisMatch("mocked")
		})
		s.Error(err)
		s.EqualValues(2, counter.Load())
	})
}

func TestCommonFunc(t *testing.T) {
	suite.Run(t, new(CommonSuite))
}



---
File: /milvusclient/common.go
---

package milvusclient

import (
	"context"
	"math"

	"github.com/cockroachdb/errors"

	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/conc"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
	"github.com/milvus-io/milvus/pkg/v2/util/retry"
	"github.com/milvus-io/milvus/pkg/v2/util/typeutil"
)

// CollectionCache stores the cached collection schema information.
type CollectionCache struct {
	sf          conc.Singleflight[*entity.Collection]
	collections *typeutil.ConcurrentMap[string, *entity.Collection]
	fetcher     func(context.Context, string) (*entity.Collection, error)
}

func (c *CollectionCache) GetCollection(ctx context.Context, collName string) (*entity.Collection, error) {
	coll, ok := c.collections.Get(collName)
	if ok {
		return coll, nil
	}

	coll, err, _ := c.sf.Do(collName, func() (*entity.Collection, error) {
		coll, err := c.fetcher(ctx, collName)
		if err != nil {
			return nil, err
		}
		c.collections.Insert(collName, coll)
		return coll, nil
	})
	return coll, err
}

// Evict removes the collection cache related to the provided collection name.
func (c *CollectionCache) Evict(collName string) {
	c.collections.Remove(collName)
}

// Reset clears all cached info, used when client switching env.
func (c *CollectionCache) Reset() {
	c.collections = typeutil.NewConcurrentMap[string, *entity.Collection]()
}

func NewCollectionCache(fetcher func(context.Context, string) (*entity.Collection, error)) *CollectionCache {
	return &CollectionCache{
		collections: typeutil.NewConcurrentMap[string, *entity.Collection](),
		fetcher:     fetcher,
	}
}

func (c *Client) getCollection(ctx context.Context, collName string) (*entity.Collection, error) {
	return c.collCache.GetCollection(ctx, collName)
}

func (c *Client) retryIfSchemaError(ctx context.Context, collName string, work func(ctx context.Context) (uint64, error)) error {
	var lastTs uint64 = math.MaxUint64
	return retry.Handle(ctx, func() (bool, error) {
		ts, err := work(ctx)
		if err != nil {
			// if schema error
			if errors.Is(err, merr.ErrCollectionSchemaMismatch) {
				sameTs := ts == lastTs
				lastTs = ts
				if !sameTs {
					c.collCache.Evict(collName)
				}
				// retry if not same ts
				return !sameTs, err
			}
			return false, err
		}
		return false, nil
	})
}



---
File: /milvusclient/database_example_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// nolint
package milvusclient_test

import (
	"context"
	"log"

	"github.com/milvus-io/milvus/client/v2/milvusclient"
)

func ExampleClient_CreateDatabase() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	dbName := `test_db`
	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	err = cli.CreateDatabase(ctx, milvusclient.NewCreateDatabaseOption(dbName))
	if err != nil {
		// handle err
	}
}

func ExampleClient_CreateDatabase_withProperties() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	dbName := `test_db_2`
	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	err = cli.CreateDatabase(ctx, milvusclient.NewCreateDatabaseOption(dbName).WithProperty("database.replica.number", 3))
	if err != nil {
		// handle err
	}
}

func ExampleClient_DescribeDatabase() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	dbName := `test_db`
	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	db, err := cli.DescribeDatabase(ctx, milvusclient.NewDescribeDatabaseOption(dbName))
	if err != nil {
		// handle err
	}
	log.Println(db)
}



---
File: /milvusclient/database_options.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"fmt"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

type UseDatabaseOption interface {
	DbName() string
}

type useDatabaseNameOpt struct {
	dbName string
}

func (opt *useDatabaseNameOpt) DbName() string {
	return opt.dbName
}

func NewUseDatabaseOption(dbName string) *useDatabaseNameOpt {
	return &useDatabaseNameOpt{
		dbName: dbName,
	}
}

// ListDatabaseOption is a builder interface for ListDatabase request.
type ListDatabaseOption interface {
	Request() *milvuspb.ListDatabasesRequest
}

type listDatabaseOption struct{}

func (opt *listDatabaseOption) Request() *milvuspb.ListDatabasesRequest {
	return &milvuspb.ListDatabasesRequest{}
}

func NewListDatabaseOption() *listDatabaseOption {
	return &listDatabaseOption{}
}

type CreateDatabaseOption interface {
	Request() *milvuspb.CreateDatabaseRequest
}

type createDatabaseOption struct {
	dbName     string
	Properties map[string]string
}

func (opt *createDatabaseOption) Request() *milvuspb.CreateDatabaseRequest {
	return &milvuspb.CreateDatabaseRequest{
		DbName:     opt.dbName,
		Properties: entity.MapKvPairs(opt.Properties),
	}
}

func (opt *createDatabaseOption) WithProperty(key string, val any) *createDatabaseOption {
	opt.Properties[key] = fmt.Sprintf("%v", val)
	return opt
}

func NewCreateDatabaseOption(dbName string) *createDatabaseOption {
	return &createDatabaseOption{
		dbName:     dbName,
		Properties: make(map[string]string),
	}
}

type DropDatabaseOption interface {
	Request() *milvuspb.DropDatabaseRequest
}

type dropDatabaseOption struct {
	dbName string
}

func (opt *dropDatabaseOption) Request() *milvuspb.DropDatabaseRequest {
	return &milvuspb.DropDatabaseRequest{
		DbName: opt.dbName,
	}
}

func NewDropDatabaseOption(dbName string) *dropDatabaseOption {
	return &dropDatabaseOption{
		dbName: dbName,
	}
}

type DescribeDatabaseOption interface {
	Request() *milvuspb.DescribeDatabaseRequest
}

type describeDatabaseOption struct {
	dbName string
}

func (opt *describeDatabaseOption) Request() *milvuspb.DescribeDatabaseRequest {
	return &milvuspb.DescribeDatabaseRequest{
		DbName: opt.dbName,
	}
}

func NewDescribeDatabaseOption(dbName string) *describeDatabaseOption {
	return &describeDatabaseOption{
		dbName: dbName,
	}
}

type AlterDatabasePropertiesOption interface {
	Request() *milvuspb.AlterDatabaseRequest
}

type alterDatabasePropertiesOption struct {
	dbName     string
	properties map[string]string
}

func (opt *alterDatabasePropertiesOption) Request() *milvuspb.AlterDatabaseRequest {
	return &milvuspb.AlterDatabaseRequest{
		DbName:     opt.dbName,
		Properties: entity.MapKvPairs(opt.properties),
	}
}

func (opt *alterDatabasePropertiesOption) WithProperty(key string, value any) *alterDatabasePropertiesOption {
	opt.properties[key] = fmt.Sprintf("%v", value)
	return opt
}

func NewAlterDatabasePropertiesOption(dbName string) *alterDatabasePropertiesOption {
	return &alterDatabasePropertiesOption{
		dbName:     dbName,
		properties: make(map[string]string),
	}
}

type DropDatabasePropertiesOption interface {
	Request() *milvuspb.AlterDatabaseRequest
}

type dropDatabasePropertiesOption struct {
	dbName string
	keys   []string
}

func (opt *dropDatabasePropertiesOption) Request() *milvuspb.AlterDatabaseRequest {
	return &milvuspb.AlterDatabaseRequest{
		DbName:     opt.dbName,
		DeleteKeys: opt.keys,
	}
}

func NewDropDatabasePropertiesOption(dbName string, propertyKeys ...string) *dropDatabasePropertiesOption {
	return &dropDatabasePropertiesOption{
		dbName: dbName,
		keys:   propertyKeys,
	}
}



---
File: /milvusclient/database_test.go
---

package milvusclient

import (
	"context"
	"fmt"
	"testing"

	mock "github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type DatabaseSuite struct {
	MockSuiteBase
}

func (s *DatabaseSuite) TestListDatabases() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		s.mock.EXPECT().ListDatabases(mock.Anything, mock.Anything).Return(&milvuspb.ListDatabasesResponse{
			Status:  merr.Success(),
			DbNames: []string{"default", "db1"},
		}, nil).Once()

		names, err := s.client.ListDatabase(ctx, NewListDatabaseOption())
		s.NoError(err)
		s.ElementsMatch([]string{"default", "db1"}, names)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().ListDatabases(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.ListDatabase(ctx, NewListDatabaseOption())
		s.Error(err)
	})
}

func (s *DatabaseSuite) TestCreateDatabase() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		dbName := fmt.Sprintf("dt_%s", s.randString(6))
		s.mock.EXPECT().CreateDatabase(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, cdr *milvuspb.CreateDatabaseRequest) (*commonpb.Status, error) {
			s.Equal(dbName, cdr.GetDbName())
			return merr.Success(), nil
		}).Once()

		err := s.client.CreateDatabase(ctx, NewCreateDatabaseOption(dbName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		dbName := fmt.Sprintf("dt_%s", s.randString(6))
		s.mock.EXPECT().CreateDatabase(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.CreateDatabase(ctx, NewCreateDatabaseOption(dbName))
		s.Error(err)
	})
}

func (s *DatabaseSuite) TestDropDatabase() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		dbName := fmt.Sprintf("dt_%s", s.randString(6))
		s.mock.EXPECT().DropDatabase(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, ddr *milvuspb.DropDatabaseRequest) (*commonpb.Status, error) {
			s.Equal(dbName, ddr.GetDbName())
			return merr.Success(), nil
		}).Once()

		err := s.client.DropDatabase(ctx, NewDropDatabaseOption(dbName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		dbName := fmt.Sprintf("dt_%s", s.randString(6))
		s.mock.EXPECT().DropDatabase(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.DropDatabase(ctx, NewDropDatabaseOption(dbName))
		s.Error(err)
	})
}

func (s *DatabaseSuite) TestUseDatabase() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		dbName := fmt.Sprintf("dt_%s", s.randString(6))
		s.mock.EXPECT().Connect(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, cr *milvuspb.ConnectRequest) (*milvuspb.ConnectResponse, error) {
			return &milvuspb.ConnectResponse{
				Status:     merr.Success(),
				ServerInfo: &commonpb.ServerInfo{},
			}, nil
		}).Once()

		err := s.client.UseDatabase(ctx, NewUseDatabaseOption(dbName))
		s.NoError(err)

		s.Equal(dbName, s.client.currentDB)
	})
}

func (s *DatabaseSuite) TestDescribeDatabase() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		dbName := fmt.Sprintf("dt_%s", s.randString(6))
		key := fmt.Sprintf("key_%s", s.randString(4))
		value := s.randString(6)
		s.mock.EXPECT().DescribeDatabase(mock.Anything, mock.Anything).Return(&milvuspb.DescribeDatabaseResponse{
			Status: merr.Success(),
			DbName: dbName,
			Properties: []*commonpb.KeyValuePair{
				{Key: key, Value: value},
			},
		}, nil).Once()

		db, err := s.client.DescribeDatabase(ctx, NewDescribeDatabaseOption(dbName))
		s.NoError(err)
		s.Equal(dbName, db.Name)
		s.Equal(value, db.Properties[key])
	})

	s.Run("failure", func() {
		dbName := fmt.Sprintf("dt_%s", s.randString(6))
		s.mock.EXPECT().DescribeDatabase(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.DescribeDatabase(ctx, NewDescribeDatabaseOption(dbName))
		s.Error(err)
	})
}

func (s *DatabaseSuite) TestAlterDatabaseProperties() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		dbName := fmt.Sprintf("dt_%s", s.randString(6))
		key := fmt.Sprintf("key_%s", s.randString(4))
		value := s.randString(6)
		s.mock.EXPECT().AlterDatabase(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, adr *milvuspb.AlterDatabaseRequest) (*commonpb.Status, error) {
			s.Equal(dbName, adr.GetDbName())
			s.Len(adr.GetProperties(), 1)
			return merr.Success(), nil
		}).Once()

		err := s.client.AlterDatabaseProperties(ctx, NewAlterDatabasePropertiesOption(dbName).WithProperty(key, value))
		s.NoError(err)
	})

	s.Run("failure", func() {
		dbName := fmt.Sprintf("dt_%s", s.randString(6))
		s.mock.EXPECT().AlterDatabase(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.AlterDatabaseProperties(ctx, NewAlterDatabasePropertiesOption(dbName).WithProperty("key", "value"))
		s.Error(err)
	})
}

func (s *DatabaseSuite) TestDropDatabaseProperties() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		dbName := fmt.Sprintf("dt_%s", s.randString(6))
		key := fmt.Sprintf("key_%s", s.randString(4))
		s.mock.EXPECT().AlterDatabase(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, adr *milvuspb.AlterDatabaseRequest) (*commonpb.Status, error) {
			s.Equal([]string{key}, adr.GetDeleteKeys())
			return merr.Success(), nil
		}).Once()

		err := s.client.DropDatabaseProperties(ctx, NewDropDatabasePropertiesOption(dbName, key))
		s.NoError(err)
	})

	s.Run("failure", func() {
		dbName := fmt.Sprintf("dt_%s", s.randString(6))
		s.mock.EXPECT().AlterDatabase(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.DropDatabaseProperties(ctx, NewDropDatabasePropertiesOption(dbName, "key"))
		s.Error(err)
	})
}

func TestDatabase(t *testing.T) {
	suite.Run(t, new(DatabaseSuite))
}



---
File: /milvusclient/database.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"

	"google.golang.org/grpc"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

func (c *Client) UseDatabase(ctx context.Context, option UseDatabaseOption) error {
	dbName := option.DbName()
	c.usingDatabase(dbName)
	return c.connectInternal(ctx)
}

func (c *Client) ListDatabase(ctx context.Context, option ListDatabaseOption, callOptions ...grpc.CallOption) (databaseNames []string, err error) {
	req := option.Request()

	err = c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.ListDatabases(ctx, req, callOptions...)
		err = merr.CheckRPCCall(resp, err)
		if err != nil {
			return err
		}
		databaseNames = resp.GetDbNames()
		return nil
	})

	return databaseNames, err
}

func (c *Client) CreateDatabase(ctx context.Context, option CreateDatabaseOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.CreateDatabase(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) DropDatabase(ctx context.Context, option DropDatabaseOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DropDatabase(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) DescribeDatabase(ctx context.Context, option DescribeDatabaseOption, callOptions ...grpc.CallOption) (*entity.Database, error) {
	req := option.Request()

	var db *entity.Database
	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DescribeDatabase(ctx, req, callOptions...)
		err = merr.CheckRPCCall(resp, err)
		if err != nil {
			return err
		}
		// databaseInfo = resp
		db = &entity.Database{
			Name:       resp.GetDbName(),
			Properties: entity.KvPairsMap(resp.GetProperties()),
		}
		return nil
	})

	return db, err
}

func (c *Client) AlterDatabaseProperties(ctx context.Context, option AlterDatabasePropertiesOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.AlterDatabase(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) DropDatabaseProperties(ctx context.Context, option DropDatabasePropertiesOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.AlterDatabase(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}



---
File: /milvusclient/doc.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package milvusclient implements the official Go Milvus client for v2.
package milvusclient



---
File: /milvusclient/index_example_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// nolint
package milvusclient_test

import (
	"context"
	"fmt"

	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/index"
	"github.com/milvus-io/milvus/client/v2/milvusclient"
)

func ExampleClient_CreateIndex() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	index := index.NewHNSWIndex(entity.COSINE, 32, 128)
	indexTask, err := cli.CreateIndex(ctx, milvusclient.NewCreateIndexOption("my_collection", "vector", index))
	if err != nil {
		// handler err
	}

	err = indexTask.Await(ctx)
	if err != nil {
		// handler err
	}
}

func ExampleClient_CreateIndex_jsonPathIndex_dynamicField() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	jsonPathIndex := index.NewJSONPathIndex(index.Inverted,
		"varchar", // cast type
		"color",   // json path
	)
	indexTask, err := cli.CreateIndex(ctx, milvusclient.NewCreateIndexOption("my_dynamic_collection", "color", jsonPathIndex))
	if err != nil {
		// handler err
	}

	err = indexTask.Await(ctx)
	if err != nil {
		// handler err
	}
}

func ExampleClient_DescribeIndex() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	indexInfo, err := cli.DescribeIndex(ctx, milvusclient.NewDescribeIndexOption("my_collection", "my_index"))
	if err != nil {
		// handle err
	}
	fmt.Println(indexInfo)
}

func ExampleClient_DropIndex() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	err = cli.DropIndex(ctx, milvusclient.NewDropIndexOption("my_collection", "my_index"))
	if err != nil {
		// handle err
	}
}

func ExampleClient_ListIndexes() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	indexes, err := cli.ListIndexes(ctx, milvusclient.NewListIndexOption("my_collection").WithFieldName("my_vector"))
	if err != nil {
		// handle err
	}
	fmt.Println(indexes)
}



---
File: /milvusclient/index_options.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"fmt"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/index"
)

type CreateIndexOption interface {
	Request() *milvuspb.CreateIndexRequest
}

type createIndexOption struct {
	collectionName string
	fieldName      string
	indexName      string
	indexDef       index.Index

	extraParams map[string]any
}

func (opt *createIndexOption) WithExtraParam(key string, value any) {
	opt.extraParams[key] = value
}

func (opt *createIndexOption) Request() *milvuspb.CreateIndexRequest {
	params := opt.indexDef.Params()
	for key, value := range opt.extraParams {
		params[key] = fmt.Sprintf("%v", value)
	}
	req := &milvuspb.CreateIndexRequest{
		CollectionName: opt.collectionName,
		FieldName:      opt.fieldName,
		IndexName:      opt.indexName,
		ExtraParams:    entity.MapKvPairs(params),
	}

	return req
}

func (opt *createIndexOption) WithIndexName(indexName string) *createIndexOption {
	opt.indexName = indexName
	return opt
}

func NewCreateIndexOption(collectionName string, fieldName string, index index.Index) *createIndexOption {
	return &createIndexOption{
		collectionName: collectionName,
		fieldName:      fieldName,
		indexDef:       index,
		extraParams:    make(map[string]any),
	}
}

type ListIndexOption interface {
	Request() *milvuspb.DescribeIndexRequest
	Matches(*milvuspb.IndexDescription) bool
}

var _ ListIndexOption = (*listIndexOption)(nil)

type listIndexOption struct {
	collectionName string
	fieldName      string
}

func (opt *listIndexOption) WithFieldName(fieldName string) *listIndexOption {
	opt.fieldName = fieldName
	return opt
}

func (opt *listIndexOption) Matches(idxDef *milvuspb.IndexDescription) bool {
	return opt.fieldName == "" || idxDef.GetFieldName() == opt.fieldName
}

func (opt *listIndexOption) Request() *milvuspb.DescribeIndexRequest {
	return &milvuspb.DescribeIndexRequest{
		CollectionName: opt.collectionName,
		FieldName:      opt.fieldName,
	}
}

func NewListIndexOption(collectionName string) *listIndexOption {
	return &listIndexOption{
		collectionName: collectionName,
	}
}

type DescribeIndexOption interface {
	Request() *milvuspb.DescribeIndexRequest
}

type describeIndexOption struct {
	collectionName string
	fieldName      string
	indexName      string
}

func (opt *describeIndexOption) Request() *milvuspb.DescribeIndexRequest {
	return &milvuspb.DescribeIndexRequest{
		CollectionName: opt.collectionName,
		IndexName:      opt.indexName,
	}
}

func NewDescribeIndexOption(collectionName string, indexName string) *describeIndexOption {
	return &describeIndexOption{
		collectionName: collectionName,
		indexName:      indexName,
	}
}

type DropIndexOption interface {
	Request() *milvuspb.DropIndexRequest
}

type dropIndexOption struct {
	collectionName string
	indexName      string
}

func (opt *dropIndexOption) Request() *milvuspb.DropIndexRequest {
	return &milvuspb.DropIndexRequest{
		CollectionName: opt.collectionName,
		IndexName:      opt.indexName,
	}
}

func NewDropIndexOption(collectionName string, indexName string) *dropIndexOption {
	return &dropIndexOption{
		collectionName: collectionName,
		indexName:      indexName,
	}
}

type AlterIndexPropertiesOption interface {
	Request() *milvuspb.AlterIndexRequest
}

type alterIndexPropertiesOption struct {
	collectionName string
	indexName      string
	properties     map[string]string
}

func (opt *alterIndexPropertiesOption) Request() *milvuspb.AlterIndexRequest {
	return &milvuspb.AlterIndexRequest{
		CollectionName: opt.collectionName,
		IndexName:      opt.indexName,
		ExtraParams:    entity.MapKvPairs(opt.properties),
	}
}

func (opt *alterIndexPropertiesOption) WithProperty(key string, value any) *alterIndexPropertiesOption {
	opt.properties[key] = fmt.Sprintf("%v", value)
	return opt
}

func NewAlterIndexPropertiesOption(collectionName string, indexName string) *alterIndexPropertiesOption {
	return &alterIndexPropertiesOption{
		collectionName: collectionName,
		indexName:      indexName,
		properties:     make(map[string]string),
	}
}

type DropIndexPropertiesOption interface {
	Request() *milvuspb.AlterIndexRequest
}

type dropIndexPropertiesOption struct {
	collectionName string
	indexName      string
	keys           []string
}

func (opt *dropIndexPropertiesOption) Request() *milvuspb.AlterIndexRequest {
	return &milvuspb.AlterIndexRequest{
		CollectionName: opt.collectionName,
		IndexName:      opt.indexName,
		DeleteKeys:     opt.keys,
	}
}

func NewDropIndexPropertiesOption(collectionName string, indexName string, keys ...string) *dropIndexPropertiesOption {
	return &dropIndexPropertiesOption{
		collectionName: collectionName,
		indexName:      indexName,
		keys:           keys,
	}
}



---
File: /milvusclient/index_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"go.uber.org/atomic"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/index"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type IndexSuite struct {
	MockSuiteBase
}

func (s *IndexSuite) TestCreateIndex() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		fieldName := fmt.Sprintf("field_%s", s.randString(4))
		indexName := fmt.Sprintf("idx_%s", s.randString(6))

		done := atomic.NewBool(false)

		s.mock.EXPECT().CreateIndex(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, cir *milvuspb.CreateIndexRequest) (*commonpb.Status, error) {
			s.Equal(collectionName, cir.GetCollectionName())
			s.Equal(fieldName, cir.GetFieldName())
			s.Equal(indexName, cir.GetIndexName())
			return merr.Success(), nil
		}).Once()
		s.mock.EXPECT().DescribeIndex(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, dir *milvuspb.DescribeIndexRequest) (*milvuspb.DescribeIndexResponse, error) {
			state := commonpb.IndexState_InProgress
			if done.Load() {
				state = commonpb.IndexState_Finished
			}
			return &milvuspb.DescribeIndexResponse{
				Status: merr.Success(),
				IndexDescriptions: []*milvuspb.IndexDescription{
					{
						FieldName: fieldName,
						IndexName: indexName,
						State:     state,
					},
				},
			}, nil
		})
		defer s.mock.EXPECT().DescribeIndex(mock.Anything, mock.Anything).Unset()

		task, err := s.client.CreateIndex(ctx, NewCreateIndexOption(collectionName, fieldName, index.NewHNSWIndex(entity.L2, 32, 128)).WithIndexName(indexName))
		s.NoError(err)

		ch := make(chan struct{})
		go func() {
			defer close(ch)
			err := task.Await(ctx)
			s.NoError(err)
		}()

		select {
		case <-ch:
			s.FailNow("task done before index state set to finish")
		case <-time.After(time.Second):
		}

		done.Store(true)

		select {
		case <-ch:
		case <-time.After(time.Second):
			s.FailNow("task not done after index set finished")
		}
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		fieldName := fmt.Sprintf("field_%s", s.randString(4))
		indexName := fmt.Sprintf("idx_%s", s.randString(6))

		s.mock.EXPECT().CreateIndex(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.CreateIndex(ctx, NewCreateIndexOption(collectionName, fieldName, index.NewHNSWIndex(entity.L2, 32, 128)).WithIndexName(indexName))
		s.Error(err)
	})
}

func (s *IndexSuite) TestListIndexes() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		s.mock.EXPECT().DescribeIndex(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, dir *milvuspb.DescribeIndexRequest) (*milvuspb.DescribeIndexResponse, error) {
			s.Equal(collectionName, dir.GetCollectionName())
			return &milvuspb.DescribeIndexResponse{
				Status: merr.Success(),
				IndexDescriptions: []*milvuspb.IndexDescription{
					{IndexName: "test_idx"},
				},
			}, nil
		}).Once()

		names, err := s.client.ListIndexes(ctx, NewListIndexOption(collectionName))
		s.NoError(err)
		s.ElementsMatch([]string{"test_idx"}, names)
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		s.mock.EXPECT().DescribeIndex(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.ListIndexes(ctx, NewListIndexOption(collectionName))
		s.Error(err)
	})
}

func (s *IndexSuite) TestDescribeIndex() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		indexName := fmt.Sprintf("idx_%s", s.randString(6))
		s.mock.EXPECT().DescribeIndex(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, dir *milvuspb.DescribeIndexRequest) (*milvuspb.DescribeIndexResponse, error) {
			s.Equal(collectionName, dir.GetCollectionName())
			s.Equal(indexName, dir.GetIndexName())
			return &milvuspb.DescribeIndexResponse{
				Status: merr.Success(),
				IndexDescriptions: []*milvuspb.IndexDescription{
					{IndexName: indexName, Params: []*commonpb.KeyValuePair{
						{Key: index.IndexTypeKey, Value: string(index.HNSW)},
					}},
				},
			}, nil
		}).Once()

		index, err := s.client.DescribeIndex(ctx, NewDescribeIndexOption(collectionName, indexName))
		s.NoError(err)
		s.Equal(indexName, index.Name())
	})

	s.Run("no_index_found", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		indexName := fmt.Sprintf("idx_%s", s.randString(6))
		s.mock.EXPECT().DescribeIndex(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, dir *milvuspb.DescribeIndexRequest) (*milvuspb.DescribeIndexResponse, error) {
			s.Equal(collectionName, dir.GetCollectionName())
			s.Equal(indexName, dir.GetIndexName())
			return &milvuspb.DescribeIndexResponse{
				Status:            merr.Success(),
				IndexDescriptions: []*milvuspb.IndexDescription{},
			}, nil
		}).Once()

		_, err := s.client.DescribeIndex(ctx, NewDescribeIndexOption(collectionName, indexName))
		s.Error(err)
		s.ErrorIs(err, merr.ErrIndexNotFound)
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		indexName := fmt.Sprintf("idx_%s", s.randString(6))
		s.mock.EXPECT().DescribeIndex(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.DescribeIndex(ctx, NewDescribeIndexOption(collectionName, indexName))
		s.Error(err)
	})
}

func (s *IndexSuite) TestDropIndexOption() {
	collectionName := fmt.Sprintf("coll_%s", s.randString(6))
	indexName := fmt.Sprintf("idx_%s", s.randString(6))
	opt := NewDropIndexOption(collectionName, indexName)
	req := opt.Request()

	s.Equal(collectionName, req.GetCollectionName())
	s.Equal(indexName, req.GetIndexName())
}

func (s *IndexSuite) TestDropIndex() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	s.Run("success", func() {
		s.mock.EXPECT().DropIndex(mock.Anything, mock.Anything).Return(merr.Success(), nil).Once()

		err := s.client.DropIndex(ctx, NewDropIndexOption("testCollection", "testIndex"))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().DropIndex(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.DropIndex(ctx, NewDropIndexOption("testCollection", "testIndex"))
		s.Error(err)
	})
}

func (s *IndexSuite) TestAlterIndexProperties() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		indexName := fmt.Sprintf("idx_%s", s.randString(6))

		key := fmt.Sprintf("key_%s", s.randString(6))
		val := fmt.Sprintf("val_%s", s.randString(6))

		s.mock.EXPECT().AlterIndex(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, air *milvuspb.AlterIndexRequest) (*commonpb.Status, error) {
			s.Equal(collectionName, air.GetCollectionName())
			s.Equal(indexName, air.GetIndexName())
			if s.Len(air.GetExtraParams(), 1) {
				kv := air.GetExtraParams()[0]
				s.Equal(key, kv.GetKey())
				s.Equal(val, kv.GetValue())
			}

			return merr.Success(), nil
		}).Once()

		err := s.client.AlterIndexProperties(ctx, NewAlterIndexPropertiesOption(collectionName, indexName).WithProperty(key, val))
		s.NoError(err)
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		indexName := fmt.Sprintf("idx_%s", s.randString(6))

		key := fmt.Sprintf("key_%s", s.randString(6))
		val := fmt.Sprintf("val_%s", s.randString(6))
		s.mock.EXPECT().AlterIndex(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.AlterIndexProperties(ctx, NewAlterIndexPropertiesOption(collectionName, indexName).WithProperty(key, val))
		s.Error(err)
	})
}

func (s *IndexSuite) TestDropIndexProperties() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		indexName := fmt.Sprintf("idx_%s", s.randString(6))

		key := fmt.Sprintf("key_%s", s.randString(6))

		s.mock.EXPECT().AlterIndex(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, air *milvuspb.AlterIndexRequest) (*commonpb.Status, error) {
			s.Equal(collectionName, air.GetCollectionName())
			s.Equal(indexName, air.GetIndexName())
			s.ElementsMatch([]string{key}, air.GetDeleteKeys())

			return merr.Success(), nil
		}).Once()

		err := s.client.DropIndexProperties(ctx, NewDropIndexPropertiesOption(collectionName, indexName, key))
		s.NoError(err)
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		indexName := fmt.Sprintf("idx_%s", s.randString(6))

		key := fmt.Sprintf("coll_%s", s.randString(6))
		s.mock.EXPECT().AlterIndex(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.DropIndexProperties(ctx, NewDropIndexPropertiesOption(collectionName, indexName, key))
		s.Error(err)
	})
}

func TestIndex(t *testing.T) {
	suite.Run(t, new(IndexSuite))
}



---
File: /milvusclient/index.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"fmt"
	"time"

	"google.golang.org/grpc"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/index"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type CreateIndexTask struct {
	client         *Client
	collectionName string
	fieldName      string
	indexName      string
	interval       time.Duration
}

func (t *CreateIndexTask) Await(ctx context.Context) error {
	timer := time.NewTimer(t.interval)
	defer timer.Stop()
	for {
		select {
		case <-timer.C:
			finished := false
			err := t.client.callService(func(milvusService milvuspb.MilvusServiceClient) error {
				resp, err := milvusService.DescribeIndex(ctx, &milvuspb.DescribeIndexRequest{
					CollectionName: t.collectionName,
					FieldName:      t.fieldName,
					IndexName:      t.indexName,
				})
				err = merr.CheckRPCCall(resp, err)
				if err != nil {
					return err
				}

				for _, info := range resp.GetIndexDescriptions() {
					if (t.indexName == "" && info.GetFieldName() == t.fieldName) || t.indexName == info.GetIndexName() {
						switch info.GetState() {
						case commonpb.IndexState_Finished:
							finished = true
							return nil
						case commonpb.IndexState_Failed:
							return fmt.Errorf("create index failed, reason: %s", info.GetIndexStateFailReason())
						}
					}
				}
				return nil
			})
			if err != nil {
				return err
			}
			if finished {
				return nil
			}
			if !timer.Stop() {
				select {
				case <-timer.C:
				default:
				}
			}
			timer.Reset(t.interval)
		case <-ctx.Done():
			return ctx.Err()
		}
	}
}

func (c *Client) CreateIndex(ctx context.Context, option CreateIndexOption, callOptions ...grpc.CallOption) (*CreateIndexTask, error) {
	req := option.Request()
	var task *CreateIndexTask

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.CreateIndex(ctx, req, callOptions...)
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}

		task = &CreateIndexTask{
			client:         c,
			collectionName: req.GetCollectionName(),
			fieldName:      req.GetFieldName(),
			indexName:      req.GetIndexName(),
			interval:       time.Millisecond * 100,
		}

		return nil
	})

	return task, err
}

func (c *Client) ListIndexes(ctx context.Context, opt ListIndexOption, callOptions ...grpc.CallOption) ([]string, error) {
	req := opt.Request()

	var indexes []string

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DescribeIndex(ctx, req, callOptions...)
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}
		for _, idxDef := range resp.GetIndexDescriptions() {
			if opt.Matches(idxDef) {
				indexes = append(indexes, idxDef.GetIndexName())
			}
		}
		return nil
	})
	return indexes, err
}

type IndexDescription struct {
	index.Index
	State            index.IndexState
	PendingIndexRows int64
	TotalRows        int64
	IndexedRows      int64
}

func (c *Client) DescribeIndex(ctx context.Context, opt DescribeIndexOption, callOptions ...grpc.CallOption) (IndexDescription, error) {
	req := opt.Request()
	var idx IndexDescription

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DescribeIndex(ctx, req, callOptions...)
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}

		if len(resp.GetIndexDescriptions()) == 0 {
			return merr.WrapErrIndexNotFound(req.GetIndexName())
		}
		for _, idxDef := range resp.GetIndexDescriptions() {
			if idxDef.GetIndexName() == req.GetIndexName() {
				idx = IndexDescription{
					Index:            index.NewGenericIndex(idxDef.GetIndexName(), entity.KvPairsMap(idxDef.GetParams())),
					State:            index.IndexState(idxDef.GetState()),
					PendingIndexRows: idxDef.GetPendingIndexRows(),
					IndexedRows:      idxDef.GetIndexedRows(),
					TotalRows:        idxDef.GetTotalRows(),
				}
			}
		}
		return nil
	})

	return idx, err
}

func (c *Client) DropIndex(ctx context.Context, opt DropIndexOption, callOptions ...grpc.CallOption) error {
	req := opt.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DropIndex(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) AlterIndexProperties(ctx context.Context, opt AlterIndexPropertiesOption, callOptions ...grpc.CallOption) error {
	req := opt.Request()
	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.AlterIndex(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) DropIndexProperties(ctx context.Context, opt DropIndexPropertiesOption, callOptions ...grpc.CallOption) error {
	req := opt.Request()
	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.AlterIndex(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}



---
File: /milvusclient/interceptors_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"math"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"google.golang.org/grpc"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
)

var (
	mockInvokerError error
	mockInvokerReply interface{}
	mockInvokeTimes  = 0
)

var mockInvoker grpc.UnaryInvoker = func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, opts ...grpc.CallOption) error {
	mockInvokeTimes++
	return mockInvokerError
}

func resetMockInvokeTimes() {
	mockInvokeTimes = 0
}

func TestRateLimitInterceptor(t *testing.T) {
	maxRetry := uint(3)
	maxBackoff := 3 * time.Second
	inter := RetryOnRateLimitInterceptor(maxRetry, maxBackoff, func(ctx context.Context, attempt uint) time.Duration {
		return 60 * time.Millisecond * time.Duration(math.Pow(2, float64(attempt)))
	})

	ctx := context.Background()

	// with retry
	mockInvokerReply = &commonpb.Status{ErrorCode: commonpb.ErrorCode_RateLimit}
	resetMockInvokeTimes()
	err := inter(ctx, "", nil, mockInvokerReply, nil, mockInvoker)
	assert.NoError(t, err)
	assert.Equal(t, maxRetry, uint(mockInvokeTimes))

	// without retry
	ctx1 := context.WithValue(ctx, RetryOnRateLimit, false)
	resetMockInvokeTimes()
	err = inter(ctx1, "", nil, mockInvokerReply, nil, mockInvoker)
	assert.NoError(t, err)
	assert.Equal(t, uint(1), uint(mockInvokeTimes))
}



---
File: /milvusclient/interceptors.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"time"

	grpc_retry "github.com/grpc-ecosystem/go-grpc-middleware/retry"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
)

const (
	authorizationHeader = `authorization`

	identifierHeader = `identifier`

	databaseHeader = `dbname`
)

func (c *Client) MetadataUnaryInterceptor() grpc.UnaryClientInterceptor {
	return func(ctx context.Context, method string, req, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
		ctx = c.metadata(ctx)
		ctx = c.state(ctx)

		return invoker(ctx, method, req, reply, cc, opts...)
	}
}

func (c *Client) metadata(ctx context.Context) context.Context {
	for k, v := range c.metadataHeaders {
		ctx = metadata.AppendToOutgoingContext(ctx, k, v)
	}
	return ctx
}

func (c *Client) state(ctx context.Context) context.Context {
	c.stateMut.RLock()
	defer c.stateMut.RUnlock()

	if c.currentDB != "" {
		ctx = metadata.AppendToOutgoingContext(ctx, databaseHeader, c.currentDB)
	}
	if c.identifier != "" {
		ctx = metadata.AppendToOutgoingContext(ctx, identifierHeader, c.identifier)
	}

	return ctx
}

// ref: https://github.com/grpc-ecosystem/go-grpc-middleware

type ctxKey int

const (
	RetryOnRateLimit ctxKey = iota
)

// RetryOnRateLimitInterceptor returns a new retrying unary client interceptor.
func RetryOnRateLimitInterceptor(maxRetry uint, maxBackoff time.Duration, backoffFunc grpc_retry.BackoffFuncContext) grpc.UnaryClientInterceptor {
	return func(parentCtx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
		if maxRetry == 0 {
			return invoker(parentCtx, method, req, reply, cc, opts...)
		}
		var lastErr error
		for attempt := uint(0); attempt < maxRetry; attempt++ {
			_, err := waitRetryBackoff(parentCtx, attempt, maxBackoff, backoffFunc)
			if err != nil {
				return err
			}
			lastErr = invoker(parentCtx, method, req, reply, cc, opts...)
			rspStatus := getResultStatus(reply)
			if retryOnRateLimit(parentCtx) && rspStatus.GetErrorCode() == commonpb.ErrorCode_RateLimit {
				continue
			}
			return lastErr
		}
		return lastErr
	}
}

func retryOnRateLimit(ctx context.Context) bool {
	retry, ok := ctx.Value(RetryOnRateLimit).(bool)
	if !ok {
		return true // default true
	}
	return retry
}

// getResultStatus returns status of response.
func getResultStatus(reply interface{}) *commonpb.Status {
	switch r := reply.(type) {
	case *commonpb.Status:
		return r
	case *milvuspb.MutationResult:
		return r.GetStatus()
	case *milvuspb.BoolResponse:
		return r.GetStatus()
	case *milvuspb.SearchResults:
		return r.GetStatus()
	case *milvuspb.QueryResults:
		return r.GetStatus()
	case *milvuspb.FlushResponse:
		return r.GetStatus()
	default:
		return nil
	}
}

func contextErrToGrpcErr(err error) error {
	switch err {
	case context.DeadlineExceeded:
		return status.Error(codes.DeadlineExceeded, err.Error())
	case context.Canceled:
		return status.Error(codes.Canceled, err.Error())
	default:
		return status.Error(codes.Unknown, err.Error())
	}
}

func waitRetryBackoff(parentCtx context.Context, attempt uint, maxBackoff time.Duration, backoffFunc grpc_retry.BackoffFuncContext) (time.Duration, error) {
	var waitTime time.Duration
	if attempt > 0 {
		waitTime = backoffFunc(parentCtx, attempt)
	}
	if waitTime > 0 {
		if waitTime > maxBackoff {
			waitTime = maxBackoff
		}
		timer := time.NewTimer(waitTime)
		select {
		case <-parentCtx.Done():
			timer.Stop()
			return waitTime, contextErrToGrpcErr(parentCtx.Err())
		case <-timer.C:
		}
	}
	return waitTime, nil
}



---
File: /milvusclient/maintenance_example_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// nolint
package milvusclient_test

import (
	"context"
	"fmt"

	"github.com/milvus-io/milvus/client/v2/milvusclient"
)

func ExampleClient_GetLoadState() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collectionName := `customized_setup_1`

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	loadState, err := cli.GetLoadState(ctx, milvusclient.NewGetLoadStateOption(collectionName))
	if err != nil {
		// handle err
	}
	fmt.Println(loadState)
}

func ExampleClient_RefreshLoad() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collectionName := `customized_setup_1`

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	loadTask, err := cli.RefreshLoad(ctx, milvusclient.NewRefreshLoadOption(collectionName))
	if err != nil {
		// handle err
	}
	err = loadTask.Await(ctx)
	if err != nil {
		// handler err
	}
}

func ExampleClient_Compact() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	collectionName := `customized_setup_1`

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	compactID, err := cli.Compact(ctx, milvusclient.NewCompactOption(collectionName))
	if err != nil {
		// handle err
	}
	fmt.Println(compactID)
}

func ExampleClient_GetCompactionState() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	compactID := int64(123)

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	state, err := cli.GetCompactionState(ctx, milvusclient.NewGetCompactionStateOption(compactID))
	if err != nil {
		// handle err
	}
	fmt.Println(state)
}

func ExampleClient_Flush() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle err
	}

	collectionName := `customized_setup_1`

	task, err := cli.Flush(ctx, milvusclient.NewFlushOption(collectionName))
	if err != nil {
		// handle err
	}

	err = task.Await(ctx)
	if err != nil {
		// handle err
	}
}



---
File: /milvusclient/maintenance_options.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"time"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
)

type LoadCollectionOption interface {
	Request() *milvuspb.LoadCollectionRequest
	CheckInterval() time.Duration
	IsRefresh() bool
}

type loadCollectionOption struct {
	collectionName       string
	interval             time.Duration
	replicaNum           int
	loadFields           []string
	skipLoadDynamicField bool
	isRefresh            bool
	resourceGroups       []string
}

func (opt *loadCollectionOption) Request() *milvuspb.LoadCollectionRequest {
	return &milvuspb.LoadCollectionRequest{
		CollectionName:       opt.collectionName,
		ReplicaNumber:        int32(opt.replicaNum),
		LoadFields:           opt.loadFields,
		SkipLoadDynamicField: opt.skipLoadDynamicField,
		ResourceGroups:       opt.resourceGroups,
	}
}

func (opt *loadCollectionOption) CheckInterval() time.Duration {
	return opt.interval
}

func (opt *loadCollectionOption) IsRefresh() bool {
	return opt.isRefresh
}

func (opt *loadCollectionOption) WithReplica(num int) *loadCollectionOption {
	opt.replicaNum = num
	return opt
}

func (opt *loadCollectionOption) WithResourceGroup(resourceGroups ...string) *loadCollectionOption {
	opt.resourceGroups = resourceGroups
	return opt
}

func (opt *loadCollectionOption) WithLoadFields(loadFields ...string) *loadCollectionOption {
	opt.loadFields = loadFields
	return opt
}

func (opt *loadCollectionOption) WithSkipLoadDynamicField(skipFlag bool) *loadCollectionOption {
	opt.skipLoadDynamicField = skipFlag
	return opt
}

func (opt *loadCollectionOption) WithRefresh(isRefresh bool) *loadCollectionOption {
	opt.isRefresh = isRefresh
	return opt
}

func NewLoadCollectionOption(collectionName string) *loadCollectionOption {
	return &loadCollectionOption{
		collectionName: collectionName,
		replicaNum:     1,
		interval:       time.Millisecond * 200,
	}
}

type LoadPartitionsOption interface {
	Request() *milvuspb.LoadPartitionsRequest
	CheckInterval() time.Duration
	IsRefresh() bool
}

var _ LoadPartitionsOption = (*loadPartitionsOption)(nil)

type loadPartitionsOption struct {
	collectionName       string
	partitionNames       []string
	interval             time.Duration
	replicaNum           int
	resourceGroups       []string
	loadFields           []string
	skipLoadDynamicField bool
	isRefresh            bool
}

func (opt *loadPartitionsOption) Request() *milvuspb.LoadPartitionsRequest {
	return &milvuspb.LoadPartitionsRequest{
		CollectionName:       opt.collectionName,
		PartitionNames:       opt.partitionNames,
		ReplicaNumber:        int32(opt.replicaNum),
		LoadFields:           opt.loadFields,
		SkipLoadDynamicField: opt.skipLoadDynamicField,
		ResourceGroups:       opt.resourceGroups,
	}
}

func (opt *loadPartitionsOption) CheckInterval() time.Duration {
	return opt.interval
}

func (opt *loadPartitionsOption) IsRefresh() bool {
	return opt.isRefresh
}

func (opt *loadPartitionsOption) WithReplica(num int) *loadPartitionsOption {
	opt.replicaNum = num
	return opt
}

func (opt *loadPartitionsOption) WithResourceGroup(resourceGroups ...string) *loadPartitionsOption {
	opt.resourceGroups = resourceGroups
	return opt
}

func (opt *loadPartitionsOption) WithLoadFields(loadFields ...string) *loadPartitionsOption {
	opt.loadFields = loadFields
	return opt
}

func (opt *loadPartitionsOption) WithSkipLoadDynamicField(skipFlag bool) *loadPartitionsOption {
	opt.skipLoadDynamicField = skipFlag
	return opt
}

func (opt *loadPartitionsOption) WithRefresh(isRefresh bool) *loadPartitionsOption {
	opt.isRefresh = isRefresh
	return opt
}

func NewLoadPartitionsOption(collectionName string, partitionsNames ...string) *loadPartitionsOption {
	return &loadPartitionsOption{
		collectionName: collectionName,
		partitionNames: partitionsNames,
		replicaNum:     1,
		interval:       time.Millisecond * 200,
	}
}

type GetLoadStateOption interface {
	Request() *milvuspb.GetLoadStateRequest
	ProgressRequest() *milvuspb.GetLoadingProgressRequest
}

type getLoadStateOption struct {
	collectionName string
	partitionNames []string
}

func (opt *getLoadStateOption) Request() *milvuspb.GetLoadStateRequest {
	return &milvuspb.GetLoadStateRequest{
		CollectionName: opt.collectionName,
		PartitionNames: opt.partitionNames,
	}
}

func (opt *getLoadStateOption) ProgressRequest() *milvuspb.GetLoadingProgressRequest {
	return &milvuspb.GetLoadingProgressRequest{
		CollectionName: opt.collectionName,
		PartitionNames: opt.partitionNames,
	}
}

func NewGetLoadStateOption(collectionName string, partitionNames ...string) *getLoadStateOption {
	return &getLoadStateOption{
		collectionName: collectionName,
		partitionNames: partitionNames,
	}
}

type RefreshLoadOption interface {
	Request() *milvuspb.LoadCollectionRequest
	CheckInterval() time.Duration
}

type refreshLoadOption struct {
	collectionName string
	checkInterval  time.Duration
}

func (opt *refreshLoadOption) Request() *milvuspb.LoadCollectionRequest {
	return &milvuspb.LoadCollectionRequest{
		CollectionName: opt.collectionName,
		Refresh:        true,
	}
}

func (opt *refreshLoadOption) CheckInterval() time.Duration {
	return opt.checkInterval
}

func NewRefreshLoadOption(collectionName string) *refreshLoadOption {
	return &refreshLoadOption{
		collectionName: collectionName,
		checkInterval:  time.Millisecond * 200,
	}
}

type ReleaseCollectionOption interface {
	Request() *milvuspb.ReleaseCollectionRequest
}

var _ ReleaseCollectionOption = (*releaseCollectionOption)(nil)

type releaseCollectionOption struct {
	collectionName string
}

func (opt *releaseCollectionOption) Request() *milvuspb.ReleaseCollectionRequest {
	return &milvuspb.ReleaseCollectionRequest{
		CollectionName: opt.collectionName,
	}
}

func NewReleaseCollectionOption(collectionName string) *releaseCollectionOption {
	return &releaseCollectionOption{
		collectionName: collectionName,
	}
}

type ReleasePartitionsOption interface {
	Request() *milvuspb.ReleasePartitionsRequest
}

var _ ReleasePartitionsOption = (*releasePartitionsOption)(nil)

type releasePartitionsOption struct {
	collectionName string
	partitionNames []string
}

func (opt *releasePartitionsOption) Request() *milvuspb.ReleasePartitionsRequest {
	return &milvuspb.ReleasePartitionsRequest{
		CollectionName: opt.collectionName,
		PartitionNames: opt.partitionNames,
	}
}

func NewReleasePartitionsOptions(collectionName string, partitionNames ...string) *releasePartitionsOption {
	return &releasePartitionsOption{
		collectionName: collectionName,
		partitionNames: partitionNames,
	}
}

type FlushOption interface {
	Request() *milvuspb.FlushRequest
	CollectionName() string
	CheckInterval() time.Duration
}

type flushOption struct {
	collectionName string
	interval       time.Duration
}

func (opt *flushOption) Request() *milvuspb.FlushRequest {
	return &milvuspb.FlushRequest{
		CollectionNames: []string{opt.collectionName},
	}
}

func (opt *flushOption) CollectionName() string {
	return opt.collectionName
}

func (opt *flushOption) CheckInterval() time.Duration {
	return opt.interval
}

func NewFlushOption(collName string) *flushOption {
	return &flushOption{
		collectionName: collName,
		interval:       time.Millisecond * 200,
	}
}

type CompactOption interface {
	Request() *milvuspb.ManualCompactionRequest
}

type compactOption struct {
	collectionName string
}

func (opt *compactOption) Request() *milvuspb.ManualCompactionRequest {
	return &milvuspb.ManualCompactionRequest{
		CollectionName: opt.collectionName,
	}
}

func NewCompactOption(collectionName string) *compactOption {
	return &compactOption{
		collectionName: collectionName,
	}
}

type GetCompactionStateOption interface {
	Request() *milvuspb.GetCompactionStateRequest
}

type getCompactionStateOption struct {
	compactionID int64
}

func (opt *getCompactionStateOption) Request() *milvuspb.GetCompactionStateRequest {
	return &milvuspb.GetCompactionStateRequest{
		CompactionID: opt.compactionID,
	}
}

func NewGetCompactionStateOption(compactionID int64) *getCompactionStateOption {
	return &getCompactionStateOption{
		compactionID: compactionID,
	}
}



---
File: /milvusclient/maintenance_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"fmt"
	"math/rand"
	"testing"
	"time"

	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"go.uber.org/atomic"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type MaintenanceSuite struct {
	MockSuiteBase
}

func (s *MaintenanceSuite) TestLoadCollection() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		fieldNames := []string{"id", "part", "vector"}
		replicaNum := rand.Intn(3) + 1
		rgs := []string{"rg1", "rg2"}

		done := atomic.NewBool(false)
		s.mock.EXPECT().LoadCollection(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, lcr *milvuspb.LoadCollectionRequest) (*commonpb.Status, error) {
			s.Equal(collectionName, lcr.GetCollectionName())
			s.ElementsMatch(fieldNames, lcr.GetLoadFields())
			s.True(lcr.SkipLoadDynamicField)
			s.EqualValues(replicaNum, lcr.GetReplicaNumber())
			s.ElementsMatch(rgs, lcr.GetResourceGroups())
			return merr.Success(), nil
		}).Once()
		s.mock.EXPECT().GetLoadingProgress(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, glpr *milvuspb.GetLoadingProgressRequest) (*milvuspb.GetLoadingProgressResponse, error) {
			s.Equal(collectionName, glpr.GetCollectionName())

			progress := int64(50)
			if done.Load() {
				progress = 100
			}

			return &milvuspb.GetLoadingProgressResponse{
				Status:   merr.Success(),
				Progress: progress,
			}, nil
		})
		defer s.mock.EXPECT().GetLoadingProgress(mock.Anything, mock.Anything).Unset()

		task, err := s.client.LoadCollection(ctx, NewLoadCollectionOption(collectionName).
			WithReplica(replicaNum).
			WithResourceGroup(rgs...).
			WithLoadFields(fieldNames...).
			WithSkipLoadDynamicField(true))
		s.NoError(err)

		ch := make(chan struct{})
		go func() {
			defer close(ch)
			err := task.Await(ctx)
			s.NoError(err)
		}()

		select {
		case <-ch:
			s.FailNow("task done before index state set to finish")
		case <-time.After(time.Second):
		}

		done.Store(true)

		select {
		case <-ch:
		case <-time.After(time.Second):
			s.FailNow("task not done after index set finished")
		}
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))

		s.mock.EXPECT().LoadCollection(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.LoadCollection(ctx, NewLoadCollectionOption(collectionName))
		s.Error(err)
	})
}

func (s *MaintenanceSuite) TestLoadPartitions() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))
		fieldNames := []string{"id", "part", "vector"}
		replicaNum := rand.Intn(3) + 1
		rgs := []string{"rg1", "rg2"}

		done := atomic.NewBool(false)
		s.mock.EXPECT().LoadPartitions(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, lpr *milvuspb.LoadPartitionsRequest) (*commonpb.Status, error) {
			s.Equal(collectionName, lpr.GetCollectionName())
			s.ElementsMatch([]string{partitionName}, lpr.GetPartitionNames())
			s.ElementsMatch(fieldNames, lpr.GetLoadFields())
			s.True(lpr.SkipLoadDynamicField)
			s.EqualValues(replicaNum, lpr.GetReplicaNumber())
			s.ElementsMatch(rgs, lpr.GetResourceGroups())
			return merr.Success(), nil
		}).Once()
		s.mock.EXPECT().GetLoadingProgress(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, glpr *milvuspb.GetLoadingProgressRequest) (*milvuspb.GetLoadingProgressResponse, error) {
			s.Equal(collectionName, glpr.GetCollectionName())
			s.ElementsMatch([]string{partitionName}, glpr.GetPartitionNames())

			progress := int64(50)
			if done.Load() {
				progress = 100
			}

			return &milvuspb.GetLoadingProgressResponse{
				Status:   merr.Success(),
				Progress: progress,
			}, nil
		})
		defer s.mock.EXPECT().GetLoadingProgress(mock.Anything, mock.Anything).Unset()

		task, err := s.client.LoadPartitions(ctx, NewLoadPartitionsOption(collectionName, partitionName).
			WithReplica(replicaNum).
			WithResourceGroup(rgs...).
			WithLoadFields(fieldNames...).
			WithSkipLoadDynamicField(true))
		s.NoError(err)

		ch := make(chan struct{})
		go func() {
			defer close(ch)
			err := task.Await(ctx)
			s.NoError(err)
		}()

		select {
		case <-ch:
			s.FailNow("task done before index state set to finish")
		case <-time.After(time.Second):
		}

		done.Store(true)

		select {
		case <-ch:
		case <-time.After(time.Second):
			s.FailNow("task not done after index set finished")
		}
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))

		s.mock.EXPECT().LoadPartitions(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.LoadPartitions(ctx, NewLoadPartitionsOption(collectionName, partitionName))
		s.Error(err)
	})
}

func (s *MaintenanceSuite) TestReleaseCollection() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		s.mock.EXPECT().ReleaseCollection(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, rcr *milvuspb.ReleaseCollectionRequest) (*commonpb.Status, error) {
			s.Equal(collectionName, rcr.GetCollectionName())
			return merr.Success(), nil
		}).Once()

		err := s.client.ReleaseCollection(ctx, NewReleaseCollectionOption(collectionName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		s.mock.EXPECT().ReleaseCollection(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.ReleaseCollection(ctx, NewReleaseCollectionOption(collectionName))
		s.Error(err)
	})
}

func (s *MaintenanceSuite) TestReleasePartitions() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))
		s.mock.EXPECT().ReleasePartitions(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, rpr *milvuspb.ReleasePartitionsRequest) (*commonpb.Status, error) {
			s.Equal(collectionName, rpr.GetCollectionName())
			s.ElementsMatch([]string{partitionName}, rpr.GetPartitionNames())
			return merr.Success(), nil
		}).Once()

		err := s.client.ReleasePartitions(ctx, NewReleasePartitionsOptions(collectionName, partitionName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))
		s.mock.EXPECT().ReleasePartitions(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.ReleasePartitions(ctx, NewReleasePartitionsOptions(collectionName, partitionName))
		s.Error(err)
	})
}

func (s *MaintenanceSuite) TestFlush() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))

		done := atomic.NewBool(false)
		s.mock.EXPECT().Flush(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, fr *milvuspb.FlushRequest) (*milvuspb.FlushResponse, error) {
			s.ElementsMatch([]string{collectionName}, fr.GetCollectionNames())
			return &milvuspb.FlushResponse{
				Status: merr.Success(),
				CollSegIDs: map[string]*schemapb.LongArray{
					collectionName: {Data: []int64{1, 2, 3}},
				},
				CollFlushTs: map[string]uint64{collectionName: 321},
			}, nil
		}).Once()
		s.mock.EXPECT().GetFlushState(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, gfsr *milvuspb.GetFlushStateRequest) (*milvuspb.GetFlushStateResponse, error) {
			s.Equal(collectionName, gfsr.GetCollectionName())
			s.ElementsMatch([]int64{1, 2, 3}, gfsr.GetSegmentIDs())
			s.EqualValues(321, gfsr.GetFlushTs())
			return &milvuspb.GetFlushStateResponse{
				Status:  merr.Success(),
				Flushed: done.Load(),
			}, nil
		})
		defer s.mock.EXPECT().GetFlushState(mock.Anything, mock.Anything).Unset()

		task, err := s.client.Flush(ctx, NewFlushOption(collectionName))
		s.NoError(err)

		ch := make(chan struct{})
		go func() {
			defer close(ch)
			err := task.Await(ctx)
			s.NoError(err)
		}()

		select {
		case <-ch:
			s.FailNow("task done before index state set to finish")
		case <-time.After(time.Second):
		}

		done.Store(true)

		select {
		case <-ch:
		case <-time.After(time.Second):
			s.FailNow("task not done after index set finished")
		}
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))

		s.mock.EXPECT().Flush(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.Flush(ctx, NewFlushOption(collectionName))
		s.Error(err)
	})
}

func (s *MaintenanceSuite) TestRefreshLoad() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))

		done := atomic.NewBool(false)
		s.mock.EXPECT().LoadCollection(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, lcr *milvuspb.LoadCollectionRequest) (*commonpb.Status, error) {
			s.Equal(collectionName, lcr.GetCollectionName())
			s.True(lcr.GetRefresh())
			return merr.Success(), nil
		}).Once()
		s.mock.EXPECT().GetLoadingProgress(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, glpr *milvuspb.GetLoadingProgressRequest) (*milvuspb.GetLoadingProgressResponse, error) {
			s.Equal(collectionName, glpr.GetCollectionName())

			progress := int64(50)
			if done.Load() {
				progress = 100
			}

			return &milvuspb.GetLoadingProgressResponse{
				Status:          merr.Success(),
				RefreshProgress: progress,
			}, nil
		})
		defer s.mock.EXPECT().GetLoadingProgress(mock.Anything, mock.Anything).Unset()

		task, err := s.client.RefreshLoad(ctx, NewRefreshLoadOption(collectionName))
		s.NoError(err)

		ch := make(chan struct{})
		go func() {
			defer close(ch)
			err := task.Await(ctx)
			s.NoError(err)
		}()

		select {
		case <-ch:
			s.FailNow("task done before index state set to finish")
		case <-time.After(time.Second):
		}

		done.Store(true)

		select {
		case <-ch:
		case <-time.After(time.Second):
			s.FailNow("task not done after index set finished")
		}
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))

		s.mock.EXPECT().LoadCollection(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.RefreshLoad(ctx, NewRefreshLoadOption(collectionName))
		s.Error(err)
	})
}

func (s *MaintenanceSuite) TestCompact() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		compactID := rand.Int63()

		s.mock.EXPECT().ManualCompaction(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, cr *milvuspb.ManualCompactionRequest) (*milvuspb.ManualCompactionResponse, error) {
			s.Equal(collectionName, cr.GetCollectionName())
			return &milvuspb.ManualCompactionResponse{
				CompactionID: compactID,
			}, nil
		}).Once()

		id, err := s.client.Compact(ctx, NewCompactOption(collectionName))
		s.NoError(err)
		s.Equal(compactID, id)
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))

		s.mock.EXPECT().ManualCompaction(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.Compact(ctx, NewCompactOption(collectionName))
		s.Error(err)
	})
}

func (s *MaintenanceSuite) TestGetCompactionState() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		compactID := rand.Int63()

		s.mock.EXPECT().GetCompactionState(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, gcsr *milvuspb.GetCompactionStateRequest) (*milvuspb.GetCompactionStateResponse, error) {
			s.Equal(compactID, gcsr.GetCompactionID())
			return &milvuspb.GetCompactionStateResponse{
				Status: merr.Success(),
				State:  commonpb.CompactionState_Completed,
			}, nil
		}).Once()

		state, err := s.client.GetCompactionState(ctx, NewGetCompactionStateOption(compactID))
		s.NoError(err)
		s.Equal(entity.CompactionStateCompleted, state)
	})

	s.Run("failure", func() {
		compactID := rand.Int63()

		s.mock.EXPECT().GetCompactionState(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.GetCompactionState(ctx, NewGetCompactionStateOption(compactID))
		s.Error(err)
	})
}

func (s *MaintenanceSuite) TestGetLoadState() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		progress := rand.Int63n(100)

		s.mock.EXPECT().GetLoadState(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, glsr *milvuspb.GetLoadStateRequest) (*milvuspb.GetLoadStateResponse, error) {
			s.Equal(collectionName, glsr.GetCollectionName())
			return &milvuspb.GetLoadStateResponse{
				Status: merr.Success(),
				State:  commonpb.LoadState_LoadStateLoading,
			}, nil
		}).Once()
		s.mock.EXPECT().GetLoadingProgress(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, glpr *milvuspb.GetLoadingProgressRequest) (*milvuspb.GetLoadingProgressResponse, error) {
			s.Equal(collectionName, glpr.GetCollectionName())
			return &milvuspb.GetLoadingProgressResponse{
				Status:   merr.Success(),
				Progress: progress,
			}, nil
		}).Once()

		state, err := s.client.GetLoadState(ctx, NewGetLoadStateOption(collectionName))
		s.NoError(err)
		s.Equal(entity.LoadStateLoading, state.State)
		s.Equal(progress, state.Progress)
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))

		s.mock.EXPECT().GetLoadState(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.GetLoadState(ctx, NewGetLoadStateOption(collectionName))
		s.Error(err)
	})
}

func TestMaintenance(t *testing.T) {
	suite.Run(t, new(MaintenanceSuite))
}



---
File: /milvusclient/maintenance.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"time"

	"google.golang.org/grpc"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus-proto/go-api/v2/msgpb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type LoadTask struct {
	client         *Client
	collectionName string
	partitionNames []string
	interval       time.Duration
	refresh        bool
}

func (t *LoadTask) Await(ctx context.Context) error {
	timer := time.NewTimer(t.interval)
	defer timer.Stop()
	for {
		select {
		case <-timer.C:
			loaded := false
			refreshed := false
			err := t.client.callService(func(milvusService milvuspb.MilvusServiceClient) error {
				resp, err := milvusService.GetLoadingProgress(ctx, &milvuspb.GetLoadingProgressRequest{
					CollectionName: t.collectionName,
					PartitionNames: t.partitionNames,
				})
				if err = merr.CheckRPCCall(resp, err); err != nil {
					return err
				}
				loaded = resp.GetProgress() == 100
				refreshed = resp.GetRefreshProgress() == 100
				return nil
			})
			if err != nil {
				return err
			}
			if (loaded && !t.refresh) || (refreshed && t.refresh) {
				return nil
			}
			if !timer.Stop() {
				select {
				case <-timer.C:
				default:
				}
			}
			timer.Reset(t.interval)
		case <-ctx.Done():
			return ctx.Err()
		}
	}
}

func (c *Client) LoadCollection(ctx context.Context, option LoadCollectionOption, callOptions ...grpc.CallOption) (LoadTask, error) {
	req := option.Request()

	var task LoadTask

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.LoadCollection(ctx, req, callOptions...)
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}

		task = LoadTask{
			client:         c,
			collectionName: req.GetCollectionName(),
			interval:       option.CheckInterval(),
			refresh:        option.IsRefresh(),
		}

		return nil
	})
	return task, err
}

func (c *Client) LoadPartitions(ctx context.Context, option LoadPartitionsOption, callOptions ...grpc.CallOption) (LoadTask, error) {
	req := option.Request()

	var task LoadTask

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.LoadPartitions(ctx, req, callOptions...)
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}

		task = LoadTask{
			client:         c,
			collectionName: req.GetCollectionName(),
			partitionNames: req.GetPartitionNames(),
			interval:       option.CheckInterval(),
			refresh:        option.IsRefresh(),
		}

		return nil
	})
	return task, err
}

func (c *Client) GetLoadState(ctx context.Context, option GetLoadStateOption, callOptions ...grpc.CallOption) (entity.LoadState, error) {
	req := option.Request()

	var state entity.LoadState
	var err error

	if err = c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.GetLoadState(ctx, req, callOptions...)
		state.State = entity.LoadStateCode(resp.GetState())
		return merr.CheckRPCCall(resp, err)
	}); err != nil {
		return state, err
	}

	// get progress if state is loading
	if state.State == entity.LoadStateLoading {
		err = c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
			resp, err := milvusService.GetLoadingProgress(ctx, option.ProgressRequest(), callOptions...)
			if err := merr.CheckRPCCall(resp, err); err != nil {
				return err
			}

			state.Progress = resp.GetProgress()
			return nil
		})
	}
	return state, err
}

func (c *Client) ReleaseCollection(ctx context.Context, option ReleaseCollectionOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.ReleaseCollection(ctx, req, callOptions...)

		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) ReleasePartitions(ctx context.Context, option ReleasePartitionsOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.ReleasePartitions(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) RefreshLoad(ctx context.Context, option RefreshLoadOption, callOptions ...grpc.CallOption) (LoadTask, error) {
	req := option.Request()
	var task LoadTask

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.LoadCollection(ctx, req, callOptions...)
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}
		task = LoadTask{
			client:         c,
			collectionName: req.GetCollectionName(),
			interval:       option.CheckInterval(),
			refresh:        true,
		}
		return nil
	})
	return task, err
}

type FlushTask struct {
	client             *Client
	collectionName     string
	segmentIDs         []int64
	flusheSegIDs       []int64
	flushTs            uint64
	channelCheckpoints map[string]*msgpb.MsgPosition
	interval           time.Duration
}

func (t *FlushTask) Await(ctx context.Context) error {
	timer := time.NewTimer(t.interval)
	defer timer.Stop()
	for {
		select {
		case <-timer.C:
			flushed := false
			err := t.client.callService(func(milvusService milvuspb.MilvusServiceClient) error {
				resp, err := milvusService.GetFlushState(ctx, &milvuspb.GetFlushStateRequest{
					CollectionName: t.collectionName,
					SegmentIDs:     t.segmentIDs,
					FlushTs:        t.flushTs,
				})
				err = merr.CheckRPCCall(resp, err)
				if err != nil {
					return err
				}
				flushed = resp.GetFlushed()

				return nil
			})
			if err != nil {
				return err
			}
			if flushed {
				return nil
			}
			if !timer.Stop() {
				select {
				case <-timer.C:
				default:
				}
			}
			timer.Reset(t.interval)
		case <-ctx.Done():
			return ctx.Err()
		}
	}
}

func (t *FlushTask) GetFlushStats() (segIDs []int64, flushSegIDs []int64, flushTs uint64, channelCheckpoints map[string]*msgpb.MsgPosition) {
	return t.segmentIDs, t.flusheSegIDs, t.flushTs, t.channelCheckpoints
}

func (c *Client) Flush(ctx context.Context, option FlushOption, callOptions ...grpc.CallOption) (*FlushTask, error) {
	req := option.Request()
	collectionName := option.CollectionName()
	var task *FlushTask

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.Flush(ctx, req, callOptions...)
		err = merr.CheckRPCCall(resp, err)
		if err != nil {
			return err
		}

		task = &FlushTask{
			client:             c,
			collectionName:     collectionName,
			segmentIDs:         resp.GetCollSegIDs()[collectionName].GetData(),
			flusheSegIDs:       resp.GetFlushCollSegIDs()[collectionName].GetData(),
			flushTs:            resp.GetCollFlushTs()[collectionName],
			channelCheckpoints: resp.GetChannelCps(),
			interval:           option.CheckInterval(),
		}

		return nil
	})
	return task, err
}

func (c *Client) Compact(ctx context.Context, option CompactOption, callOptions ...grpc.CallOption) (int64, error) {
	req := option.Request()

	var jobID int64

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.ManualCompaction(ctx, req, callOptions...)
		jobID = resp.GetCompactionID()
		return merr.CheckRPCCall(resp, err)
	})
	return jobID, err
}

func (c *Client) GetCompactionState(ctx context.Context, option GetCompactionStateOption, callOptions ...grpc.CallOption) (entity.CompactionState, error) {
	req := option.Request()

	var status entity.CompactionState

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.GetCompactionState(ctx, req, callOptions...)
		status = entity.CompactionState(resp.GetState())
		return merr.CheckRPCCall(resp, err)
	})
	return status, err
}



---
File: /milvusclient/mock_milvus_server_test.go
---

// Code generated by mockery v2.53.3. DO NOT EDIT.

package milvusclient

import (
	context "context"

	commonpb "github.com/milvus-io/milvus-proto/go-api/v2/commonpb"

	federpb "github.com/milvus-io/milvus-proto/go-api/v2/federpb"

	milvuspb "github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"

	mock "github.com/stretchr/testify/mock"
)

// MilvusServiceServer is an autogenerated mock type for the MilvusServiceServer type
type MilvusServiceServer struct {
	mock.Mock
}

type MilvusServiceServer_Expecter struct {
	mock *mock.Mock
}

func (_m *MilvusServiceServer) EXPECT() *MilvusServiceServer_Expecter {
	return &MilvusServiceServer_Expecter{mock: &_m.Mock}
}

// AllocTimestamp provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) AllocTimestamp(_a0 context.Context, _a1 *milvuspb.AllocTimestampRequest) (*milvuspb.AllocTimestampResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for AllocTimestamp")
	}

	var r0 *milvuspb.AllocTimestampResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.AllocTimestampRequest) (*milvuspb.AllocTimestampResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.AllocTimestampRequest) *milvuspb.AllocTimestampResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.AllocTimestampResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.AllocTimestampRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_AllocTimestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AllocTimestamp'
type MilvusServiceServer_AllocTimestamp_Call struct {
	*mock.Call
}

// AllocTimestamp is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.AllocTimestampRequest
func (_e *MilvusServiceServer_Expecter) AllocTimestamp(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_AllocTimestamp_Call {
	return &MilvusServiceServer_AllocTimestamp_Call{Call: _e.mock.On("AllocTimestamp", _a0, _a1)}
}

func (_c *MilvusServiceServer_AllocTimestamp_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.AllocTimestampRequest)) *MilvusServiceServer_AllocTimestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.AllocTimestampRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_AllocTimestamp_Call) Return(_a0 *milvuspb.AllocTimestampResponse, _a1 error) *MilvusServiceServer_AllocTimestamp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_AllocTimestamp_Call) RunAndReturn(run func(context.Context, *milvuspb.AllocTimestampRequest) (*milvuspb.AllocTimestampResponse, error)) *MilvusServiceServer_AllocTimestamp_Call {
	_c.Call.Return(run)
	return _c
}

// AlterAlias provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) AlterAlias(_a0 context.Context, _a1 *milvuspb.AlterAliasRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for AlterAlias")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.AlterAliasRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.AlterAliasRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.AlterAliasRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_AlterAlias_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AlterAlias'
type MilvusServiceServer_AlterAlias_Call struct {
	*mock.Call
}

// AlterAlias is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.AlterAliasRequest
func (_e *MilvusServiceServer_Expecter) AlterAlias(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_AlterAlias_Call {
	return &MilvusServiceServer_AlterAlias_Call{Call: _e.mock.On("AlterAlias", _a0, _a1)}
}

func (_c *MilvusServiceServer_AlterAlias_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.AlterAliasRequest)) *MilvusServiceServer_AlterAlias_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.AlterAliasRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_AlterAlias_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_AlterAlias_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_AlterAlias_Call) RunAndReturn(run func(context.Context, *milvuspb.AlterAliasRequest) (*commonpb.Status, error)) *MilvusServiceServer_AlterAlias_Call {
	_c.Call.Return(run)
	return _c
}

// AlterCollection provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) AlterCollection(_a0 context.Context, _a1 *milvuspb.AlterCollectionRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for AlterCollection")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.AlterCollectionRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.AlterCollectionRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.AlterCollectionRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_AlterCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AlterCollection'
type MilvusServiceServer_AlterCollection_Call struct {
	*mock.Call
}

// AlterCollection is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.AlterCollectionRequest
func (_e *MilvusServiceServer_Expecter) AlterCollection(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_AlterCollection_Call {
	return &MilvusServiceServer_AlterCollection_Call{Call: _e.mock.On("AlterCollection", _a0, _a1)}
}

func (_c *MilvusServiceServer_AlterCollection_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.AlterCollectionRequest)) *MilvusServiceServer_AlterCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.AlterCollectionRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_AlterCollection_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_AlterCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_AlterCollection_Call) RunAndReturn(run func(context.Context, *milvuspb.AlterCollectionRequest) (*commonpb.Status, error)) *MilvusServiceServer_AlterCollection_Call {
	_c.Call.Return(run)
	return _c
}

// AlterCollectionField provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) AlterCollectionField(_a0 context.Context, _a1 *milvuspb.AlterCollectionFieldRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for AlterCollectionField")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.AlterCollectionFieldRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.AlterCollectionFieldRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.AlterCollectionFieldRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_AlterCollectionField_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AlterCollectionField'
type MilvusServiceServer_AlterCollectionField_Call struct {
	*mock.Call
}

// AlterCollectionField is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.AlterCollectionFieldRequest
func (_e *MilvusServiceServer_Expecter) AlterCollectionField(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_AlterCollectionField_Call {
	return &MilvusServiceServer_AlterCollectionField_Call{Call: _e.mock.On("AlterCollectionField", _a0, _a1)}
}

func (_c *MilvusServiceServer_AlterCollectionField_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.AlterCollectionFieldRequest)) *MilvusServiceServer_AlterCollectionField_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.AlterCollectionFieldRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_AlterCollectionField_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_AlterCollectionField_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_AlterCollectionField_Call) RunAndReturn(run func(context.Context, *milvuspb.AlterCollectionFieldRequest) (*commonpb.Status, error)) *MilvusServiceServer_AlterCollectionField_Call {
	_c.Call.Return(run)
	return _c
}

// AlterDatabase provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) AlterDatabase(_a0 context.Context, _a1 *milvuspb.AlterDatabaseRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for AlterDatabase")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.AlterDatabaseRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.AlterDatabaseRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.AlterDatabaseRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_AlterDatabase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AlterDatabase'
type MilvusServiceServer_AlterDatabase_Call struct {
	*mock.Call
}

// AlterDatabase is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.AlterDatabaseRequest
func (_e *MilvusServiceServer_Expecter) AlterDatabase(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_AlterDatabase_Call {
	return &MilvusServiceServer_AlterDatabase_Call{Call: _e.mock.On("AlterDatabase", _a0, _a1)}
}

func (_c *MilvusServiceServer_AlterDatabase_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.AlterDatabaseRequest)) *MilvusServiceServer_AlterDatabase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.AlterDatabaseRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_AlterDatabase_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_AlterDatabase_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_AlterDatabase_Call) RunAndReturn(run func(context.Context, *milvuspb.AlterDatabaseRequest) (*commonpb.Status, error)) *MilvusServiceServer_AlterDatabase_Call {
	_c.Call.Return(run)
	return _c
}

// AlterIndex provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) AlterIndex(_a0 context.Context, _a1 *milvuspb.AlterIndexRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for AlterIndex")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.AlterIndexRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.AlterIndexRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.AlterIndexRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_AlterIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AlterIndex'
type MilvusServiceServer_AlterIndex_Call struct {
	*mock.Call
}

// AlterIndex is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.AlterIndexRequest
func (_e *MilvusServiceServer_Expecter) AlterIndex(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_AlterIndex_Call {
	return &MilvusServiceServer_AlterIndex_Call{Call: _e.mock.On("AlterIndex", _a0, _a1)}
}

func (_c *MilvusServiceServer_AlterIndex_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.AlterIndexRequest)) *MilvusServiceServer_AlterIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.AlterIndexRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_AlterIndex_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_AlterIndex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_AlterIndex_Call) RunAndReturn(run func(context.Context, *milvuspb.AlterIndexRequest) (*commonpb.Status, error)) *MilvusServiceServer_AlterIndex_Call {
	_c.Call.Return(run)
	return _c
}

// BackupRBAC provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) BackupRBAC(_a0 context.Context, _a1 *milvuspb.BackupRBACMetaRequest) (*milvuspb.BackupRBACMetaResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for BackupRBAC")
	}

	var r0 *milvuspb.BackupRBACMetaResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.BackupRBACMetaRequest) (*milvuspb.BackupRBACMetaResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.BackupRBACMetaRequest) *milvuspb.BackupRBACMetaResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.BackupRBACMetaResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.BackupRBACMetaRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_BackupRBAC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BackupRBAC'
type MilvusServiceServer_BackupRBAC_Call struct {
	*mock.Call
}

// BackupRBAC is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.BackupRBACMetaRequest
func (_e *MilvusServiceServer_Expecter) BackupRBAC(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_BackupRBAC_Call {
	return &MilvusServiceServer_BackupRBAC_Call{Call: _e.mock.On("BackupRBAC", _a0, _a1)}
}

func (_c *MilvusServiceServer_BackupRBAC_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.BackupRBACMetaRequest)) *MilvusServiceServer_BackupRBAC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.BackupRBACMetaRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_BackupRBAC_Call) Return(_a0 *milvuspb.BackupRBACMetaResponse, _a1 error) *MilvusServiceServer_BackupRBAC_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_BackupRBAC_Call) RunAndReturn(run func(context.Context, *milvuspb.BackupRBACMetaRequest) (*milvuspb.BackupRBACMetaResponse, error)) *MilvusServiceServer_BackupRBAC_Call {
	_c.Call.Return(run)
	return _c
}

// CalcDistance provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) CalcDistance(_a0 context.Context, _a1 *milvuspb.CalcDistanceRequest) (*milvuspb.CalcDistanceResults, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for CalcDistance")
	}

	var r0 *milvuspb.CalcDistanceResults
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CalcDistanceRequest) (*milvuspb.CalcDistanceResults, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CalcDistanceRequest) *milvuspb.CalcDistanceResults); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.CalcDistanceResults)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.CalcDistanceRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_CalcDistance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CalcDistance'
type MilvusServiceServer_CalcDistance_Call struct {
	*mock.Call
}

// CalcDistance is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.CalcDistanceRequest
func (_e *MilvusServiceServer_Expecter) CalcDistance(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_CalcDistance_Call {
	return &MilvusServiceServer_CalcDistance_Call{Call: _e.mock.On("CalcDistance", _a0, _a1)}
}

func (_c *MilvusServiceServer_CalcDistance_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.CalcDistanceRequest)) *MilvusServiceServer_CalcDistance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.CalcDistanceRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_CalcDistance_Call) Return(_a0 *milvuspb.CalcDistanceResults, _a1 error) *MilvusServiceServer_CalcDistance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_CalcDistance_Call) RunAndReturn(run func(context.Context, *milvuspb.CalcDistanceRequest) (*milvuspb.CalcDistanceResults, error)) *MilvusServiceServer_CalcDistance_Call {
	_c.Call.Return(run)
	return _c
}

// CheckHealth provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) CheckHealth(_a0 context.Context, _a1 *milvuspb.CheckHealthRequest) (*milvuspb.CheckHealthResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for CheckHealth")
	}

	var r0 *milvuspb.CheckHealthResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CheckHealthRequest) (*milvuspb.CheckHealthResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CheckHealthRequest) *milvuspb.CheckHealthResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.CheckHealthResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.CheckHealthRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_CheckHealth_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckHealth'
type MilvusServiceServer_CheckHealth_Call struct {
	*mock.Call
}

// CheckHealth is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.CheckHealthRequest
func (_e *MilvusServiceServer_Expecter) CheckHealth(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_CheckHealth_Call {
	return &MilvusServiceServer_CheckHealth_Call{Call: _e.mock.On("CheckHealth", _a0, _a1)}
}

func (_c *MilvusServiceServer_CheckHealth_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.CheckHealthRequest)) *MilvusServiceServer_CheckHealth_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.CheckHealthRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_CheckHealth_Call) Return(_a0 *milvuspb.CheckHealthResponse, _a1 error) *MilvusServiceServer_CheckHealth_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_CheckHealth_Call) RunAndReturn(run func(context.Context, *milvuspb.CheckHealthRequest) (*milvuspb.CheckHealthResponse, error)) *MilvusServiceServer_CheckHealth_Call {
	_c.Call.Return(run)
	return _c
}

// Connect provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) Connect(_a0 context.Context, _a1 *milvuspb.ConnectRequest) (*milvuspb.ConnectResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Connect")
	}

	var r0 *milvuspb.ConnectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ConnectRequest) (*milvuspb.ConnectResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ConnectRequest) *milvuspb.ConnectResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.ConnectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.ConnectRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_Connect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connect'
type MilvusServiceServer_Connect_Call struct {
	*mock.Call
}

// Connect is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.ConnectRequest
func (_e *MilvusServiceServer_Expecter) Connect(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_Connect_Call {
	return &MilvusServiceServer_Connect_Call{Call: _e.mock.On("Connect", _a0, _a1)}
}

func (_c *MilvusServiceServer_Connect_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.ConnectRequest)) *MilvusServiceServer_Connect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.ConnectRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_Connect_Call) Return(_a0 *milvuspb.ConnectResponse, _a1 error) *MilvusServiceServer_Connect_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_Connect_Call) RunAndReturn(run func(context.Context, *milvuspb.ConnectRequest) (*milvuspb.ConnectResponse, error)) *MilvusServiceServer_Connect_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAlias provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) CreateAlias(_a0 context.Context, _a1 *milvuspb.CreateAliasRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for CreateAlias")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreateAliasRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreateAliasRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.CreateAliasRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_CreateAlias_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAlias'
type MilvusServiceServer_CreateAlias_Call struct {
	*mock.Call
}

// CreateAlias is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.CreateAliasRequest
func (_e *MilvusServiceServer_Expecter) CreateAlias(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_CreateAlias_Call {
	return &MilvusServiceServer_CreateAlias_Call{Call: _e.mock.On("CreateAlias", _a0, _a1)}
}

func (_c *MilvusServiceServer_CreateAlias_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.CreateAliasRequest)) *MilvusServiceServer_CreateAlias_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.CreateAliasRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_CreateAlias_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_CreateAlias_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_CreateAlias_Call) RunAndReturn(run func(context.Context, *milvuspb.CreateAliasRequest) (*commonpb.Status, error)) *MilvusServiceServer_CreateAlias_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCollection provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) CreateCollection(_a0 context.Context, _a1 *milvuspb.CreateCollectionRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for CreateCollection")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreateCollectionRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreateCollectionRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.CreateCollectionRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_CreateCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCollection'
type MilvusServiceServer_CreateCollection_Call struct {
	*mock.Call
}

// CreateCollection is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.CreateCollectionRequest
func (_e *MilvusServiceServer_Expecter) CreateCollection(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_CreateCollection_Call {
	return &MilvusServiceServer_CreateCollection_Call{Call: _e.mock.On("CreateCollection", _a0, _a1)}
}

func (_c *MilvusServiceServer_CreateCollection_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.CreateCollectionRequest)) *MilvusServiceServer_CreateCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.CreateCollectionRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_CreateCollection_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_CreateCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_CreateCollection_Call) RunAndReturn(run func(context.Context, *milvuspb.CreateCollectionRequest) (*commonpb.Status, error)) *MilvusServiceServer_CreateCollection_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCredential provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) CreateCredential(_a0 context.Context, _a1 *milvuspb.CreateCredentialRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for CreateCredential")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreateCredentialRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreateCredentialRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.CreateCredentialRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_CreateCredential_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCredential'
type MilvusServiceServer_CreateCredential_Call struct {
	*mock.Call
}

// CreateCredential is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.CreateCredentialRequest
func (_e *MilvusServiceServer_Expecter) CreateCredential(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_CreateCredential_Call {
	return &MilvusServiceServer_CreateCredential_Call{Call: _e.mock.On("CreateCredential", _a0, _a1)}
}

func (_c *MilvusServiceServer_CreateCredential_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.CreateCredentialRequest)) *MilvusServiceServer_CreateCredential_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.CreateCredentialRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_CreateCredential_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_CreateCredential_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_CreateCredential_Call) RunAndReturn(run func(context.Context, *milvuspb.CreateCredentialRequest) (*commonpb.Status, error)) *MilvusServiceServer_CreateCredential_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDatabase provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) CreateDatabase(_a0 context.Context, _a1 *milvuspb.CreateDatabaseRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for CreateDatabase")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreateDatabaseRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreateDatabaseRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.CreateDatabaseRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_CreateDatabase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDatabase'
type MilvusServiceServer_CreateDatabase_Call struct {
	*mock.Call
}

// CreateDatabase is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.CreateDatabaseRequest
func (_e *MilvusServiceServer_Expecter) CreateDatabase(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_CreateDatabase_Call {
	return &MilvusServiceServer_CreateDatabase_Call{Call: _e.mock.On("CreateDatabase", _a0, _a1)}
}

func (_c *MilvusServiceServer_CreateDatabase_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.CreateDatabaseRequest)) *MilvusServiceServer_CreateDatabase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.CreateDatabaseRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_CreateDatabase_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_CreateDatabase_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_CreateDatabase_Call) RunAndReturn(run func(context.Context, *milvuspb.CreateDatabaseRequest) (*commonpb.Status, error)) *MilvusServiceServer_CreateDatabase_Call {
	_c.Call.Return(run)
	return _c
}

// CreateIndex provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) CreateIndex(_a0 context.Context, _a1 *milvuspb.CreateIndexRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for CreateIndex")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreateIndexRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreateIndexRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.CreateIndexRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_CreateIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIndex'
type MilvusServiceServer_CreateIndex_Call struct {
	*mock.Call
}

// CreateIndex is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.CreateIndexRequest
func (_e *MilvusServiceServer_Expecter) CreateIndex(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_CreateIndex_Call {
	return &MilvusServiceServer_CreateIndex_Call{Call: _e.mock.On("CreateIndex", _a0, _a1)}
}

func (_c *MilvusServiceServer_CreateIndex_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.CreateIndexRequest)) *MilvusServiceServer_CreateIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.CreateIndexRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_CreateIndex_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_CreateIndex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_CreateIndex_Call) RunAndReturn(run func(context.Context, *milvuspb.CreateIndexRequest) (*commonpb.Status, error)) *MilvusServiceServer_CreateIndex_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePartition provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) CreatePartition(_a0 context.Context, _a1 *milvuspb.CreatePartitionRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for CreatePartition")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreatePartitionRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreatePartitionRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.CreatePartitionRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_CreatePartition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePartition'
type MilvusServiceServer_CreatePartition_Call struct {
	*mock.Call
}

// CreatePartition is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.CreatePartitionRequest
func (_e *MilvusServiceServer_Expecter) CreatePartition(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_CreatePartition_Call {
	return &MilvusServiceServer_CreatePartition_Call{Call: _e.mock.On("CreatePartition", _a0, _a1)}
}

func (_c *MilvusServiceServer_CreatePartition_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.CreatePartitionRequest)) *MilvusServiceServer_CreatePartition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.CreatePartitionRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_CreatePartition_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_CreatePartition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_CreatePartition_Call) RunAndReturn(run func(context.Context, *milvuspb.CreatePartitionRequest) (*commonpb.Status, error)) *MilvusServiceServer_CreatePartition_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePrivilegeGroup provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) CreatePrivilegeGroup(_a0 context.Context, _a1 *milvuspb.CreatePrivilegeGroupRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for CreatePrivilegeGroup")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreatePrivilegeGroupRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreatePrivilegeGroupRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.CreatePrivilegeGroupRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_CreatePrivilegeGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePrivilegeGroup'
type MilvusServiceServer_CreatePrivilegeGroup_Call struct {
	*mock.Call
}

// CreatePrivilegeGroup is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.CreatePrivilegeGroupRequest
func (_e *MilvusServiceServer_Expecter) CreatePrivilegeGroup(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_CreatePrivilegeGroup_Call {
	return &MilvusServiceServer_CreatePrivilegeGroup_Call{Call: _e.mock.On("CreatePrivilegeGroup", _a0, _a1)}
}

func (_c *MilvusServiceServer_CreatePrivilegeGroup_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.CreatePrivilegeGroupRequest)) *MilvusServiceServer_CreatePrivilegeGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.CreatePrivilegeGroupRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_CreatePrivilegeGroup_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_CreatePrivilegeGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_CreatePrivilegeGroup_Call) RunAndReturn(run func(context.Context, *milvuspb.CreatePrivilegeGroupRequest) (*commonpb.Status, error)) *MilvusServiceServer_CreatePrivilegeGroup_Call {
	_c.Call.Return(run)
	return _c
}

// CreateResourceGroup provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) CreateResourceGroup(_a0 context.Context, _a1 *milvuspb.CreateResourceGroupRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for CreateResourceGroup")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreateResourceGroupRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreateResourceGroupRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.CreateResourceGroupRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_CreateResourceGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateResourceGroup'
type MilvusServiceServer_CreateResourceGroup_Call struct {
	*mock.Call
}

// CreateResourceGroup is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.CreateResourceGroupRequest
func (_e *MilvusServiceServer_Expecter) CreateResourceGroup(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_CreateResourceGroup_Call {
	return &MilvusServiceServer_CreateResourceGroup_Call{Call: _e.mock.On("CreateResourceGroup", _a0, _a1)}
}

func (_c *MilvusServiceServer_CreateResourceGroup_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.CreateResourceGroupRequest)) *MilvusServiceServer_CreateResourceGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.CreateResourceGroupRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_CreateResourceGroup_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_CreateResourceGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_CreateResourceGroup_Call) RunAndReturn(run func(context.Context, *milvuspb.CreateResourceGroupRequest) (*commonpb.Status, error)) *MilvusServiceServer_CreateResourceGroup_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRole provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) CreateRole(_a0 context.Context, _a1 *milvuspb.CreateRoleRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for CreateRole")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreateRoleRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.CreateRoleRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.CreateRoleRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_CreateRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRole'
type MilvusServiceServer_CreateRole_Call struct {
	*mock.Call
}

// CreateRole is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.CreateRoleRequest
func (_e *MilvusServiceServer_Expecter) CreateRole(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_CreateRole_Call {
	return &MilvusServiceServer_CreateRole_Call{Call: _e.mock.On("CreateRole", _a0, _a1)}
}

func (_c *MilvusServiceServer_CreateRole_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.CreateRoleRequest)) *MilvusServiceServer_CreateRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.CreateRoleRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_CreateRole_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_CreateRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_CreateRole_Call) RunAndReturn(run func(context.Context, *milvuspb.CreateRoleRequest) (*commonpb.Status, error)) *MilvusServiceServer_CreateRole_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) Delete(_a0 context.Context, _a1 *milvuspb.DeleteRequest) (*milvuspb.MutationResult, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 *milvuspb.MutationResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DeleteRequest) (*milvuspb.MutationResult, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DeleteRequest) *milvuspb.MutationResult); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.MutationResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DeleteRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MilvusServiceServer_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DeleteRequest
func (_e *MilvusServiceServer_Expecter) Delete(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_Delete_Call {
	return &MilvusServiceServer_Delete_Call{Call: _e.mock.On("Delete", _a0, _a1)}
}

func (_c *MilvusServiceServer_Delete_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DeleteRequest)) *MilvusServiceServer_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DeleteRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_Delete_Call) Return(_a0 *milvuspb.MutationResult, _a1 error) *MilvusServiceServer_Delete_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_Delete_Call) RunAndReturn(run func(context.Context, *milvuspb.DeleteRequest) (*milvuspb.MutationResult, error)) *MilvusServiceServer_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCredential provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DeleteCredential(_a0 context.Context, _a1 *milvuspb.DeleteCredentialRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCredential")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DeleteCredentialRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DeleteCredentialRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DeleteCredentialRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DeleteCredential_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCredential'
type MilvusServiceServer_DeleteCredential_Call struct {
	*mock.Call
}

// DeleteCredential is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DeleteCredentialRequest
func (_e *MilvusServiceServer_Expecter) DeleteCredential(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DeleteCredential_Call {
	return &MilvusServiceServer_DeleteCredential_Call{Call: _e.mock.On("DeleteCredential", _a0, _a1)}
}

func (_c *MilvusServiceServer_DeleteCredential_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DeleteCredentialRequest)) *MilvusServiceServer_DeleteCredential_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DeleteCredentialRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DeleteCredential_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_DeleteCredential_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DeleteCredential_Call) RunAndReturn(run func(context.Context, *milvuspb.DeleteCredentialRequest) (*commonpb.Status, error)) *MilvusServiceServer_DeleteCredential_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeAlias provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DescribeAlias(_a0 context.Context, _a1 *milvuspb.DescribeAliasRequest) (*milvuspb.DescribeAliasResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DescribeAlias")
	}

	var r0 *milvuspb.DescribeAliasResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DescribeAliasRequest) (*milvuspb.DescribeAliasResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DescribeAliasRequest) *milvuspb.DescribeAliasResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.DescribeAliasResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DescribeAliasRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DescribeAlias_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeAlias'
type MilvusServiceServer_DescribeAlias_Call struct {
	*mock.Call
}

// DescribeAlias is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DescribeAliasRequest
func (_e *MilvusServiceServer_Expecter) DescribeAlias(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DescribeAlias_Call {
	return &MilvusServiceServer_DescribeAlias_Call{Call: _e.mock.On("DescribeAlias", _a0, _a1)}
}

func (_c *MilvusServiceServer_DescribeAlias_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DescribeAliasRequest)) *MilvusServiceServer_DescribeAlias_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DescribeAliasRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DescribeAlias_Call) Return(_a0 *milvuspb.DescribeAliasResponse, _a1 error) *MilvusServiceServer_DescribeAlias_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DescribeAlias_Call) RunAndReturn(run func(context.Context, *milvuspb.DescribeAliasRequest) (*milvuspb.DescribeAliasResponse, error)) *MilvusServiceServer_DescribeAlias_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeCollection provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DescribeCollection(_a0 context.Context, _a1 *milvuspb.DescribeCollectionRequest) (*milvuspb.DescribeCollectionResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DescribeCollection")
	}

	var r0 *milvuspb.DescribeCollectionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DescribeCollectionRequest) (*milvuspb.DescribeCollectionResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DescribeCollectionRequest) *milvuspb.DescribeCollectionResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.DescribeCollectionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DescribeCollectionRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DescribeCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeCollection'
type MilvusServiceServer_DescribeCollection_Call struct {
	*mock.Call
}

// DescribeCollection is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DescribeCollectionRequest
func (_e *MilvusServiceServer_Expecter) DescribeCollection(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DescribeCollection_Call {
	return &MilvusServiceServer_DescribeCollection_Call{Call: _e.mock.On("DescribeCollection", _a0, _a1)}
}

func (_c *MilvusServiceServer_DescribeCollection_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DescribeCollectionRequest)) *MilvusServiceServer_DescribeCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DescribeCollectionRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DescribeCollection_Call) Return(_a0 *milvuspb.DescribeCollectionResponse, _a1 error) *MilvusServiceServer_DescribeCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DescribeCollection_Call) RunAndReturn(run func(context.Context, *milvuspb.DescribeCollectionRequest) (*milvuspb.DescribeCollectionResponse, error)) *MilvusServiceServer_DescribeCollection_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeDatabase provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DescribeDatabase(_a0 context.Context, _a1 *milvuspb.DescribeDatabaseRequest) (*milvuspb.DescribeDatabaseResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DescribeDatabase")
	}

	var r0 *milvuspb.DescribeDatabaseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DescribeDatabaseRequest) (*milvuspb.DescribeDatabaseResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DescribeDatabaseRequest) *milvuspb.DescribeDatabaseResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.DescribeDatabaseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DescribeDatabaseRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DescribeDatabase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeDatabase'
type MilvusServiceServer_DescribeDatabase_Call struct {
	*mock.Call
}

// DescribeDatabase is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DescribeDatabaseRequest
func (_e *MilvusServiceServer_Expecter) DescribeDatabase(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DescribeDatabase_Call {
	return &MilvusServiceServer_DescribeDatabase_Call{Call: _e.mock.On("DescribeDatabase", _a0, _a1)}
}

func (_c *MilvusServiceServer_DescribeDatabase_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DescribeDatabaseRequest)) *MilvusServiceServer_DescribeDatabase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DescribeDatabaseRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DescribeDatabase_Call) Return(_a0 *milvuspb.DescribeDatabaseResponse, _a1 error) *MilvusServiceServer_DescribeDatabase_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DescribeDatabase_Call) RunAndReturn(run func(context.Context, *milvuspb.DescribeDatabaseRequest) (*milvuspb.DescribeDatabaseResponse, error)) *MilvusServiceServer_DescribeDatabase_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeIndex provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DescribeIndex(_a0 context.Context, _a1 *milvuspb.DescribeIndexRequest) (*milvuspb.DescribeIndexResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DescribeIndex")
	}

	var r0 *milvuspb.DescribeIndexResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DescribeIndexRequest) (*milvuspb.DescribeIndexResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DescribeIndexRequest) *milvuspb.DescribeIndexResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.DescribeIndexResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DescribeIndexRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DescribeIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeIndex'
type MilvusServiceServer_DescribeIndex_Call struct {
	*mock.Call
}

// DescribeIndex is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DescribeIndexRequest
func (_e *MilvusServiceServer_Expecter) DescribeIndex(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DescribeIndex_Call {
	return &MilvusServiceServer_DescribeIndex_Call{Call: _e.mock.On("DescribeIndex", _a0, _a1)}
}

func (_c *MilvusServiceServer_DescribeIndex_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DescribeIndexRequest)) *MilvusServiceServer_DescribeIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DescribeIndexRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DescribeIndex_Call) Return(_a0 *milvuspb.DescribeIndexResponse, _a1 error) *MilvusServiceServer_DescribeIndex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DescribeIndex_Call) RunAndReturn(run func(context.Context, *milvuspb.DescribeIndexRequest) (*milvuspb.DescribeIndexResponse, error)) *MilvusServiceServer_DescribeIndex_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeResourceGroup provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DescribeResourceGroup(_a0 context.Context, _a1 *milvuspb.DescribeResourceGroupRequest) (*milvuspb.DescribeResourceGroupResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DescribeResourceGroup")
	}

	var r0 *milvuspb.DescribeResourceGroupResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DescribeResourceGroupRequest) (*milvuspb.DescribeResourceGroupResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DescribeResourceGroupRequest) *milvuspb.DescribeResourceGroupResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.DescribeResourceGroupResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DescribeResourceGroupRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DescribeResourceGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeResourceGroup'
type MilvusServiceServer_DescribeResourceGroup_Call struct {
	*mock.Call
}

// DescribeResourceGroup is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DescribeResourceGroupRequest
func (_e *MilvusServiceServer_Expecter) DescribeResourceGroup(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DescribeResourceGroup_Call {
	return &MilvusServiceServer_DescribeResourceGroup_Call{Call: _e.mock.On("DescribeResourceGroup", _a0, _a1)}
}

func (_c *MilvusServiceServer_DescribeResourceGroup_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DescribeResourceGroupRequest)) *MilvusServiceServer_DescribeResourceGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DescribeResourceGroupRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DescribeResourceGroup_Call) Return(_a0 *milvuspb.DescribeResourceGroupResponse, _a1 error) *MilvusServiceServer_DescribeResourceGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DescribeResourceGroup_Call) RunAndReturn(run func(context.Context, *milvuspb.DescribeResourceGroupRequest) (*milvuspb.DescribeResourceGroupResponse, error)) *MilvusServiceServer_DescribeResourceGroup_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSegmentIndexData provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DescribeSegmentIndexData(_a0 context.Context, _a1 *federpb.DescribeSegmentIndexDataRequest) (*federpb.DescribeSegmentIndexDataResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSegmentIndexData")
	}

	var r0 *federpb.DescribeSegmentIndexDataResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *federpb.DescribeSegmentIndexDataRequest) (*federpb.DescribeSegmentIndexDataResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *federpb.DescribeSegmentIndexDataRequest) *federpb.DescribeSegmentIndexDataResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*federpb.DescribeSegmentIndexDataResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *federpb.DescribeSegmentIndexDataRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DescribeSegmentIndexData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSegmentIndexData'
type MilvusServiceServer_DescribeSegmentIndexData_Call struct {
	*mock.Call
}

// DescribeSegmentIndexData is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *federpb.DescribeSegmentIndexDataRequest
func (_e *MilvusServiceServer_Expecter) DescribeSegmentIndexData(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DescribeSegmentIndexData_Call {
	return &MilvusServiceServer_DescribeSegmentIndexData_Call{Call: _e.mock.On("DescribeSegmentIndexData", _a0, _a1)}
}

func (_c *MilvusServiceServer_DescribeSegmentIndexData_Call) Run(run func(_a0 context.Context, _a1 *federpb.DescribeSegmentIndexDataRequest)) *MilvusServiceServer_DescribeSegmentIndexData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*federpb.DescribeSegmentIndexDataRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DescribeSegmentIndexData_Call) Return(_a0 *federpb.DescribeSegmentIndexDataResponse, _a1 error) *MilvusServiceServer_DescribeSegmentIndexData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DescribeSegmentIndexData_Call) RunAndReturn(run func(context.Context, *federpb.DescribeSegmentIndexDataRequest) (*federpb.DescribeSegmentIndexDataResponse, error)) *MilvusServiceServer_DescribeSegmentIndexData_Call {
	_c.Call.Return(run)
	return _c
}

// DropAlias provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DropAlias(_a0 context.Context, _a1 *milvuspb.DropAliasRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DropAlias")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropAliasRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropAliasRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DropAliasRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DropAlias_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropAlias'
type MilvusServiceServer_DropAlias_Call struct {
	*mock.Call
}

// DropAlias is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DropAliasRequest
func (_e *MilvusServiceServer_Expecter) DropAlias(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DropAlias_Call {
	return &MilvusServiceServer_DropAlias_Call{Call: _e.mock.On("DropAlias", _a0, _a1)}
}

func (_c *MilvusServiceServer_DropAlias_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DropAliasRequest)) *MilvusServiceServer_DropAlias_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DropAliasRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DropAlias_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_DropAlias_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DropAlias_Call) RunAndReturn(run func(context.Context, *milvuspb.DropAliasRequest) (*commonpb.Status, error)) *MilvusServiceServer_DropAlias_Call {
	_c.Call.Return(run)
	return _c
}

// DropCollection provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DropCollection(_a0 context.Context, _a1 *milvuspb.DropCollectionRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DropCollection")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropCollectionRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropCollectionRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DropCollectionRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DropCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropCollection'
type MilvusServiceServer_DropCollection_Call struct {
	*mock.Call
}

// DropCollection is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DropCollectionRequest
func (_e *MilvusServiceServer_Expecter) DropCollection(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DropCollection_Call {
	return &MilvusServiceServer_DropCollection_Call{Call: _e.mock.On("DropCollection", _a0, _a1)}
}

func (_c *MilvusServiceServer_DropCollection_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DropCollectionRequest)) *MilvusServiceServer_DropCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DropCollectionRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DropCollection_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_DropCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DropCollection_Call) RunAndReturn(run func(context.Context, *milvuspb.DropCollectionRequest) (*commonpb.Status, error)) *MilvusServiceServer_DropCollection_Call {
	_c.Call.Return(run)
	return _c
}

// DropDatabase provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DropDatabase(_a0 context.Context, _a1 *milvuspb.DropDatabaseRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DropDatabase")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropDatabaseRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropDatabaseRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DropDatabaseRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DropDatabase_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropDatabase'
type MilvusServiceServer_DropDatabase_Call struct {
	*mock.Call
}

// DropDatabase is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DropDatabaseRequest
func (_e *MilvusServiceServer_Expecter) DropDatabase(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DropDatabase_Call {
	return &MilvusServiceServer_DropDatabase_Call{Call: _e.mock.On("DropDatabase", _a0, _a1)}
}

func (_c *MilvusServiceServer_DropDatabase_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DropDatabaseRequest)) *MilvusServiceServer_DropDatabase_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DropDatabaseRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DropDatabase_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_DropDatabase_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DropDatabase_Call) RunAndReturn(run func(context.Context, *milvuspb.DropDatabaseRequest) (*commonpb.Status, error)) *MilvusServiceServer_DropDatabase_Call {
	_c.Call.Return(run)
	return _c
}

// DropIndex provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DropIndex(_a0 context.Context, _a1 *milvuspb.DropIndexRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DropIndex")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropIndexRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropIndexRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DropIndexRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DropIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropIndex'
type MilvusServiceServer_DropIndex_Call struct {
	*mock.Call
}

// DropIndex is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DropIndexRequest
func (_e *MilvusServiceServer_Expecter) DropIndex(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DropIndex_Call {
	return &MilvusServiceServer_DropIndex_Call{Call: _e.mock.On("DropIndex", _a0, _a1)}
}

func (_c *MilvusServiceServer_DropIndex_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DropIndexRequest)) *MilvusServiceServer_DropIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DropIndexRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DropIndex_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_DropIndex_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DropIndex_Call) RunAndReturn(run func(context.Context, *milvuspb.DropIndexRequest) (*commonpb.Status, error)) *MilvusServiceServer_DropIndex_Call {
	_c.Call.Return(run)
	return _c
}

// DropPartition provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DropPartition(_a0 context.Context, _a1 *milvuspb.DropPartitionRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DropPartition")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropPartitionRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropPartitionRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DropPartitionRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DropPartition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropPartition'
type MilvusServiceServer_DropPartition_Call struct {
	*mock.Call
}

// DropPartition is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DropPartitionRequest
func (_e *MilvusServiceServer_Expecter) DropPartition(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DropPartition_Call {
	return &MilvusServiceServer_DropPartition_Call{Call: _e.mock.On("DropPartition", _a0, _a1)}
}

func (_c *MilvusServiceServer_DropPartition_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DropPartitionRequest)) *MilvusServiceServer_DropPartition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DropPartitionRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DropPartition_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_DropPartition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DropPartition_Call) RunAndReturn(run func(context.Context, *milvuspb.DropPartitionRequest) (*commonpb.Status, error)) *MilvusServiceServer_DropPartition_Call {
	_c.Call.Return(run)
	return _c
}

// DropPrivilegeGroup provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DropPrivilegeGroup(_a0 context.Context, _a1 *milvuspb.DropPrivilegeGroupRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DropPrivilegeGroup")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropPrivilegeGroupRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropPrivilegeGroupRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DropPrivilegeGroupRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DropPrivilegeGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropPrivilegeGroup'
type MilvusServiceServer_DropPrivilegeGroup_Call struct {
	*mock.Call
}

// DropPrivilegeGroup is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DropPrivilegeGroupRequest
func (_e *MilvusServiceServer_Expecter) DropPrivilegeGroup(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DropPrivilegeGroup_Call {
	return &MilvusServiceServer_DropPrivilegeGroup_Call{Call: _e.mock.On("DropPrivilegeGroup", _a0, _a1)}
}

func (_c *MilvusServiceServer_DropPrivilegeGroup_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DropPrivilegeGroupRequest)) *MilvusServiceServer_DropPrivilegeGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DropPrivilegeGroupRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DropPrivilegeGroup_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_DropPrivilegeGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DropPrivilegeGroup_Call) RunAndReturn(run func(context.Context, *milvuspb.DropPrivilegeGroupRequest) (*commonpb.Status, error)) *MilvusServiceServer_DropPrivilegeGroup_Call {
	_c.Call.Return(run)
	return _c
}

// DropResourceGroup provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DropResourceGroup(_a0 context.Context, _a1 *milvuspb.DropResourceGroupRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DropResourceGroup")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropResourceGroupRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropResourceGroupRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DropResourceGroupRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DropResourceGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropResourceGroup'
type MilvusServiceServer_DropResourceGroup_Call struct {
	*mock.Call
}

// DropResourceGroup is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DropResourceGroupRequest
func (_e *MilvusServiceServer_Expecter) DropResourceGroup(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DropResourceGroup_Call {
	return &MilvusServiceServer_DropResourceGroup_Call{Call: _e.mock.On("DropResourceGroup", _a0, _a1)}
}

func (_c *MilvusServiceServer_DropResourceGroup_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DropResourceGroupRequest)) *MilvusServiceServer_DropResourceGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DropResourceGroupRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DropResourceGroup_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_DropResourceGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DropResourceGroup_Call) RunAndReturn(run func(context.Context, *milvuspb.DropResourceGroupRequest) (*commonpb.Status, error)) *MilvusServiceServer_DropResourceGroup_Call {
	_c.Call.Return(run)
	return _c
}

// DropRole provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) DropRole(_a0 context.Context, _a1 *milvuspb.DropRoleRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for DropRole")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropRoleRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DropRoleRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DropRoleRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_DropRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DropRole'
type MilvusServiceServer_DropRole_Call struct {
	*mock.Call
}

// DropRole is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DropRoleRequest
func (_e *MilvusServiceServer_Expecter) DropRole(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_DropRole_Call {
	return &MilvusServiceServer_DropRole_Call{Call: _e.mock.On("DropRole", _a0, _a1)}
}

func (_c *MilvusServiceServer_DropRole_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DropRoleRequest)) *MilvusServiceServer_DropRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DropRoleRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_DropRole_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_DropRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_DropRole_Call) RunAndReturn(run func(context.Context, *milvuspb.DropRoleRequest) (*commonpb.Status, error)) *MilvusServiceServer_DropRole_Call {
	_c.Call.Return(run)
	return _c
}

// Dummy provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) Dummy(_a0 context.Context, _a1 *milvuspb.DummyRequest) (*milvuspb.DummyResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Dummy")
	}

	var r0 *milvuspb.DummyResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DummyRequest) (*milvuspb.DummyResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.DummyRequest) *milvuspb.DummyResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.DummyResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.DummyRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_Dummy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Dummy'
type MilvusServiceServer_Dummy_Call struct {
	*mock.Call
}

// Dummy is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.DummyRequest
func (_e *MilvusServiceServer_Expecter) Dummy(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_Dummy_Call {
	return &MilvusServiceServer_Dummy_Call{Call: _e.mock.On("Dummy", _a0, _a1)}
}

func (_c *MilvusServiceServer_Dummy_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.DummyRequest)) *MilvusServiceServer_Dummy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.DummyRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_Dummy_Call) Return(_a0 *milvuspb.DummyResponse, _a1 error) *MilvusServiceServer_Dummy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_Dummy_Call) RunAndReturn(run func(context.Context, *milvuspb.DummyRequest) (*milvuspb.DummyResponse, error)) *MilvusServiceServer_Dummy_Call {
	_c.Call.Return(run)
	return _c
}

// Flush provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) Flush(_a0 context.Context, _a1 *milvuspb.FlushRequest) (*milvuspb.FlushResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Flush")
	}

	var r0 *milvuspb.FlushResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.FlushRequest) (*milvuspb.FlushResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.FlushRequest) *milvuspb.FlushResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.FlushResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.FlushRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_Flush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Flush'
type MilvusServiceServer_Flush_Call struct {
	*mock.Call
}

// Flush is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.FlushRequest
func (_e *MilvusServiceServer_Expecter) Flush(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_Flush_Call {
	return &MilvusServiceServer_Flush_Call{Call: _e.mock.On("Flush", _a0, _a1)}
}

func (_c *MilvusServiceServer_Flush_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.FlushRequest)) *MilvusServiceServer_Flush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.FlushRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_Flush_Call) Return(_a0 *milvuspb.FlushResponse, _a1 error) *MilvusServiceServer_Flush_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_Flush_Call) RunAndReturn(run func(context.Context, *milvuspb.FlushRequest) (*milvuspb.FlushResponse, error)) *MilvusServiceServer_Flush_Call {
	_c.Call.Return(run)
	return _c
}

// FlushAll provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) FlushAll(_a0 context.Context, _a1 *milvuspb.FlushAllRequest) (*milvuspb.FlushAllResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for FlushAll")
	}

	var r0 *milvuspb.FlushAllResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.FlushAllRequest) (*milvuspb.FlushAllResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.FlushAllRequest) *milvuspb.FlushAllResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.FlushAllResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.FlushAllRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_FlushAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FlushAll'
type MilvusServiceServer_FlushAll_Call struct {
	*mock.Call
}

// FlushAll is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.FlushAllRequest
func (_e *MilvusServiceServer_Expecter) FlushAll(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_FlushAll_Call {
	return &MilvusServiceServer_FlushAll_Call{Call: _e.mock.On("FlushAll", _a0, _a1)}
}

func (_c *MilvusServiceServer_FlushAll_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.FlushAllRequest)) *MilvusServiceServer_FlushAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.FlushAllRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_FlushAll_Call) Return(_a0 *milvuspb.FlushAllResponse, _a1 error) *MilvusServiceServer_FlushAll_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_FlushAll_Call) RunAndReturn(run func(context.Context, *milvuspb.FlushAllRequest) (*milvuspb.FlushAllResponse, error)) *MilvusServiceServer_FlushAll_Call {
	_c.Call.Return(run)
	return _c
}

// GetCollectionStatistics provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetCollectionStatistics(_a0 context.Context, _a1 *milvuspb.GetCollectionStatisticsRequest) (*milvuspb.GetCollectionStatisticsResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetCollectionStatistics")
	}

	var r0 *milvuspb.GetCollectionStatisticsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetCollectionStatisticsRequest) (*milvuspb.GetCollectionStatisticsResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetCollectionStatisticsRequest) *milvuspb.GetCollectionStatisticsResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetCollectionStatisticsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetCollectionStatisticsRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetCollectionStatistics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCollectionStatistics'
type MilvusServiceServer_GetCollectionStatistics_Call struct {
	*mock.Call
}

// GetCollectionStatistics is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetCollectionStatisticsRequest
func (_e *MilvusServiceServer_Expecter) GetCollectionStatistics(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetCollectionStatistics_Call {
	return &MilvusServiceServer_GetCollectionStatistics_Call{Call: _e.mock.On("GetCollectionStatistics", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetCollectionStatistics_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetCollectionStatisticsRequest)) *MilvusServiceServer_GetCollectionStatistics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetCollectionStatisticsRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetCollectionStatistics_Call) Return(_a0 *milvuspb.GetCollectionStatisticsResponse, _a1 error) *MilvusServiceServer_GetCollectionStatistics_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetCollectionStatistics_Call) RunAndReturn(run func(context.Context, *milvuspb.GetCollectionStatisticsRequest) (*milvuspb.GetCollectionStatisticsResponse, error)) *MilvusServiceServer_GetCollectionStatistics_Call {
	_c.Call.Return(run)
	return _c
}

// GetCompactionState provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetCompactionState(_a0 context.Context, _a1 *milvuspb.GetCompactionStateRequest) (*milvuspb.GetCompactionStateResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetCompactionState")
	}

	var r0 *milvuspb.GetCompactionStateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetCompactionStateRequest) (*milvuspb.GetCompactionStateResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetCompactionStateRequest) *milvuspb.GetCompactionStateResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetCompactionStateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetCompactionStateRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetCompactionState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCompactionState'
type MilvusServiceServer_GetCompactionState_Call struct {
	*mock.Call
}

// GetCompactionState is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetCompactionStateRequest
func (_e *MilvusServiceServer_Expecter) GetCompactionState(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetCompactionState_Call {
	return &MilvusServiceServer_GetCompactionState_Call{Call: _e.mock.On("GetCompactionState", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetCompactionState_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetCompactionStateRequest)) *MilvusServiceServer_GetCompactionState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetCompactionStateRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetCompactionState_Call) Return(_a0 *milvuspb.GetCompactionStateResponse, _a1 error) *MilvusServiceServer_GetCompactionState_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetCompactionState_Call) RunAndReturn(run func(context.Context, *milvuspb.GetCompactionStateRequest) (*milvuspb.GetCompactionStateResponse, error)) *MilvusServiceServer_GetCompactionState_Call {
	_c.Call.Return(run)
	return _c
}

// GetCompactionStateWithPlans provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetCompactionStateWithPlans(_a0 context.Context, _a1 *milvuspb.GetCompactionPlansRequest) (*milvuspb.GetCompactionPlansResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetCompactionStateWithPlans")
	}

	var r0 *milvuspb.GetCompactionPlansResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetCompactionPlansRequest) (*milvuspb.GetCompactionPlansResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetCompactionPlansRequest) *milvuspb.GetCompactionPlansResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetCompactionPlansResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetCompactionPlansRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetCompactionStateWithPlans_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCompactionStateWithPlans'
type MilvusServiceServer_GetCompactionStateWithPlans_Call struct {
	*mock.Call
}

// GetCompactionStateWithPlans is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetCompactionPlansRequest
func (_e *MilvusServiceServer_Expecter) GetCompactionStateWithPlans(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetCompactionStateWithPlans_Call {
	return &MilvusServiceServer_GetCompactionStateWithPlans_Call{Call: _e.mock.On("GetCompactionStateWithPlans", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetCompactionStateWithPlans_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetCompactionPlansRequest)) *MilvusServiceServer_GetCompactionStateWithPlans_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetCompactionPlansRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetCompactionStateWithPlans_Call) Return(_a0 *milvuspb.GetCompactionPlansResponse, _a1 error) *MilvusServiceServer_GetCompactionStateWithPlans_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetCompactionStateWithPlans_Call) RunAndReturn(run func(context.Context, *milvuspb.GetCompactionPlansRequest) (*milvuspb.GetCompactionPlansResponse, error)) *MilvusServiceServer_GetCompactionStateWithPlans_Call {
	_c.Call.Return(run)
	return _c
}

// GetComponentStates provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetComponentStates(_a0 context.Context, _a1 *milvuspb.GetComponentStatesRequest) (*milvuspb.ComponentStates, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetComponentStates")
	}

	var r0 *milvuspb.ComponentStates
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetComponentStatesRequest) (*milvuspb.ComponentStates, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetComponentStatesRequest) *milvuspb.ComponentStates); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.ComponentStates)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetComponentStatesRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetComponentStates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetComponentStates'
type MilvusServiceServer_GetComponentStates_Call struct {
	*mock.Call
}

// GetComponentStates is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetComponentStatesRequest
func (_e *MilvusServiceServer_Expecter) GetComponentStates(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetComponentStates_Call {
	return &MilvusServiceServer_GetComponentStates_Call{Call: _e.mock.On("GetComponentStates", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetComponentStates_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetComponentStatesRequest)) *MilvusServiceServer_GetComponentStates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetComponentStatesRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetComponentStates_Call) Return(_a0 *milvuspb.ComponentStates, _a1 error) *MilvusServiceServer_GetComponentStates_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetComponentStates_Call) RunAndReturn(run func(context.Context, *milvuspb.GetComponentStatesRequest) (*milvuspb.ComponentStates, error)) *MilvusServiceServer_GetComponentStates_Call {
	_c.Call.Return(run)
	return _c
}

// GetFlushAllState provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetFlushAllState(_a0 context.Context, _a1 *milvuspb.GetFlushAllStateRequest) (*milvuspb.GetFlushAllStateResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetFlushAllState")
	}

	var r0 *milvuspb.GetFlushAllStateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetFlushAllStateRequest) (*milvuspb.GetFlushAllStateResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetFlushAllStateRequest) *milvuspb.GetFlushAllStateResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetFlushAllStateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetFlushAllStateRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetFlushAllState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFlushAllState'
type MilvusServiceServer_GetFlushAllState_Call struct {
	*mock.Call
}

// GetFlushAllState is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetFlushAllStateRequest
func (_e *MilvusServiceServer_Expecter) GetFlushAllState(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetFlushAllState_Call {
	return &MilvusServiceServer_GetFlushAllState_Call{Call: _e.mock.On("GetFlushAllState", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetFlushAllState_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetFlushAllStateRequest)) *MilvusServiceServer_GetFlushAllState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetFlushAllStateRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetFlushAllState_Call) Return(_a0 *milvuspb.GetFlushAllStateResponse, _a1 error) *MilvusServiceServer_GetFlushAllState_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetFlushAllState_Call) RunAndReturn(run func(context.Context, *milvuspb.GetFlushAllStateRequest) (*milvuspb.GetFlushAllStateResponse, error)) *MilvusServiceServer_GetFlushAllState_Call {
	_c.Call.Return(run)
	return _c
}

// GetFlushState provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetFlushState(_a0 context.Context, _a1 *milvuspb.GetFlushStateRequest) (*milvuspb.GetFlushStateResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetFlushState")
	}

	var r0 *milvuspb.GetFlushStateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetFlushStateRequest) (*milvuspb.GetFlushStateResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetFlushStateRequest) *milvuspb.GetFlushStateResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetFlushStateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetFlushStateRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetFlushState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFlushState'
type MilvusServiceServer_GetFlushState_Call struct {
	*mock.Call
}

// GetFlushState is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetFlushStateRequest
func (_e *MilvusServiceServer_Expecter) GetFlushState(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetFlushState_Call {
	return &MilvusServiceServer_GetFlushState_Call{Call: _e.mock.On("GetFlushState", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetFlushState_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetFlushStateRequest)) *MilvusServiceServer_GetFlushState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetFlushStateRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetFlushState_Call) Return(_a0 *milvuspb.GetFlushStateResponse, _a1 error) *MilvusServiceServer_GetFlushState_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetFlushState_Call) RunAndReturn(run func(context.Context, *milvuspb.GetFlushStateRequest) (*milvuspb.GetFlushStateResponse, error)) *MilvusServiceServer_GetFlushState_Call {
	_c.Call.Return(run)
	return _c
}

// GetImportState provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetImportState(_a0 context.Context, _a1 *milvuspb.GetImportStateRequest) (*milvuspb.GetImportStateResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetImportState")
	}

	var r0 *milvuspb.GetImportStateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetImportStateRequest) (*milvuspb.GetImportStateResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetImportStateRequest) *milvuspb.GetImportStateResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetImportStateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetImportStateRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetImportState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetImportState'
type MilvusServiceServer_GetImportState_Call struct {
	*mock.Call
}

// GetImportState is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetImportStateRequest
func (_e *MilvusServiceServer_Expecter) GetImportState(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetImportState_Call {
	return &MilvusServiceServer_GetImportState_Call{Call: _e.mock.On("GetImportState", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetImportState_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetImportStateRequest)) *MilvusServiceServer_GetImportState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetImportStateRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetImportState_Call) Return(_a0 *milvuspb.GetImportStateResponse, _a1 error) *MilvusServiceServer_GetImportState_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetImportState_Call) RunAndReturn(run func(context.Context, *milvuspb.GetImportStateRequest) (*milvuspb.GetImportStateResponse, error)) *MilvusServiceServer_GetImportState_Call {
	_c.Call.Return(run)
	return _c
}

// GetIndexBuildProgress provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetIndexBuildProgress(_a0 context.Context, _a1 *milvuspb.GetIndexBuildProgressRequest) (*milvuspb.GetIndexBuildProgressResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetIndexBuildProgress")
	}

	var r0 *milvuspb.GetIndexBuildProgressResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetIndexBuildProgressRequest) (*milvuspb.GetIndexBuildProgressResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetIndexBuildProgressRequest) *milvuspb.GetIndexBuildProgressResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetIndexBuildProgressResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetIndexBuildProgressRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetIndexBuildProgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIndexBuildProgress'
type MilvusServiceServer_GetIndexBuildProgress_Call struct {
	*mock.Call
}

// GetIndexBuildProgress is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetIndexBuildProgressRequest
func (_e *MilvusServiceServer_Expecter) GetIndexBuildProgress(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetIndexBuildProgress_Call {
	return &MilvusServiceServer_GetIndexBuildProgress_Call{Call: _e.mock.On("GetIndexBuildProgress", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetIndexBuildProgress_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetIndexBuildProgressRequest)) *MilvusServiceServer_GetIndexBuildProgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetIndexBuildProgressRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetIndexBuildProgress_Call) Return(_a0 *milvuspb.GetIndexBuildProgressResponse, _a1 error) *MilvusServiceServer_GetIndexBuildProgress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetIndexBuildProgress_Call) RunAndReturn(run func(context.Context, *milvuspb.GetIndexBuildProgressRequest) (*milvuspb.GetIndexBuildProgressResponse, error)) *MilvusServiceServer_GetIndexBuildProgress_Call {
	_c.Call.Return(run)
	return _c
}

// GetIndexState provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetIndexState(_a0 context.Context, _a1 *milvuspb.GetIndexStateRequest) (*milvuspb.GetIndexStateResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetIndexState")
	}

	var r0 *milvuspb.GetIndexStateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetIndexStateRequest) (*milvuspb.GetIndexStateResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetIndexStateRequest) *milvuspb.GetIndexStateResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetIndexStateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetIndexStateRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetIndexState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIndexState'
type MilvusServiceServer_GetIndexState_Call struct {
	*mock.Call
}

// GetIndexState is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetIndexStateRequest
func (_e *MilvusServiceServer_Expecter) GetIndexState(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetIndexState_Call {
	return &MilvusServiceServer_GetIndexState_Call{Call: _e.mock.On("GetIndexState", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetIndexState_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetIndexStateRequest)) *MilvusServiceServer_GetIndexState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetIndexStateRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetIndexState_Call) Return(_a0 *milvuspb.GetIndexStateResponse, _a1 error) *MilvusServiceServer_GetIndexState_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetIndexState_Call) RunAndReturn(run func(context.Context, *milvuspb.GetIndexStateRequest) (*milvuspb.GetIndexStateResponse, error)) *MilvusServiceServer_GetIndexState_Call {
	_c.Call.Return(run)
	return _c
}

// GetIndexStatistics provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetIndexStatistics(_a0 context.Context, _a1 *milvuspb.GetIndexStatisticsRequest) (*milvuspb.GetIndexStatisticsResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetIndexStatistics")
	}

	var r0 *milvuspb.GetIndexStatisticsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetIndexStatisticsRequest) (*milvuspb.GetIndexStatisticsResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetIndexStatisticsRequest) *milvuspb.GetIndexStatisticsResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetIndexStatisticsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetIndexStatisticsRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetIndexStatistics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIndexStatistics'
type MilvusServiceServer_GetIndexStatistics_Call struct {
	*mock.Call
}

// GetIndexStatistics is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetIndexStatisticsRequest
func (_e *MilvusServiceServer_Expecter) GetIndexStatistics(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetIndexStatistics_Call {
	return &MilvusServiceServer_GetIndexStatistics_Call{Call: _e.mock.On("GetIndexStatistics", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetIndexStatistics_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetIndexStatisticsRequest)) *MilvusServiceServer_GetIndexStatistics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetIndexStatisticsRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetIndexStatistics_Call) Return(_a0 *milvuspb.GetIndexStatisticsResponse, _a1 error) *MilvusServiceServer_GetIndexStatistics_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetIndexStatistics_Call) RunAndReturn(run func(context.Context, *milvuspb.GetIndexStatisticsRequest) (*milvuspb.GetIndexStatisticsResponse, error)) *MilvusServiceServer_GetIndexStatistics_Call {
	_c.Call.Return(run)
	return _c
}

// GetLoadState provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetLoadState(_a0 context.Context, _a1 *milvuspb.GetLoadStateRequest) (*milvuspb.GetLoadStateResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetLoadState")
	}

	var r0 *milvuspb.GetLoadStateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetLoadStateRequest) (*milvuspb.GetLoadStateResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetLoadStateRequest) *milvuspb.GetLoadStateResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetLoadStateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetLoadStateRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetLoadState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLoadState'
type MilvusServiceServer_GetLoadState_Call struct {
	*mock.Call
}

// GetLoadState is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetLoadStateRequest
func (_e *MilvusServiceServer_Expecter) GetLoadState(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetLoadState_Call {
	return &MilvusServiceServer_GetLoadState_Call{Call: _e.mock.On("GetLoadState", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetLoadState_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetLoadStateRequest)) *MilvusServiceServer_GetLoadState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetLoadStateRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetLoadState_Call) Return(_a0 *milvuspb.GetLoadStateResponse, _a1 error) *MilvusServiceServer_GetLoadState_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetLoadState_Call) RunAndReturn(run func(context.Context, *milvuspb.GetLoadStateRequest) (*milvuspb.GetLoadStateResponse, error)) *MilvusServiceServer_GetLoadState_Call {
	_c.Call.Return(run)
	return _c
}

// GetLoadingProgress provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetLoadingProgress(_a0 context.Context, _a1 *milvuspb.GetLoadingProgressRequest) (*milvuspb.GetLoadingProgressResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetLoadingProgress")
	}

	var r0 *milvuspb.GetLoadingProgressResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetLoadingProgressRequest) (*milvuspb.GetLoadingProgressResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetLoadingProgressRequest) *milvuspb.GetLoadingProgressResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetLoadingProgressResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetLoadingProgressRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetLoadingProgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLoadingProgress'
type MilvusServiceServer_GetLoadingProgress_Call struct {
	*mock.Call
}

// GetLoadingProgress is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetLoadingProgressRequest
func (_e *MilvusServiceServer_Expecter) GetLoadingProgress(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetLoadingProgress_Call {
	return &MilvusServiceServer_GetLoadingProgress_Call{Call: _e.mock.On("GetLoadingProgress", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetLoadingProgress_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetLoadingProgressRequest)) *MilvusServiceServer_GetLoadingProgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetLoadingProgressRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetLoadingProgress_Call) Return(_a0 *milvuspb.GetLoadingProgressResponse, _a1 error) *MilvusServiceServer_GetLoadingProgress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetLoadingProgress_Call) RunAndReturn(run func(context.Context, *milvuspb.GetLoadingProgressRequest) (*milvuspb.GetLoadingProgressResponse, error)) *MilvusServiceServer_GetLoadingProgress_Call {
	_c.Call.Return(run)
	return _c
}

// GetMetrics provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetMetrics(_a0 context.Context, _a1 *milvuspb.GetMetricsRequest) (*milvuspb.GetMetricsResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetMetrics")
	}

	var r0 *milvuspb.GetMetricsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetMetricsRequest) (*milvuspb.GetMetricsResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetMetricsRequest) *milvuspb.GetMetricsResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetMetricsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetMetricsRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetMetrics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMetrics'
type MilvusServiceServer_GetMetrics_Call struct {
	*mock.Call
}

// GetMetrics is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetMetricsRequest
func (_e *MilvusServiceServer_Expecter) GetMetrics(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetMetrics_Call {
	return &MilvusServiceServer_GetMetrics_Call{Call: _e.mock.On("GetMetrics", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetMetrics_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetMetricsRequest)) *MilvusServiceServer_GetMetrics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetMetricsRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetMetrics_Call) Return(_a0 *milvuspb.GetMetricsResponse, _a1 error) *MilvusServiceServer_GetMetrics_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetMetrics_Call) RunAndReturn(run func(context.Context, *milvuspb.GetMetricsRequest) (*milvuspb.GetMetricsResponse, error)) *MilvusServiceServer_GetMetrics_Call {
	_c.Call.Return(run)
	return _c
}

// GetPartitionStatistics provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetPartitionStatistics(_a0 context.Context, _a1 *milvuspb.GetPartitionStatisticsRequest) (*milvuspb.GetPartitionStatisticsResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetPartitionStatistics")
	}

	var r0 *milvuspb.GetPartitionStatisticsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetPartitionStatisticsRequest) (*milvuspb.GetPartitionStatisticsResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetPartitionStatisticsRequest) *milvuspb.GetPartitionStatisticsResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetPartitionStatisticsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetPartitionStatisticsRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetPartitionStatistics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPartitionStatistics'
type MilvusServiceServer_GetPartitionStatistics_Call struct {
	*mock.Call
}

// GetPartitionStatistics is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetPartitionStatisticsRequest
func (_e *MilvusServiceServer_Expecter) GetPartitionStatistics(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetPartitionStatistics_Call {
	return &MilvusServiceServer_GetPartitionStatistics_Call{Call: _e.mock.On("GetPartitionStatistics", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetPartitionStatistics_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetPartitionStatisticsRequest)) *MilvusServiceServer_GetPartitionStatistics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetPartitionStatisticsRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetPartitionStatistics_Call) Return(_a0 *milvuspb.GetPartitionStatisticsResponse, _a1 error) *MilvusServiceServer_GetPartitionStatistics_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetPartitionStatistics_Call) RunAndReturn(run func(context.Context, *milvuspb.GetPartitionStatisticsRequest) (*milvuspb.GetPartitionStatisticsResponse, error)) *MilvusServiceServer_GetPartitionStatistics_Call {
	_c.Call.Return(run)
	return _c
}

// GetPersistentSegmentInfo provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetPersistentSegmentInfo(_a0 context.Context, _a1 *milvuspb.GetPersistentSegmentInfoRequest) (*milvuspb.GetPersistentSegmentInfoResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetPersistentSegmentInfo")
	}

	var r0 *milvuspb.GetPersistentSegmentInfoResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetPersistentSegmentInfoRequest) (*milvuspb.GetPersistentSegmentInfoResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetPersistentSegmentInfoRequest) *milvuspb.GetPersistentSegmentInfoResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetPersistentSegmentInfoResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetPersistentSegmentInfoRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetPersistentSegmentInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPersistentSegmentInfo'
type MilvusServiceServer_GetPersistentSegmentInfo_Call struct {
	*mock.Call
}

// GetPersistentSegmentInfo is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetPersistentSegmentInfoRequest
func (_e *MilvusServiceServer_Expecter) GetPersistentSegmentInfo(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetPersistentSegmentInfo_Call {
	return &MilvusServiceServer_GetPersistentSegmentInfo_Call{Call: _e.mock.On("GetPersistentSegmentInfo", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetPersistentSegmentInfo_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetPersistentSegmentInfoRequest)) *MilvusServiceServer_GetPersistentSegmentInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetPersistentSegmentInfoRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetPersistentSegmentInfo_Call) Return(_a0 *milvuspb.GetPersistentSegmentInfoResponse, _a1 error) *MilvusServiceServer_GetPersistentSegmentInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetPersistentSegmentInfo_Call) RunAndReturn(run func(context.Context, *milvuspb.GetPersistentSegmentInfoRequest) (*milvuspb.GetPersistentSegmentInfoResponse, error)) *MilvusServiceServer_GetPersistentSegmentInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetQuerySegmentInfo provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetQuerySegmentInfo(_a0 context.Context, _a1 *milvuspb.GetQuerySegmentInfoRequest) (*milvuspb.GetQuerySegmentInfoResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetQuerySegmentInfo")
	}

	var r0 *milvuspb.GetQuerySegmentInfoResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetQuerySegmentInfoRequest) (*milvuspb.GetQuerySegmentInfoResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetQuerySegmentInfoRequest) *milvuspb.GetQuerySegmentInfoResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetQuerySegmentInfoResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetQuerySegmentInfoRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetQuerySegmentInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetQuerySegmentInfo'
type MilvusServiceServer_GetQuerySegmentInfo_Call struct {
	*mock.Call
}

// GetQuerySegmentInfo is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetQuerySegmentInfoRequest
func (_e *MilvusServiceServer_Expecter) GetQuerySegmentInfo(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetQuerySegmentInfo_Call {
	return &MilvusServiceServer_GetQuerySegmentInfo_Call{Call: _e.mock.On("GetQuerySegmentInfo", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetQuerySegmentInfo_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetQuerySegmentInfoRequest)) *MilvusServiceServer_GetQuerySegmentInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetQuerySegmentInfoRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetQuerySegmentInfo_Call) Return(_a0 *milvuspb.GetQuerySegmentInfoResponse, _a1 error) *MilvusServiceServer_GetQuerySegmentInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetQuerySegmentInfo_Call) RunAndReturn(run func(context.Context, *milvuspb.GetQuerySegmentInfoRequest) (*milvuspb.GetQuerySegmentInfoResponse, error)) *MilvusServiceServer_GetQuerySegmentInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetReplicas provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetReplicas(_a0 context.Context, _a1 *milvuspb.GetReplicasRequest) (*milvuspb.GetReplicasResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetReplicas")
	}

	var r0 *milvuspb.GetReplicasResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetReplicasRequest) (*milvuspb.GetReplicasResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetReplicasRequest) *milvuspb.GetReplicasResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetReplicasResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetReplicasRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetReplicas_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetReplicas'
type MilvusServiceServer_GetReplicas_Call struct {
	*mock.Call
}

// GetReplicas is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetReplicasRequest
func (_e *MilvusServiceServer_Expecter) GetReplicas(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetReplicas_Call {
	return &MilvusServiceServer_GetReplicas_Call{Call: _e.mock.On("GetReplicas", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetReplicas_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetReplicasRequest)) *MilvusServiceServer_GetReplicas_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetReplicasRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetReplicas_Call) Return(_a0 *milvuspb.GetReplicasResponse, _a1 error) *MilvusServiceServer_GetReplicas_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetReplicas_Call) RunAndReturn(run func(context.Context, *milvuspb.GetReplicasRequest) (*milvuspb.GetReplicasResponse, error)) *MilvusServiceServer_GetReplicas_Call {
	_c.Call.Return(run)
	return _c
}

// GetVersion provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) GetVersion(_a0 context.Context, _a1 *milvuspb.GetVersionRequest) (*milvuspb.GetVersionResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetVersion")
	}

	var r0 *milvuspb.GetVersionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetVersionRequest) (*milvuspb.GetVersionResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.GetVersionRequest) *milvuspb.GetVersionResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.GetVersionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.GetVersionRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_GetVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVersion'
type MilvusServiceServer_GetVersion_Call struct {
	*mock.Call
}

// GetVersion is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.GetVersionRequest
func (_e *MilvusServiceServer_Expecter) GetVersion(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_GetVersion_Call {
	return &MilvusServiceServer_GetVersion_Call{Call: _e.mock.On("GetVersion", _a0, _a1)}
}

func (_c *MilvusServiceServer_GetVersion_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.GetVersionRequest)) *MilvusServiceServer_GetVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.GetVersionRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_GetVersion_Call) Return(_a0 *milvuspb.GetVersionResponse, _a1 error) *MilvusServiceServer_GetVersion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_GetVersion_Call) RunAndReturn(run func(context.Context, *milvuspb.GetVersionRequest) (*milvuspb.GetVersionResponse, error)) *MilvusServiceServer_GetVersion_Call {
	_c.Call.Return(run)
	return _c
}

// HasCollection provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) HasCollection(_a0 context.Context, _a1 *milvuspb.HasCollectionRequest) (*milvuspb.BoolResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for HasCollection")
	}

	var r0 *milvuspb.BoolResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.HasCollectionRequest) (*milvuspb.BoolResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.HasCollectionRequest) *milvuspb.BoolResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.BoolResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.HasCollectionRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_HasCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasCollection'
type MilvusServiceServer_HasCollection_Call struct {
	*mock.Call
}

// HasCollection is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.HasCollectionRequest
func (_e *MilvusServiceServer_Expecter) HasCollection(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_HasCollection_Call {
	return &MilvusServiceServer_HasCollection_Call{Call: _e.mock.On("HasCollection", _a0, _a1)}
}

func (_c *MilvusServiceServer_HasCollection_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.HasCollectionRequest)) *MilvusServiceServer_HasCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.HasCollectionRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_HasCollection_Call) Return(_a0 *milvuspb.BoolResponse, _a1 error) *MilvusServiceServer_HasCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_HasCollection_Call) RunAndReturn(run func(context.Context, *milvuspb.HasCollectionRequest) (*milvuspb.BoolResponse, error)) *MilvusServiceServer_HasCollection_Call {
	_c.Call.Return(run)
	return _c
}

// HasPartition provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) HasPartition(_a0 context.Context, _a1 *milvuspb.HasPartitionRequest) (*milvuspb.BoolResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for HasPartition")
	}

	var r0 *milvuspb.BoolResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.HasPartitionRequest) (*milvuspb.BoolResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.HasPartitionRequest) *milvuspb.BoolResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.BoolResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.HasPartitionRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_HasPartition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasPartition'
type MilvusServiceServer_HasPartition_Call struct {
	*mock.Call
}

// HasPartition is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.HasPartitionRequest
func (_e *MilvusServiceServer_Expecter) HasPartition(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_HasPartition_Call {
	return &MilvusServiceServer_HasPartition_Call{Call: _e.mock.On("HasPartition", _a0, _a1)}
}

func (_c *MilvusServiceServer_HasPartition_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.HasPartitionRequest)) *MilvusServiceServer_HasPartition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.HasPartitionRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_HasPartition_Call) Return(_a0 *milvuspb.BoolResponse, _a1 error) *MilvusServiceServer_HasPartition_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_HasPartition_Call) RunAndReturn(run func(context.Context, *milvuspb.HasPartitionRequest) (*milvuspb.BoolResponse, error)) *MilvusServiceServer_HasPartition_Call {
	_c.Call.Return(run)
	return _c
}

// HybridSearch provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) HybridSearch(_a0 context.Context, _a1 *milvuspb.HybridSearchRequest) (*milvuspb.SearchResults, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for HybridSearch")
	}

	var r0 *milvuspb.SearchResults
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.HybridSearchRequest) (*milvuspb.SearchResults, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.HybridSearchRequest) *milvuspb.SearchResults); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.SearchResults)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.HybridSearchRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_HybridSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HybridSearch'
type MilvusServiceServer_HybridSearch_Call struct {
	*mock.Call
}

// HybridSearch is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.HybridSearchRequest
func (_e *MilvusServiceServer_Expecter) HybridSearch(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_HybridSearch_Call {
	return &MilvusServiceServer_HybridSearch_Call{Call: _e.mock.On("HybridSearch", _a0, _a1)}
}

func (_c *MilvusServiceServer_HybridSearch_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.HybridSearchRequest)) *MilvusServiceServer_HybridSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.HybridSearchRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_HybridSearch_Call) Return(_a0 *milvuspb.SearchResults, _a1 error) *MilvusServiceServer_HybridSearch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_HybridSearch_Call) RunAndReturn(run func(context.Context, *milvuspb.HybridSearchRequest) (*milvuspb.SearchResults, error)) *MilvusServiceServer_HybridSearch_Call {
	_c.Call.Return(run)
	return _c
}

// Import provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) Import(_a0 context.Context, _a1 *milvuspb.ImportRequest) (*milvuspb.ImportResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Import")
	}

	var r0 *milvuspb.ImportResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ImportRequest) (*milvuspb.ImportResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ImportRequest) *milvuspb.ImportResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.ImportResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.ImportRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_Import_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Import'
type MilvusServiceServer_Import_Call struct {
	*mock.Call
}

// Import is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.ImportRequest
func (_e *MilvusServiceServer_Expecter) Import(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_Import_Call {
	return &MilvusServiceServer_Import_Call{Call: _e.mock.On("Import", _a0, _a1)}
}

func (_c *MilvusServiceServer_Import_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.ImportRequest)) *MilvusServiceServer_Import_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.ImportRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_Import_Call) Return(_a0 *milvuspb.ImportResponse, _a1 error) *MilvusServiceServer_Import_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_Import_Call) RunAndReturn(run func(context.Context, *milvuspb.ImportRequest) (*milvuspb.ImportResponse, error)) *MilvusServiceServer_Import_Call {
	_c.Call.Return(run)
	return _c
}

// Insert provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) Insert(_a0 context.Context, _a1 *milvuspb.InsertRequest) (*milvuspb.MutationResult, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Insert")
	}

	var r0 *milvuspb.MutationResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.InsertRequest) (*milvuspb.MutationResult, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.InsertRequest) *milvuspb.MutationResult); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.MutationResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.InsertRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_Insert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Insert'
type MilvusServiceServer_Insert_Call struct {
	*mock.Call
}

// Insert is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.InsertRequest
func (_e *MilvusServiceServer_Expecter) Insert(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_Insert_Call {
	return &MilvusServiceServer_Insert_Call{Call: _e.mock.On("Insert", _a0, _a1)}
}

func (_c *MilvusServiceServer_Insert_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.InsertRequest)) *MilvusServiceServer_Insert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.InsertRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_Insert_Call) Return(_a0 *milvuspb.MutationResult, _a1 error) *MilvusServiceServer_Insert_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_Insert_Call) RunAndReturn(run func(context.Context, *milvuspb.InsertRequest) (*milvuspb.MutationResult, error)) *MilvusServiceServer_Insert_Call {
	_c.Call.Return(run)
	return _c
}

// ListAliases provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) ListAliases(_a0 context.Context, _a1 *milvuspb.ListAliasesRequest) (*milvuspb.ListAliasesResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ListAliases")
	}

	var r0 *milvuspb.ListAliasesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ListAliasesRequest) (*milvuspb.ListAliasesResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ListAliasesRequest) *milvuspb.ListAliasesResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.ListAliasesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.ListAliasesRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_ListAliases_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAliases'
type MilvusServiceServer_ListAliases_Call struct {
	*mock.Call
}

// ListAliases is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.ListAliasesRequest
func (_e *MilvusServiceServer_Expecter) ListAliases(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_ListAliases_Call {
	return &MilvusServiceServer_ListAliases_Call{Call: _e.mock.On("ListAliases", _a0, _a1)}
}

func (_c *MilvusServiceServer_ListAliases_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.ListAliasesRequest)) *MilvusServiceServer_ListAliases_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.ListAliasesRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_ListAliases_Call) Return(_a0 *milvuspb.ListAliasesResponse, _a1 error) *MilvusServiceServer_ListAliases_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_ListAliases_Call) RunAndReturn(run func(context.Context, *milvuspb.ListAliasesRequest) (*milvuspb.ListAliasesResponse, error)) *MilvusServiceServer_ListAliases_Call {
	_c.Call.Return(run)
	return _c
}

// ListCredUsers provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) ListCredUsers(_a0 context.Context, _a1 *milvuspb.ListCredUsersRequest) (*milvuspb.ListCredUsersResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ListCredUsers")
	}

	var r0 *milvuspb.ListCredUsersResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ListCredUsersRequest) (*milvuspb.ListCredUsersResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ListCredUsersRequest) *milvuspb.ListCredUsersResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.ListCredUsersResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.ListCredUsersRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_ListCredUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCredUsers'
type MilvusServiceServer_ListCredUsers_Call struct {
	*mock.Call
}

// ListCredUsers is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.ListCredUsersRequest
func (_e *MilvusServiceServer_Expecter) ListCredUsers(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_ListCredUsers_Call {
	return &MilvusServiceServer_ListCredUsers_Call{Call: _e.mock.On("ListCredUsers", _a0, _a1)}
}

func (_c *MilvusServiceServer_ListCredUsers_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.ListCredUsersRequest)) *MilvusServiceServer_ListCredUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.ListCredUsersRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_ListCredUsers_Call) Return(_a0 *milvuspb.ListCredUsersResponse, _a1 error) *MilvusServiceServer_ListCredUsers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_ListCredUsers_Call) RunAndReturn(run func(context.Context, *milvuspb.ListCredUsersRequest) (*milvuspb.ListCredUsersResponse, error)) *MilvusServiceServer_ListCredUsers_Call {
	_c.Call.Return(run)
	return _c
}

// ListDatabases provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) ListDatabases(_a0 context.Context, _a1 *milvuspb.ListDatabasesRequest) (*milvuspb.ListDatabasesResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ListDatabases")
	}

	var r0 *milvuspb.ListDatabasesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ListDatabasesRequest) (*milvuspb.ListDatabasesResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ListDatabasesRequest) *milvuspb.ListDatabasesResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.ListDatabasesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.ListDatabasesRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_ListDatabases_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListDatabases'
type MilvusServiceServer_ListDatabases_Call struct {
	*mock.Call
}

// ListDatabases is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.ListDatabasesRequest
func (_e *MilvusServiceServer_Expecter) ListDatabases(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_ListDatabases_Call {
	return &MilvusServiceServer_ListDatabases_Call{Call: _e.mock.On("ListDatabases", _a0, _a1)}
}

func (_c *MilvusServiceServer_ListDatabases_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.ListDatabasesRequest)) *MilvusServiceServer_ListDatabases_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.ListDatabasesRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_ListDatabases_Call) Return(_a0 *milvuspb.ListDatabasesResponse, _a1 error) *MilvusServiceServer_ListDatabases_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_ListDatabases_Call) RunAndReturn(run func(context.Context, *milvuspb.ListDatabasesRequest) (*milvuspb.ListDatabasesResponse, error)) *MilvusServiceServer_ListDatabases_Call {
	_c.Call.Return(run)
	return _c
}

// ListImportTasks provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) ListImportTasks(_a0 context.Context, _a1 *milvuspb.ListImportTasksRequest) (*milvuspb.ListImportTasksResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ListImportTasks")
	}

	var r0 *milvuspb.ListImportTasksResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ListImportTasksRequest) (*milvuspb.ListImportTasksResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ListImportTasksRequest) *milvuspb.ListImportTasksResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.ListImportTasksResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.ListImportTasksRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_ListImportTasks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListImportTasks'
type MilvusServiceServer_ListImportTasks_Call struct {
	*mock.Call
}

// ListImportTasks is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.ListImportTasksRequest
func (_e *MilvusServiceServer_Expecter) ListImportTasks(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_ListImportTasks_Call {
	return &MilvusServiceServer_ListImportTasks_Call{Call: _e.mock.On("ListImportTasks", _a0, _a1)}
}

func (_c *MilvusServiceServer_ListImportTasks_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.ListImportTasksRequest)) *MilvusServiceServer_ListImportTasks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.ListImportTasksRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_ListImportTasks_Call) Return(_a0 *milvuspb.ListImportTasksResponse, _a1 error) *MilvusServiceServer_ListImportTasks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_ListImportTasks_Call) RunAndReturn(run func(context.Context, *milvuspb.ListImportTasksRequest) (*milvuspb.ListImportTasksResponse, error)) *MilvusServiceServer_ListImportTasks_Call {
	_c.Call.Return(run)
	return _c
}

// ListIndexedSegment provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) ListIndexedSegment(_a0 context.Context, _a1 *federpb.ListIndexedSegmentRequest) (*federpb.ListIndexedSegmentResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ListIndexedSegment")
	}

	var r0 *federpb.ListIndexedSegmentResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *federpb.ListIndexedSegmentRequest) (*federpb.ListIndexedSegmentResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *federpb.ListIndexedSegmentRequest) *federpb.ListIndexedSegmentResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*federpb.ListIndexedSegmentResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *federpb.ListIndexedSegmentRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_ListIndexedSegment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListIndexedSegment'
type MilvusServiceServer_ListIndexedSegment_Call struct {
	*mock.Call
}

// ListIndexedSegment is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *federpb.ListIndexedSegmentRequest
func (_e *MilvusServiceServer_Expecter) ListIndexedSegment(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_ListIndexedSegment_Call {
	return &MilvusServiceServer_ListIndexedSegment_Call{Call: _e.mock.On("ListIndexedSegment", _a0, _a1)}
}

func (_c *MilvusServiceServer_ListIndexedSegment_Call) Run(run func(_a0 context.Context, _a1 *federpb.ListIndexedSegmentRequest)) *MilvusServiceServer_ListIndexedSegment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*federpb.ListIndexedSegmentRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_ListIndexedSegment_Call) Return(_a0 *federpb.ListIndexedSegmentResponse, _a1 error) *MilvusServiceServer_ListIndexedSegment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_ListIndexedSegment_Call) RunAndReturn(run func(context.Context, *federpb.ListIndexedSegmentRequest) (*federpb.ListIndexedSegmentResponse, error)) *MilvusServiceServer_ListIndexedSegment_Call {
	_c.Call.Return(run)
	return _c
}

// ListPrivilegeGroups provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) ListPrivilegeGroups(_a0 context.Context, _a1 *milvuspb.ListPrivilegeGroupsRequest) (*milvuspb.ListPrivilegeGroupsResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ListPrivilegeGroups")
	}

	var r0 *milvuspb.ListPrivilegeGroupsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ListPrivilegeGroupsRequest) (*milvuspb.ListPrivilegeGroupsResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ListPrivilegeGroupsRequest) *milvuspb.ListPrivilegeGroupsResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.ListPrivilegeGroupsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.ListPrivilegeGroupsRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_ListPrivilegeGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPrivilegeGroups'
type MilvusServiceServer_ListPrivilegeGroups_Call struct {
	*mock.Call
}

// ListPrivilegeGroups is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.ListPrivilegeGroupsRequest
func (_e *MilvusServiceServer_Expecter) ListPrivilegeGroups(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_ListPrivilegeGroups_Call {
	return &MilvusServiceServer_ListPrivilegeGroups_Call{Call: _e.mock.On("ListPrivilegeGroups", _a0, _a1)}
}

func (_c *MilvusServiceServer_ListPrivilegeGroups_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.ListPrivilegeGroupsRequest)) *MilvusServiceServer_ListPrivilegeGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.ListPrivilegeGroupsRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_ListPrivilegeGroups_Call) Return(_a0 *milvuspb.ListPrivilegeGroupsResponse, _a1 error) *MilvusServiceServer_ListPrivilegeGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_ListPrivilegeGroups_Call) RunAndReturn(run func(context.Context, *milvuspb.ListPrivilegeGroupsRequest) (*milvuspb.ListPrivilegeGroupsResponse, error)) *MilvusServiceServer_ListPrivilegeGroups_Call {
	_c.Call.Return(run)
	return _c
}

// ListResourceGroups provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) ListResourceGroups(_a0 context.Context, _a1 *milvuspb.ListResourceGroupsRequest) (*milvuspb.ListResourceGroupsResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ListResourceGroups")
	}

	var r0 *milvuspb.ListResourceGroupsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ListResourceGroupsRequest) (*milvuspb.ListResourceGroupsResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ListResourceGroupsRequest) *milvuspb.ListResourceGroupsResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.ListResourceGroupsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.ListResourceGroupsRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_ListResourceGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListResourceGroups'
type MilvusServiceServer_ListResourceGroups_Call struct {
	*mock.Call
}

// ListResourceGroups is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.ListResourceGroupsRequest
func (_e *MilvusServiceServer_Expecter) ListResourceGroups(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_ListResourceGroups_Call {
	return &MilvusServiceServer_ListResourceGroups_Call{Call: _e.mock.On("ListResourceGroups", _a0, _a1)}
}

func (_c *MilvusServiceServer_ListResourceGroups_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.ListResourceGroupsRequest)) *MilvusServiceServer_ListResourceGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.ListResourceGroupsRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_ListResourceGroups_Call) Return(_a0 *milvuspb.ListResourceGroupsResponse, _a1 error) *MilvusServiceServer_ListResourceGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_ListResourceGroups_Call) RunAndReturn(run func(context.Context, *milvuspb.ListResourceGroupsRequest) (*milvuspb.ListResourceGroupsResponse, error)) *MilvusServiceServer_ListResourceGroups_Call {
	_c.Call.Return(run)
	return _c
}

// LoadBalance provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) LoadBalance(_a0 context.Context, _a1 *milvuspb.LoadBalanceRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for LoadBalance")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.LoadBalanceRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.LoadBalanceRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.LoadBalanceRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_LoadBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadBalance'
type MilvusServiceServer_LoadBalance_Call struct {
	*mock.Call
}

// LoadBalance is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.LoadBalanceRequest
func (_e *MilvusServiceServer_Expecter) LoadBalance(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_LoadBalance_Call {
	return &MilvusServiceServer_LoadBalance_Call{Call: _e.mock.On("LoadBalance", _a0, _a1)}
}

func (_c *MilvusServiceServer_LoadBalance_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.LoadBalanceRequest)) *MilvusServiceServer_LoadBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.LoadBalanceRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_LoadBalance_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_LoadBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_LoadBalance_Call) RunAndReturn(run func(context.Context, *milvuspb.LoadBalanceRequest) (*commonpb.Status, error)) *MilvusServiceServer_LoadBalance_Call {
	_c.Call.Return(run)
	return _c
}

// LoadCollection provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) LoadCollection(_a0 context.Context, _a1 *milvuspb.LoadCollectionRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for LoadCollection")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.LoadCollectionRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.LoadCollectionRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.LoadCollectionRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_LoadCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadCollection'
type MilvusServiceServer_LoadCollection_Call struct {
	*mock.Call
}

// LoadCollection is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.LoadCollectionRequest
func (_e *MilvusServiceServer_Expecter) LoadCollection(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_LoadCollection_Call {
	return &MilvusServiceServer_LoadCollection_Call{Call: _e.mock.On("LoadCollection", _a0, _a1)}
}

func (_c *MilvusServiceServer_LoadCollection_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.LoadCollectionRequest)) *MilvusServiceServer_LoadCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.LoadCollectionRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_LoadCollection_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_LoadCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_LoadCollection_Call) RunAndReturn(run func(context.Context, *milvuspb.LoadCollectionRequest) (*commonpb.Status, error)) *MilvusServiceServer_LoadCollection_Call {
	_c.Call.Return(run)
	return _c
}

// LoadPartitions provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) LoadPartitions(_a0 context.Context, _a1 *milvuspb.LoadPartitionsRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for LoadPartitions")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.LoadPartitionsRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.LoadPartitionsRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.LoadPartitionsRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_LoadPartitions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadPartitions'
type MilvusServiceServer_LoadPartitions_Call struct {
	*mock.Call
}

// LoadPartitions is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.LoadPartitionsRequest
func (_e *MilvusServiceServer_Expecter) LoadPartitions(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_LoadPartitions_Call {
	return &MilvusServiceServer_LoadPartitions_Call{Call: _e.mock.On("LoadPartitions", _a0, _a1)}
}

func (_c *MilvusServiceServer_LoadPartitions_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.LoadPartitionsRequest)) *MilvusServiceServer_LoadPartitions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.LoadPartitionsRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_LoadPartitions_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_LoadPartitions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_LoadPartitions_Call) RunAndReturn(run func(context.Context, *milvuspb.LoadPartitionsRequest) (*commonpb.Status, error)) *MilvusServiceServer_LoadPartitions_Call {
	_c.Call.Return(run)
	return _c
}

// ManualCompaction provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) ManualCompaction(_a0 context.Context, _a1 *milvuspb.ManualCompactionRequest) (*milvuspb.ManualCompactionResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ManualCompaction")
	}

	var r0 *milvuspb.ManualCompactionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ManualCompactionRequest) (*milvuspb.ManualCompactionResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ManualCompactionRequest) *milvuspb.ManualCompactionResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.ManualCompactionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.ManualCompactionRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_ManualCompaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ManualCompaction'
type MilvusServiceServer_ManualCompaction_Call struct {
	*mock.Call
}

// ManualCompaction is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.ManualCompactionRequest
func (_e *MilvusServiceServer_Expecter) ManualCompaction(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_ManualCompaction_Call {
	return &MilvusServiceServer_ManualCompaction_Call{Call: _e.mock.On("ManualCompaction", _a0, _a1)}
}

func (_c *MilvusServiceServer_ManualCompaction_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.ManualCompactionRequest)) *MilvusServiceServer_ManualCompaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.ManualCompactionRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_ManualCompaction_Call) Return(_a0 *milvuspb.ManualCompactionResponse, _a1 error) *MilvusServiceServer_ManualCompaction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_ManualCompaction_Call) RunAndReturn(run func(context.Context, *milvuspb.ManualCompactionRequest) (*milvuspb.ManualCompactionResponse, error)) *MilvusServiceServer_ManualCompaction_Call {
	_c.Call.Return(run)
	return _c
}

// OperatePrivilege provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) OperatePrivilege(_a0 context.Context, _a1 *milvuspb.OperatePrivilegeRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for OperatePrivilege")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.OperatePrivilegeRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.OperatePrivilegeRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.OperatePrivilegeRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_OperatePrivilege_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OperatePrivilege'
type MilvusServiceServer_OperatePrivilege_Call struct {
	*mock.Call
}

// OperatePrivilege is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.OperatePrivilegeRequest
func (_e *MilvusServiceServer_Expecter) OperatePrivilege(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_OperatePrivilege_Call {
	return &MilvusServiceServer_OperatePrivilege_Call{Call: _e.mock.On("OperatePrivilege", _a0, _a1)}
}

func (_c *MilvusServiceServer_OperatePrivilege_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.OperatePrivilegeRequest)) *MilvusServiceServer_OperatePrivilege_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.OperatePrivilegeRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_OperatePrivilege_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_OperatePrivilege_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_OperatePrivilege_Call) RunAndReturn(run func(context.Context, *milvuspb.OperatePrivilegeRequest) (*commonpb.Status, error)) *MilvusServiceServer_OperatePrivilege_Call {
	_c.Call.Return(run)
	return _c
}

// OperatePrivilegeGroup provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) OperatePrivilegeGroup(_a0 context.Context, _a1 *milvuspb.OperatePrivilegeGroupRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for OperatePrivilegeGroup")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.OperatePrivilegeGroupRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.OperatePrivilegeGroupRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.OperatePrivilegeGroupRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_OperatePrivilegeGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OperatePrivilegeGroup'
type MilvusServiceServer_OperatePrivilegeGroup_Call struct {
	*mock.Call
}

// OperatePrivilegeGroup is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.OperatePrivilegeGroupRequest
func (_e *MilvusServiceServer_Expecter) OperatePrivilegeGroup(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_OperatePrivilegeGroup_Call {
	return &MilvusServiceServer_OperatePrivilegeGroup_Call{Call: _e.mock.On("OperatePrivilegeGroup", _a0, _a1)}
}

func (_c *MilvusServiceServer_OperatePrivilegeGroup_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.OperatePrivilegeGroupRequest)) *MilvusServiceServer_OperatePrivilegeGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.OperatePrivilegeGroupRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_OperatePrivilegeGroup_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_OperatePrivilegeGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_OperatePrivilegeGroup_Call) RunAndReturn(run func(context.Context, *milvuspb.OperatePrivilegeGroupRequest) (*commonpb.Status, error)) *MilvusServiceServer_OperatePrivilegeGroup_Call {
	_c.Call.Return(run)
	return _c
}

// OperatePrivilegeV2 provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) OperatePrivilegeV2(_a0 context.Context, _a1 *milvuspb.OperatePrivilegeV2Request) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for OperatePrivilegeV2")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.OperatePrivilegeV2Request) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.OperatePrivilegeV2Request) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.OperatePrivilegeV2Request) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_OperatePrivilegeV2_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OperatePrivilegeV2'
type MilvusServiceServer_OperatePrivilegeV2_Call struct {
	*mock.Call
}

// OperatePrivilegeV2 is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.OperatePrivilegeV2Request
func (_e *MilvusServiceServer_Expecter) OperatePrivilegeV2(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_OperatePrivilegeV2_Call {
	return &MilvusServiceServer_OperatePrivilegeV2_Call{Call: _e.mock.On("OperatePrivilegeV2", _a0, _a1)}
}

func (_c *MilvusServiceServer_OperatePrivilegeV2_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.OperatePrivilegeV2Request)) *MilvusServiceServer_OperatePrivilegeV2_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.OperatePrivilegeV2Request))
	})
	return _c
}

func (_c *MilvusServiceServer_OperatePrivilegeV2_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_OperatePrivilegeV2_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_OperatePrivilegeV2_Call) RunAndReturn(run func(context.Context, *milvuspb.OperatePrivilegeV2Request) (*commonpb.Status, error)) *MilvusServiceServer_OperatePrivilegeV2_Call {
	_c.Call.Return(run)
	return _c
}

// OperateUserRole provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) OperateUserRole(_a0 context.Context, _a1 *milvuspb.OperateUserRoleRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for OperateUserRole")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.OperateUserRoleRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.OperateUserRoleRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.OperateUserRoleRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_OperateUserRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OperateUserRole'
type MilvusServiceServer_OperateUserRole_Call struct {
	*mock.Call
}

// OperateUserRole is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.OperateUserRoleRequest
func (_e *MilvusServiceServer_Expecter) OperateUserRole(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_OperateUserRole_Call {
	return &MilvusServiceServer_OperateUserRole_Call{Call: _e.mock.On("OperateUserRole", _a0, _a1)}
}

func (_c *MilvusServiceServer_OperateUserRole_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.OperateUserRoleRequest)) *MilvusServiceServer_OperateUserRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.OperateUserRoleRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_OperateUserRole_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_OperateUserRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_OperateUserRole_Call) RunAndReturn(run func(context.Context, *milvuspb.OperateUserRoleRequest) (*commonpb.Status, error)) *MilvusServiceServer_OperateUserRole_Call {
	_c.Call.Return(run)
	return _c
}

// Query provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) Query(_a0 context.Context, _a1 *milvuspb.QueryRequest) (*milvuspb.QueryResults, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Query")
	}

	var r0 *milvuspb.QueryResults
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.QueryRequest) (*milvuspb.QueryResults, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.QueryRequest) *milvuspb.QueryResults); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.QueryResults)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.QueryRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_Query_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Query'
type MilvusServiceServer_Query_Call struct {
	*mock.Call
}

// Query is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.QueryRequest
func (_e *MilvusServiceServer_Expecter) Query(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_Query_Call {
	return &MilvusServiceServer_Query_Call{Call: _e.mock.On("Query", _a0, _a1)}
}

func (_c *MilvusServiceServer_Query_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.QueryRequest)) *MilvusServiceServer_Query_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.QueryRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_Query_Call) Return(_a0 *milvuspb.QueryResults, _a1 error) *MilvusServiceServer_Query_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_Query_Call) RunAndReturn(run func(context.Context, *milvuspb.QueryRequest) (*milvuspb.QueryResults, error)) *MilvusServiceServer_Query_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterLink provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) RegisterLink(_a0 context.Context, _a1 *milvuspb.RegisterLinkRequest) (*milvuspb.RegisterLinkResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for RegisterLink")
	}

	var r0 *milvuspb.RegisterLinkResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.RegisterLinkRequest) (*milvuspb.RegisterLinkResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.RegisterLinkRequest) *milvuspb.RegisterLinkResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.RegisterLinkResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.RegisterLinkRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_RegisterLink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterLink'
type MilvusServiceServer_RegisterLink_Call struct {
	*mock.Call
}

// RegisterLink is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.RegisterLinkRequest
func (_e *MilvusServiceServer_Expecter) RegisterLink(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_RegisterLink_Call {
	return &MilvusServiceServer_RegisterLink_Call{Call: _e.mock.On("RegisterLink", _a0, _a1)}
}

func (_c *MilvusServiceServer_RegisterLink_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.RegisterLinkRequest)) *MilvusServiceServer_RegisterLink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.RegisterLinkRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_RegisterLink_Call) Return(_a0 *milvuspb.RegisterLinkResponse, _a1 error) *MilvusServiceServer_RegisterLink_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_RegisterLink_Call) RunAndReturn(run func(context.Context, *milvuspb.RegisterLinkRequest) (*milvuspb.RegisterLinkResponse, error)) *MilvusServiceServer_RegisterLink_Call {
	_c.Call.Return(run)
	return _c
}

// ReleaseCollection provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) ReleaseCollection(_a0 context.Context, _a1 *milvuspb.ReleaseCollectionRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ReleaseCollection")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ReleaseCollectionRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ReleaseCollectionRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.ReleaseCollectionRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_ReleaseCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReleaseCollection'
type MilvusServiceServer_ReleaseCollection_Call struct {
	*mock.Call
}

// ReleaseCollection is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.ReleaseCollectionRequest
func (_e *MilvusServiceServer_Expecter) ReleaseCollection(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_ReleaseCollection_Call {
	return &MilvusServiceServer_ReleaseCollection_Call{Call: _e.mock.On("ReleaseCollection", _a0, _a1)}
}

func (_c *MilvusServiceServer_ReleaseCollection_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.ReleaseCollectionRequest)) *MilvusServiceServer_ReleaseCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.ReleaseCollectionRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_ReleaseCollection_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_ReleaseCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_ReleaseCollection_Call) RunAndReturn(run func(context.Context, *milvuspb.ReleaseCollectionRequest) (*commonpb.Status, error)) *MilvusServiceServer_ReleaseCollection_Call {
	_c.Call.Return(run)
	return _c
}

// ReleasePartitions provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) ReleasePartitions(_a0 context.Context, _a1 *milvuspb.ReleasePartitionsRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ReleasePartitions")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ReleasePartitionsRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ReleasePartitionsRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.ReleasePartitionsRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_ReleasePartitions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReleasePartitions'
type MilvusServiceServer_ReleasePartitions_Call struct {
	*mock.Call
}

// ReleasePartitions is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.ReleasePartitionsRequest
func (_e *MilvusServiceServer_Expecter) ReleasePartitions(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_ReleasePartitions_Call {
	return &MilvusServiceServer_ReleasePartitions_Call{Call: _e.mock.On("ReleasePartitions", _a0, _a1)}
}

func (_c *MilvusServiceServer_ReleasePartitions_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.ReleasePartitionsRequest)) *MilvusServiceServer_ReleasePartitions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.ReleasePartitionsRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_ReleasePartitions_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_ReleasePartitions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_ReleasePartitions_Call) RunAndReturn(run func(context.Context, *milvuspb.ReleasePartitionsRequest) (*commonpb.Status, error)) *MilvusServiceServer_ReleasePartitions_Call {
	_c.Call.Return(run)
	return _c
}

// RenameCollection provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) RenameCollection(_a0 context.Context, _a1 *milvuspb.RenameCollectionRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for RenameCollection")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.RenameCollectionRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.RenameCollectionRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.RenameCollectionRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_RenameCollection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RenameCollection'
type MilvusServiceServer_RenameCollection_Call struct {
	*mock.Call
}

// RenameCollection is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.RenameCollectionRequest
func (_e *MilvusServiceServer_Expecter) RenameCollection(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_RenameCollection_Call {
	return &MilvusServiceServer_RenameCollection_Call{Call: _e.mock.On("RenameCollection", _a0, _a1)}
}

func (_c *MilvusServiceServer_RenameCollection_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.RenameCollectionRequest)) *MilvusServiceServer_RenameCollection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.RenameCollectionRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_RenameCollection_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_RenameCollection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_RenameCollection_Call) RunAndReturn(run func(context.Context, *milvuspb.RenameCollectionRequest) (*commonpb.Status, error)) *MilvusServiceServer_RenameCollection_Call {
	_c.Call.Return(run)
	return _c
}

// ReplicateMessage provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) ReplicateMessage(_a0 context.Context, _a1 *milvuspb.ReplicateMessageRequest) (*milvuspb.ReplicateMessageResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ReplicateMessage")
	}

	var r0 *milvuspb.ReplicateMessageResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ReplicateMessageRequest) (*milvuspb.ReplicateMessageResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ReplicateMessageRequest) *milvuspb.ReplicateMessageResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.ReplicateMessageResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.ReplicateMessageRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_ReplicateMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReplicateMessage'
type MilvusServiceServer_ReplicateMessage_Call struct {
	*mock.Call
}

// ReplicateMessage is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.ReplicateMessageRequest
func (_e *MilvusServiceServer_Expecter) ReplicateMessage(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_ReplicateMessage_Call {
	return &MilvusServiceServer_ReplicateMessage_Call{Call: _e.mock.On("ReplicateMessage", _a0, _a1)}
}

func (_c *MilvusServiceServer_ReplicateMessage_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.ReplicateMessageRequest)) *MilvusServiceServer_ReplicateMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.ReplicateMessageRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_ReplicateMessage_Call) Return(_a0 *milvuspb.ReplicateMessageResponse, _a1 error) *MilvusServiceServer_ReplicateMessage_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_ReplicateMessage_Call) RunAndReturn(run func(context.Context, *milvuspb.ReplicateMessageRequest) (*milvuspb.ReplicateMessageResponse, error)) *MilvusServiceServer_ReplicateMessage_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreRBAC provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) RestoreRBAC(_a0 context.Context, _a1 *milvuspb.RestoreRBACMetaRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for RestoreRBAC")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.RestoreRBACMetaRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.RestoreRBACMetaRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.RestoreRBACMetaRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_RestoreRBAC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreRBAC'
type MilvusServiceServer_RestoreRBAC_Call struct {
	*mock.Call
}

// RestoreRBAC is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.RestoreRBACMetaRequest
func (_e *MilvusServiceServer_Expecter) RestoreRBAC(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_RestoreRBAC_Call {
	return &MilvusServiceServer_RestoreRBAC_Call{Call: _e.mock.On("RestoreRBAC", _a0, _a1)}
}

func (_c *MilvusServiceServer_RestoreRBAC_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.RestoreRBACMetaRequest)) *MilvusServiceServer_RestoreRBAC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.RestoreRBACMetaRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_RestoreRBAC_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_RestoreRBAC_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_RestoreRBAC_Call) RunAndReturn(run func(context.Context, *milvuspb.RestoreRBACMetaRequest) (*commonpb.Status, error)) *MilvusServiceServer_RestoreRBAC_Call {
	_c.Call.Return(run)
	return _c
}

// RunAnalyzer provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) RunAnalyzer(_a0 context.Context, _a1 *milvuspb.RunAnalyzerRequest) (*milvuspb.RunAnalyzerResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for RunAnalyzer")
	}

	var r0 *milvuspb.RunAnalyzerResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.RunAnalyzerRequest) (*milvuspb.RunAnalyzerResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.RunAnalyzerRequest) *milvuspb.RunAnalyzerResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.RunAnalyzerResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.RunAnalyzerRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_RunAnalyzer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunAnalyzer'
type MilvusServiceServer_RunAnalyzer_Call struct {
	*mock.Call
}

// RunAnalyzer is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.RunAnalyzerRequest
func (_e *MilvusServiceServer_Expecter) RunAnalyzer(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_RunAnalyzer_Call {
	return &MilvusServiceServer_RunAnalyzer_Call{Call: _e.mock.On("RunAnalyzer", _a0, _a1)}
}

func (_c *MilvusServiceServer_RunAnalyzer_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.RunAnalyzerRequest)) *MilvusServiceServer_RunAnalyzer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.RunAnalyzerRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_RunAnalyzer_Call) Return(_a0 *milvuspb.RunAnalyzerResponse, _a1 error) *MilvusServiceServer_RunAnalyzer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_RunAnalyzer_Call) RunAndReturn(run func(context.Context, *milvuspb.RunAnalyzerRequest) (*milvuspb.RunAnalyzerResponse, error)) *MilvusServiceServer_RunAnalyzer_Call {
	_c.Call.Return(run)
	return _c
}

// Search provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) Search(_a0 context.Context, _a1 *milvuspb.SearchRequest) (*milvuspb.SearchResults, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Search")
	}

	var r0 *milvuspb.SearchResults
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.SearchRequest) (*milvuspb.SearchResults, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.SearchRequest) *milvuspb.SearchResults); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.SearchResults)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.SearchRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_Search_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Search'
type MilvusServiceServer_Search_Call struct {
	*mock.Call
}

// Search is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.SearchRequest
func (_e *MilvusServiceServer_Expecter) Search(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_Search_Call {
	return &MilvusServiceServer_Search_Call{Call: _e.mock.On("Search", _a0, _a1)}
}

func (_c *MilvusServiceServer_Search_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.SearchRequest)) *MilvusServiceServer_Search_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.SearchRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_Search_Call) Return(_a0 *milvuspb.SearchResults, _a1 error) *MilvusServiceServer_Search_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_Search_Call) RunAndReturn(run func(context.Context, *milvuspb.SearchRequest) (*milvuspb.SearchResults, error)) *MilvusServiceServer_Search_Call {
	_c.Call.Return(run)
	return _c
}

// SelectGrant provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) SelectGrant(_a0 context.Context, _a1 *milvuspb.SelectGrantRequest) (*milvuspb.SelectGrantResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for SelectGrant")
	}

	var r0 *milvuspb.SelectGrantResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.SelectGrantRequest) (*milvuspb.SelectGrantResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.SelectGrantRequest) *milvuspb.SelectGrantResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.SelectGrantResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.SelectGrantRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_SelectGrant_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectGrant'
type MilvusServiceServer_SelectGrant_Call struct {
	*mock.Call
}

// SelectGrant is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.SelectGrantRequest
func (_e *MilvusServiceServer_Expecter) SelectGrant(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_SelectGrant_Call {
	return &MilvusServiceServer_SelectGrant_Call{Call: _e.mock.On("SelectGrant", _a0, _a1)}
}

func (_c *MilvusServiceServer_SelectGrant_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.SelectGrantRequest)) *MilvusServiceServer_SelectGrant_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.SelectGrantRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_SelectGrant_Call) Return(_a0 *milvuspb.SelectGrantResponse, _a1 error) *MilvusServiceServer_SelectGrant_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_SelectGrant_Call) RunAndReturn(run func(context.Context, *milvuspb.SelectGrantRequest) (*milvuspb.SelectGrantResponse, error)) *MilvusServiceServer_SelectGrant_Call {
	_c.Call.Return(run)
	return _c
}

// SelectRole provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) SelectRole(_a0 context.Context, _a1 *milvuspb.SelectRoleRequest) (*milvuspb.SelectRoleResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for SelectRole")
	}

	var r0 *milvuspb.SelectRoleResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.SelectRoleRequest) (*milvuspb.SelectRoleResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.SelectRoleRequest) *milvuspb.SelectRoleResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.SelectRoleResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.SelectRoleRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_SelectRole_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectRole'
type MilvusServiceServer_SelectRole_Call struct {
	*mock.Call
}

// SelectRole is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.SelectRoleRequest
func (_e *MilvusServiceServer_Expecter) SelectRole(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_SelectRole_Call {
	return &MilvusServiceServer_SelectRole_Call{Call: _e.mock.On("SelectRole", _a0, _a1)}
}

func (_c *MilvusServiceServer_SelectRole_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.SelectRoleRequest)) *MilvusServiceServer_SelectRole_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.SelectRoleRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_SelectRole_Call) Return(_a0 *milvuspb.SelectRoleResponse, _a1 error) *MilvusServiceServer_SelectRole_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_SelectRole_Call) RunAndReturn(run func(context.Context, *milvuspb.SelectRoleRequest) (*milvuspb.SelectRoleResponse, error)) *MilvusServiceServer_SelectRole_Call {
	_c.Call.Return(run)
	return _c
}

// SelectUser provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) SelectUser(_a0 context.Context, _a1 *milvuspb.SelectUserRequest) (*milvuspb.SelectUserResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for SelectUser")
	}

	var r0 *milvuspb.SelectUserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.SelectUserRequest) (*milvuspb.SelectUserResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.SelectUserRequest) *milvuspb.SelectUserResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.SelectUserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.SelectUserRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_SelectUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectUser'
type MilvusServiceServer_SelectUser_Call struct {
	*mock.Call
}

// SelectUser is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.SelectUserRequest
func (_e *MilvusServiceServer_Expecter) SelectUser(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_SelectUser_Call {
	return &MilvusServiceServer_SelectUser_Call{Call: _e.mock.On("SelectUser", _a0, _a1)}
}

func (_c *MilvusServiceServer_SelectUser_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.SelectUserRequest)) *MilvusServiceServer_SelectUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.SelectUserRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_SelectUser_Call) Return(_a0 *milvuspb.SelectUserResponse, _a1 error) *MilvusServiceServer_SelectUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_SelectUser_Call) RunAndReturn(run func(context.Context, *milvuspb.SelectUserRequest) (*milvuspb.SelectUserResponse, error)) *MilvusServiceServer_SelectUser_Call {
	_c.Call.Return(run)
	return _c
}

// ShowCollections provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) ShowCollections(_a0 context.Context, _a1 *milvuspb.ShowCollectionsRequest) (*milvuspb.ShowCollectionsResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ShowCollections")
	}

	var r0 *milvuspb.ShowCollectionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ShowCollectionsRequest) (*milvuspb.ShowCollectionsResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ShowCollectionsRequest) *milvuspb.ShowCollectionsResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.ShowCollectionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.ShowCollectionsRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_ShowCollections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShowCollections'
type MilvusServiceServer_ShowCollections_Call struct {
	*mock.Call
}

// ShowCollections is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.ShowCollectionsRequest
func (_e *MilvusServiceServer_Expecter) ShowCollections(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_ShowCollections_Call {
	return &MilvusServiceServer_ShowCollections_Call{Call: _e.mock.On("ShowCollections", _a0, _a1)}
}

func (_c *MilvusServiceServer_ShowCollections_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.ShowCollectionsRequest)) *MilvusServiceServer_ShowCollections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.ShowCollectionsRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_ShowCollections_Call) Return(_a0 *milvuspb.ShowCollectionsResponse, _a1 error) *MilvusServiceServer_ShowCollections_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_ShowCollections_Call) RunAndReturn(run func(context.Context, *milvuspb.ShowCollectionsRequest) (*milvuspb.ShowCollectionsResponse, error)) *MilvusServiceServer_ShowCollections_Call {
	_c.Call.Return(run)
	return _c
}

// ShowPartitions provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) ShowPartitions(_a0 context.Context, _a1 *milvuspb.ShowPartitionsRequest) (*milvuspb.ShowPartitionsResponse, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ShowPartitions")
	}

	var r0 *milvuspb.ShowPartitionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ShowPartitionsRequest) (*milvuspb.ShowPartitionsResponse, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.ShowPartitionsRequest) *milvuspb.ShowPartitionsResponse); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.ShowPartitionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.ShowPartitionsRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_ShowPartitions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShowPartitions'
type MilvusServiceServer_ShowPartitions_Call struct {
	*mock.Call
}

// ShowPartitions is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.ShowPartitionsRequest
func (_e *MilvusServiceServer_Expecter) ShowPartitions(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_ShowPartitions_Call {
	return &MilvusServiceServer_ShowPartitions_Call{Call: _e.mock.On("ShowPartitions", _a0, _a1)}
}

func (_c *MilvusServiceServer_ShowPartitions_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.ShowPartitionsRequest)) *MilvusServiceServer_ShowPartitions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.ShowPartitionsRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_ShowPartitions_Call) Return(_a0 *milvuspb.ShowPartitionsResponse, _a1 error) *MilvusServiceServer_ShowPartitions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_ShowPartitions_Call) RunAndReturn(run func(context.Context, *milvuspb.ShowPartitionsRequest) (*milvuspb.ShowPartitionsResponse, error)) *MilvusServiceServer_ShowPartitions_Call {
	_c.Call.Return(run)
	return _c
}

// TransferNode provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) TransferNode(_a0 context.Context, _a1 *milvuspb.TransferNodeRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for TransferNode")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.TransferNodeRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.TransferNodeRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.TransferNodeRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_TransferNode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransferNode'
type MilvusServiceServer_TransferNode_Call struct {
	*mock.Call
}

// TransferNode is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.TransferNodeRequest
func (_e *MilvusServiceServer_Expecter) TransferNode(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_TransferNode_Call {
	return &MilvusServiceServer_TransferNode_Call{Call: _e.mock.On("TransferNode", _a0, _a1)}
}

func (_c *MilvusServiceServer_TransferNode_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.TransferNodeRequest)) *MilvusServiceServer_TransferNode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.TransferNodeRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_TransferNode_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_TransferNode_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_TransferNode_Call) RunAndReturn(run func(context.Context, *milvuspb.TransferNodeRequest) (*commonpb.Status, error)) *MilvusServiceServer_TransferNode_Call {
	_c.Call.Return(run)
	return _c
}

// TransferReplica provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) TransferReplica(_a0 context.Context, _a1 *milvuspb.TransferReplicaRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for TransferReplica")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.TransferReplicaRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.TransferReplicaRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.TransferReplicaRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_TransferReplica_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransferReplica'
type MilvusServiceServer_TransferReplica_Call struct {
	*mock.Call
}

// TransferReplica is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.TransferReplicaRequest
func (_e *MilvusServiceServer_Expecter) TransferReplica(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_TransferReplica_Call {
	return &MilvusServiceServer_TransferReplica_Call{Call: _e.mock.On("TransferReplica", _a0, _a1)}
}

func (_c *MilvusServiceServer_TransferReplica_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.TransferReplicaRequest)) *MilvusServiceServer_TransferReplica_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.TransferReplicaRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_TransferReplica_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_TransferReplica_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_TransferReplica_Call) RunAndReturn(run func(context.Context, *milvuspb.TransferReplicaRequest) (*commonpb.Status, error)) *MilvusServiceServer_TransferReplica_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCredential provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) UpdateCredential(_a0 context.Context, _a1 *milvuspb.UpdateCredentialRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCredential")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.UpdateCredentialRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.UpdateCredentialRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.UpdateCredentialRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_UpdateCredential_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCredential'
type MilvusServiceServer_UpdateCredential_Call struct {
	*mock.Call
}

// UpdateCredential is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.UpdateCredentialRequest
func (_e *MilvusServiceServer_Expecter) UpdateCredential(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_UpdateCredential_Call {
	return &MilvusServiceServer_UpdateCredential_Call{Call: _e.mock.On("UpdateCredential", _a0, _a1)}
}

func (_c *MilvusServiceServer_UpdateCredential_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.UpdateCredentialRequest)) *MilvusServiceServer_UpdateCredential_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.UpdateCredentialRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_UpdateCredential_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_UpdateCredential_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_UpdateCredential_Call) RunAndReturn(run func(context.Context, *milvuspb.UpdateCredentialRequest) (*commonpb.Status, error)) *MilvusServiceServer_UpdateCredential_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateResourceGroups provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) UpdateResourceGroups(_a0 context.Context, _a1 *milvuspb.UpdateResourceGroupsRequest) (*commonpb.Status, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for UpdateResourceGroups")
	}

	var r0 *commonpb.Status
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.UpdateResourceGroupsRequest) (*commonpb.Status, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.UpdateResourceGroupsRequest) *commonpb.Status); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commonpb.Status)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.UpdateResourceGroupsRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_UpdateResourceGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateResourceGroups'
type MilvusServiceServer_UpdateResourceGroups_Call struct {
	*mock.Call
}

// UpdateResourceGroups is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.UpdateResourceGroupsRequest
func (_e *MilvusServiceServer_Expecter) UpdateResourceGroups(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_UpdateResourceGroups_Call {
	return &MilvusServiceServer_UpdateResourceGroups_Call{Call: _e.mock.On("UpdateResourceGroups", _a0, _a1)}
}

func (_c *MilvusServiceServer_UpdateResourceGroups_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.UpdateResourceGroupsRequest)) *MilvusServiceServer_UpdateResourceGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.UpdateResourceGroupsRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_UpdateResourceGroups_Call) Return(_a0 *commonpb.Status, _a1 error) *MilvusServiceServer_UpdateResourceGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_UpdateResourceGroups_Call) RunAndReturn(run func(context.Context, *milvuspb.UpdateResourceGroupsRequest) (*commonpb.Status, error)) *MilvusServiceServer_UpdateResourceGroups_Call {
	_c.Call.Return(run)
	return _c
}

// Upsert provides a mock function with given fields: _a0, _a1
func (_m *MilvusServiceServer) Upsert(_a0 context.Context, _a1 *milvuspb.UpsertRequest) (*milvuspb.MutationResult, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Upsert")
	}

	var r0 *milvuspb.MutationResult
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.UpsertRequest) (*milvuspb.MutationResult, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *milvuspb.UpsertRequest) *milvuspb.MutationResult); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*milvuspb.MutationResult)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *milvuspb.UpsertRequest) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MilvusServiceServer_Upsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upsert'
type MilvusServiceServer_Upsert_Call struct {
	*mock.Call
}

// Upsert is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *milvuspb.UpsertRequest
func (_e *MilvusServiceServer_Expecter) Upsert(_a0 interface{}, _a1 interface{}) *MilvusServiceServer_Upsert_Call {
	return &MilvusServiceServer_Upsert_Call{Call: _e.mock.On("Upsert", _a0, _a1)}
}

func (_c *MilvusServiceServer_Upsert_Call) Run(run func(_a0 context.Context, _a1 *milvuspb.UpsertRequest)) *MilvusServiceServer_Upsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*milvuspb.UpsertRequest))
	})
	return _c
}

func (_c *MilvusServiceServer_Upsert_Call) Return(_a0 *milvuspb.MutationResult, _a1 error) *MilvusServiceServer_Upsert_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MilvusServiceServer_Upsert_Call) RunAndReturn(run func(context.Context, *milvuspb.UpsertRequest) (*milvuspb.MutationResult, error)) *MilvusServiceServer_Upsert_Call {
	_c.Call.Return(run)
	return _c
}

// NewMilvusServiceServer creates a new instance of MilvusServiceServer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMilvusServiceServer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MilvusServiceServer {
	mock := &MilvusServiceServer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}



---
File: /milvusclient/partition_example_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// nolint
package milvusclient_test

import (
	"context"
	"fmt"

	"github.com/milvus-io/milvus/client/v2/milvusclient"
)

func ExampleClient_ListPartitions() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	partitionNames, err := cli.ListPartitions(ctx, milvusclient.NewListPartitionOption("quick_setup"))
	if err != nil {
		// handle error
	}

	fmt.Println(partitionNames)
}

func ExampleClient_CreatePartition() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	err = cli.CreatePartition(ctx, milvusclient.NewCreatePartitionOption("quick_setup", "partitionA"))
	if err != nil {
		// handle error
	}

	partitionNames, err := cli.ListPartitions(ctx, milvusclient.NewListPartitionOption("quick_setup"))
	if err != nil {
		// handle error
	}

	fmt.Println(partitionNames)
}

func ExampleClient_HasPartition() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)
	result, err := cli.HasPartition(ctx, milvusclient.NewHasPartitionOption("quick_setup", "partitionA"))
	if err != nil {
		// handle error
	}

	fmt.Println(result)
}

func ExampleClient_LoadPartitions() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	task, err := cli.LoadPartitions(ctx, milvusclient.NewLoadPartitionsOption("quick_setup", "partitionA"))

	// sync wait collection to be loaded
	err = task.Await(ctx)
	if err != nil {
		// handle error
	}
}

func ExampleClient_ReleasePartitions() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	err = cli.ReleasePartitions(ctx, milvusclient.NewReleasePartitionsOptions("quick_setup", "partitionA"))
	if err != nil {
		// handle error
	}
}

func ExampleClient_DropPartition() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	err = cli.DropPartition(ctx, milvusclient.NewDropPartitionOption("quick_setup", "partitionA"))
	if err != nil {
		// handle error
	}
}



---
File: /milvusclient/partition_options.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import "github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"

// CreatePartitionOption is the interface builds Create Partition request.
type CreatePartitionOption interface {
	// Request is the method returns the composed request.
	Request() *milvuspb.CreatePartitionRequest
}

type createPartitionOpt struct {
	collectionName string
	partitionName  string
}

func (opt *createPartitionOpt) Request() *milvuspb.CreatePartitionRequest {
	return &milvuspb.CreatePartitionRequest{
		CollectionName: opt.collectionName,
		PartitionName:  opt.partitionName,
	}
}

func NewCreatePartitionOption(collectionName string, partitionName string) *createPartitionOpt {
	return &createPartitionOpt{
		collectionName: collectionName,
		partitionName:  partitionName,
	}
}

// DropPartitionOption is the interface that builds Drop Partition request.
type DropPartitionOption interface {
	// Request is the method returns the composed request.
	Request() *milvuspb.DropPartitionRequest
}

type dropPartitionOpt struct {
	collectionName string
	partitionName  string
}

func (opt *dropPartitionOpt) Request() *milvuspb.DropPartitionRequest {
	return &milvuspb.DropPartitionRequest{
		CollectionName: opt.collectionName,
		PartitionName:  opt.partitionName,
	}
}

func NewDropPartitionOption(collectionName string, partitionName string) *dropPartitionOpt {
	return &dropPartitionOpt{
		collectionName: collectionName,
		partitionName:  partitionName,
	}
}

// HasPartitionOption is the interface builds HasPartition request.
type HasPartitionOption interface {
	// Request is the method returns the composed request.
	Request() *milvuspb.HasPartitionRequest
}

var _ HasPartitionOption = (*hasPartitionOpt)(nil)

type hasPartitionOpt struct {
	collectionName string
	partitionName  string
}

func (opt *hasPartitionOpt) Request() *milvuspb.HasPartitionRequest {
	return &milvuspb.HasPartitionRequest{
		CollectionName: opt.collectionName,
		PartitionName:  opt.partitionName,
	}
}

func NewHasPartitionOption(collectionName string, partitionName string) *hasPartitionOpt {
	return &hasPartitionOpt{
		collectionName: collectionName,
		partitionName:  partitionName,
	}
}

// ListPartitionsOption is the interface builds List Partition request.
type ListPartitionsOption interface {
	// Request is the method returns the composed request.
	Request() *milvuspb.ShowPartitionsRequest
}

type listPartitionsOpt struct {
	collectionName string
}

func (opt *listPartitionsOpt) Request() *milvuspb.ShowPartitionsRequest {
	return &milvuspb.ShowPartitionsRequest{
		CollectionName: opt.collectionName,
		Type:           milvuspb.ShowType_All,
	}
}

func NewListPartitionOption(collectionName string) *listPartitionsOpt {
	return &listPartitionsOpt{
		collectionName: collectionName,
	}
}

type GetPartitionStatsOption interface {
	Request() *milvuspb.GetPartitionStatisticsRequest
}

type getPartitionStatsOpt struct {
	collectionName string
	partitionName  string
}

func (opt *getPartitionStatsOpt) Request() *milvuspb.GetPartitionStatisticsRequest {
	return &milvuspb.GetPartitionStatisticsRequest{
		CollectionName: opt.collectionName,
		PartitionName:  opt.partitionName,
	}
}

func NewGetPartitionStatsOption(collectionName string, partitionName string) *getPartitionStatsOpt {
	return &getPartitionStatsOpt{
		collectionName: collectionName,
		partitionName:  partitionName,
	}
}



---
File: /milvusclient/partition_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"fmt"
	"testing"

	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type PartitionSuite struct {
	MockSuiteBase
}

func (s *PartitionSuite) TestListPartitions() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))

		s.mock.EXPECT().ShowPartitions(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, spr *milvuspb.ShowPartitionsRequest) (*milvuspb.ShowPartitionsResponse, error) {
			s.Equal(collectionName, spr.GetCollectionName())
			return &milvuspb.ShowPartitionsResponse{
				Status:         merr.Success(),
				PartitionNames: []string{"_default", "part_1"},
				PartitionIDs:   []int64{100, 101},
			}, nil
		}).Once()

		names, err := s.client.ListPartitions(ctx, NewListPartitionOption(collectionName))
		s.NoError(err)
		s.ElementsMatch([]string{"_default", "part_1"}, names)
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))

		s.mock.EXPECT().ShowPartitions(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.ListPartitions(ctx, NewListPartitionOption(collectionName))
		s.Error(err)
	})
}

func (s *PartitionSuite) TestCreatePartition() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))

		s.mock.EXPECT().CreatePartition(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, cpr *milvuspb.CreatePartitionRequest) (*commonpb.Status, error) {
			s.Equal(collectionName, cpr.GetCollectionName())
			s.Equal(partitionName, cpr.GetPartitionName())
			return merr.Success(), nil
		}).Once()

		err := s.client.CreatePartition(ctx, NewCreatePartitionOption(collectionName, partitionName))
		s.NoError(err)
	})

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))

		s.mock.EXPECT().CreatePartition(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.CreatePartition(ctx, NewCreatePartitionOption(collectionName, partitionName))
		s.Error(err)
	})
}

func (s *PartitionSuite) TestHasPartition() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))

		s.mock.EXPECT().HasPartition(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, hpr *milvuspb.HasPartitionRequest) (*milvuspb.BoolResponse, error) {
			s.Equal(collectionName, hpr.GetCollectionName())
			s.Equal(partitionName, hpr.GetPartitionName())
			return &milvuspb.BoolResponse{Status: merr.Success()}, nil
		}).Once()

		has, err := s.client.HasPartition(ctx, NewHasPartitionOption(collectionName, partitionName))
		s.NoError(err)
		s.False(has)

		s.mock.EXPECT().HasPartition(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, hpr *milvuspb.HasPartitionRequest) (*milvuspb.BoolResponse, error) {
			s.Equal(collectionName, hpr.GetCollectionName())
			s.Equal(partitionName, hpr.GetPartitionName())
			return &milvuspb.BoolResponse{
				Status: merr.Success(),
				Value:  true,
			}, nil
		}).Once()

		has, err = s.client.HasPartition(ctx, NewHasPartitionOption(collectionName, partitionName))
		s.NoError(err)
		s.True(has)
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))
		s.mock.EXPECT().HasPartition(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.HasPartition(ctx, NewHasPartitionOption(collectionName, partitionName))
		s.Error(err)
	})
}

func (s *PartitionSuite) TestDropPartition() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))
		s.mock.EXPECT().DropPartition(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, dpr *milvuspb.DropPartitionRequest) (*commonpb.Status, error) {
			s.Equal(collectionName, dpr.GetCollectionName())
			s.Equal(partitionName, dpr.GetPartitionName())
			return merr.Success(), nil
		}).Once()

		err := s.client.DropPartition(ctx, NewDropPartitionOption(collectionName, partitionName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))
		s.mock.EXPECT().DropPartition(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.DropPartition(ctx, NewDropPartitionOption(collectionName, partitionName))
		s.Error(err)
	})
}

func (s *PartitionSuite) TestGetPartitionStats() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))
		s.mock.EXPECT().GetPartitionStatistics(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, gpsr *milvuspb.GetPartitionStatisticsRequest) (*milvuspb.GetPartitionStatisticsResponse, error) {
			s.Equal(collectionName, gpsr.GetCollectionName())
			s.Equal(partitionName, gpsr.GetPartitionName())
			return &milvuspb.GetPartitionStatisticsResponse{
				Status: merr.Success(),
				Stats: []*commonpb.KeyValuePair{
					{Key: "rows", Value: "100"},
				},
			}, nil
		}).Once()

		stats, err := s.client.GetPartitionStats(ctx, NewGetPartitionStatsOption(collectionName, partitionName))
		s.NoError(err)
		s.Equal("100", stats["rows"])
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))
		s.mock.EXPECT().GetPartitionStatistics(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.GetPartitionStats(ctx, NewGetPartitionStatsOption(collectionName, partitionName))
		s.Error(err)
	})
}

func TestPartition(t *testing.T) {
	suite.Run(t, new(PartitionSuite))
}



---
File: /milvusclient/partition.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"

	"google.golang.org/grpc"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

// CreatePartition is the API for creating a partition for a collection.
func (c *Client) CreatePartition(ctx context.Context, opt CreatePartitionOption, callOptions ...grpc.CallOption) error {
	req := opt.Request()

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.CreatePartition(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})

	return err
}

func (c *Client) DropPartition(ctx context.Context, opt DropPartitionOption, callOptions ...grpc.CallOption) error {
	req := opt.Request()

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DropPartition(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
	return err
}

func (c *Client) HasPartition(ctx context.Context, opt HasPartitionOption, callOptions ...grpc.CallOption) (has bool, err error) {
	req := opt.Request()

	err = c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.HasPartition(ctx, req, callOptions...)
		err = merr.CheckRPCCall(resp, err)
		if err != nil {
			return err
		}
		has = resp.GetValue()
		return nil
	})
	return has, err
}

func (c *Client) ListPartitions(ctx context.Context, opt ListPartitionsOption, callOptions ...grpc.CallOption) (partitionNames []string, err error) {
	req := opt.Request()

	err = c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.ShowPartitions(ctx, req, callOptions...)
		err = merr.CheckRPCCall(resp, err)
		if err != nil {
			return err
		}
		partitionNames = resp.GetPartitionNames()
		return nil
	})
	return partitionNames, err
}

func (c *Client) GetPartitionStats(ctx context.Context, opt GetPartitionStatsOption, callOptions ...grpc.CallOption) (map[string]string, error) {
	req := opt.Request()

	var result map[string]string

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.GetPartitionStatistics(ctx, req, callOptions...)
		err = merr.CheckRPCCall(resp, err)
		if err != nil {
			return err
		}
		result = entity.KvPairsMap(resp.GetStats())
		return nil
	})
	return result, err
}



---
File: /milvusclient/rbac_example_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// nolint
package milvusclient_test

import (
	"context"

	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/milvusclient"
)

func ExampleClient_GrantPrivilege() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	readOnlyPrivileges := []*entity.RoleGrants{
		{Object: "Global", ObjectName: "*", PrivilegeName: "DescribeCollection"},
		{Object: "Global", ObjectName: "*", PrivilegeName: "ShowCollections"},
		{Object: "Collection", ObjectName: "quick_setup", PrivilegeName: "Search"},
	}

	for _, grantItem := range readOnlyPrivileges {
		err := cli.GrantPrivilege(ctx, milvusclient.NewGrantPrivilegeOption("my_role", grantItem.Object, grantItem.PrivilegeName, grantItem.ObjectName))
		if err != nil {
			// handle error
		}
	}
}

func ExampleClient_GrantPrivilegeV2() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	err = cli.GrantPrivilegeV2(ctx, milvusclient.NewGrantPrivilegeV2Option("my_role", "Search", "quick_setup"))
	if err != nil {
		// handle error
	}
}



---
File: /milvusclient/rbac_options.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"github.com/samber/lo"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/pkg/v2/util/crypto"
)

type ListUserOption interface {
	Request() *milvuspb.ListCredUsersRequest
}

// listUserOption is the struct to build ListCredUsersRequest
// left empty for not attribute needed right now
type listUserOption struct{}

func (opt *listUserOption) Request() *milvuspb.ListCredUsersRequest {
	return &milvuspb.ListCredUsersRequest{}
}

func NewListUserOption() *listUserOption {
	return &listUserOption{}
}

type DescribeUserOption interface {
	Request() *milvuspb.SelectUserRequest
}

type describeUserOption struct {
	userName string
}

func (opt *describeUserOption) Request() *milvuspb.SelectUserRequest {
	return &milvuspb.SelectUserRequest{
		User: &milvuspb.UserEntity{
			Name: opt.userName,
		},
		IncludeRoleInfo: true,
	}
}

func NewDescribeUserOption(userName string) *describeUserOption {
	return &describeUserOption{
		userName: userName,
	}
}

type CreateUserOption interface {
	Request() *milvuspb.CreateCredentialRequest
}

type createUserOption struct {
	userName string
	password string
}

func (opt *createUserOption) Request() *milvuspb.CreateCredentialRequest {
	return &milvuspb.CreateCredentialRequest{
		Username: opt.userName,
		Password: crypto.Base64Encode(opt.password),
	}
}

func NewCreateUserOption(userName, password string) *createUserOption {
	return &createUserOption{
		userName: userName,
		password: password,
	}
}

type UpdatePasswordOption interface {
	Request() *milvuspb.UpdateCredentialRequest
}

type updatePasswordOption struct {
	userName    string
	oldPassword string
	newPassword string
}

func (opt *updatePasswordOption) Request() *milvuspb.UpdateCredentialRequest {
	return &milvuspb.UpdateCredentialRequest{
		Username:    opt.userName,
		OldPassword: crypto.Base64Encode(opt.oldPassword),
		NewPassword: crypto.Base64Encode(opt.newPassword),
	}
}

func NewUpdatePasswordOption(userName, oldPassword, newPassword string) *updatePasswordOption {
	return &updatePasswordOption{
		userName:    userName,
		oldPassword: oldPassword,
		newPassword: newPassword,
	}
}

type DropUserOption interface {
	Request() *milvuspb.DeleteCredentialRequest
}

type dropUserOption struct {
	userName string
}

func (opt *dropUserOption) Request() *milvuspb.DeleteCredentialRequest {
	return &milvuspb.DeleteCredentialRequest{
		Username: opt.userName,
	}
}

func NewDropUserOption(userName string) *dropUserOption {
	return &dropUserOption{
		userName: userName,
	}
}

type ListRoleOption interface {
	Request() *milvuspb.SelectRoleRequest
}

type listRoleOption struct{}

func (opt *listRoleOption) Request() *milvuspb.SelectRoleRequest {
	return &milvuspb.SelectRoleRequest{
		IncludeUserInfo: false,
	}
}

func NewListRoleOption() *listRoleOption {
	return &listRoleOption{}
}

type CreateRoleOption interface {
	Request() *milvuspb.CreateRoleRequest
}

type createRoleOption struct {
	roleName string
}

func (opt *createRoleOption) Request() *milvuspb.CreateRoleRequest {
	return &milvuspb.CreateRoleRequest{
		Entity: &milvuspb.RoleEntity{Name: opt.roleName},
	}
}

func NewCreateRoleOption(roleName string) *createRoleOption {
	return &createRoleOption{
		roleName: roleName,
	}
}

type GrantRoleOption interface {
	Request() *milvuspb.OperateUserRoleRequest
}

type grantRoleOption struct {
	roleName string
	userName string
}

func (opt *grantRoleOption) Request() *milvuspb.OperateUserRoleRequest {
	return &milvuspb.OperateUserRoleRequest{
		Username: opt.userName,
		RoleName: opt.roleName,
		Type:     milvuspb.OperateUserRoleType_AddUserToRole,
	}
}

func NewGrantRoleOption(userName, roleName string) *grantRoleOption {
	return &grantRoleOption{
		roleName: roleName,
		userName: userName,
	}
}

type RevokeRoleOption interface {
	Request() *milvuspb.OperateUserRoleRequest
}

type revokeRoleOption struct {
	roleName string
	userName string
}

func (opt *revokeRoleOption) Request() *milvuspb.OperateUserRoleRequest {
	return &milvuspb.OperateUserRoleRequest{
		Username: opt.userName,
		RoleName: opt.roleName,
		Type:     milvuspb.OperateUserRoleType_RemoveUserFromRole,
	}
}

func NewRevokeRoleOption(userName, roleName string) *revokeRoleOption {
	return &revokeRoleOption{
		roleName: roleName,
		userName: userName,
	}
}

type DropRoleOption interface {
	Request() *milvuspb.DropRoleRequest
}

type dropDropRoleOption struct {
	roleName string
}

func (opt *dropDropRoleOption) Request() *milvuspb.DropRoleRequest {
	return &milvuspb.DropRoleRequest{
		RoleName: opt.roleName,
	}
}

func NewDropRoleOption(roleName string) *dropDropRoleOption {
	return &dropDropRoleOption{
		roleName: roleName,
	}
}

type DescribeRoleOption interface {
	SelectRoleRequest() *milvuspb.SelectRoleRequest
	Request() *milvuspb.SelectGrantRequest
}

type describeRoleOption struct {
	roleName string
	dbName   string
}

func (opt *describeRoleOption) SelectRoleRequest() *milvuspb.SelectRoleRequest {
	return &milvuspb.SelectRoleRequest{
		Role: &milvuspb.RoleEntity{
			Name: opt.roleName,
		},
	}
}

func (opt *describeRoleOption) Request() *milvuspb.SelectGrantRequest {
	return &milvuspb.SelectGrantRequest{
		Entity: &milvuspb.GrantEntity{
			Role:   &milvuspb.RoleEntity{Name: opt.roleName},
			DbName: opt.dbName,
		},
	}
}

func NewDescribeRoleOption(roleName string) *describeRoleOption {
	return &describeRoleOption{
		roleName: roleName,
	}
}

func (opt *describeRoleOption) WithDbName(dbName string) *describeRoleOption {
	opt.dbName = dbName
	return opt
}

type GrantPrivilegeOption interface {
	Request() *milvuspb.OperatePrivilegeRequest
}

type grantPrivilegeOption struct {
	roleName      string
	privilegeName string
	objectName    string
	objectType    string
	dbName        string
}

func (opt *grantPrivilegeOption) Request() *milvuspb.OperatePrivilegeRequest {
	return &milvuspb.OperatePrivilegeRequest{
		Entity: &milvuspb.GrantEntity{
			Role: &milvuspb.RoleEntity{Name: opt.roleName},
			Grantor: &milvuspb.GrantorEntity{
				Privilege: &milvuspb.PrivilegeEntity{Name: opt.privilegeName},
			},
			Object: &milvuspb.ObjectEntity{
				Name: opt.objectType,
			},
			ObjectName: opt.objectName,
			DbName:     opt.dbName,
		},

		Type: milvuspb.OperatePrivilegeType_Grant,
	}
}

func NewGrantPrivilegeOption(roleName, objectType, privilegeName, objectName string) *grantPrivilegeOption {
	return &grantPrivilegeOption{
		roleName:      roleName,
		privilegeName: privilegeName,
		objectName:    objectName,
		objectType:    objectType,
	}
}

func (opt *grantPrivilegeOption) WithDbName(dbName string) *grantPrivilegeOption {
	opt.dbName = dbName
	return opt
}

type RevokePrivilegeOption interface {
	Request() *milvuspb.OperatePrivilegeRequest
}

type revokePrivilegeOption struct {
	roleName      string
	privilegeName string
	objectName    string
	objectType    string
	dbName        string
}

func (opt *revokePrivilegeOption) Request() *milvuspb.OperatePrivilegeRequest {
	return &milvuspb.OperatePrivilegeRequest{
		Entity: &milvuspb.GrantEntity{
			Role: &milvuspb.RoleEntity{Name: opt.roleName},
			Grantor: &milvuspb.GrantorEntity{
				Privilege: &milvuspb.PrivilegeEntity{Name: opt.privilegeName},
			},
			Object: &milvuspb.ObjectEntity{
				Name: opt.objectType,
			},
			ObjectName: opt.objectName,
			DbName:     opt.dbName,
		},

		Type: milvuspb.OperatePrivilegeType_Revoke,
	}
}

func NewRevokePrivilegeOption(roleName, objectType, privilegeName, objectName string) *revokePrivilegeOption {
	return &revokePrivilegeOption{
		roleName:      roleName,
		privilegeName: privilegeName,
		objectName:    objectName,
		objectType:    objectType,
	}
}

func (opt *revokePrivilegeOption) WithDbName(dbName string) *revokePrivilegeOption {
	opt.dbName = dbName
	return opt
}

type GrantV2Option GrantPrivilegeV2Option

// GrantPrivilegeV2Option is the interface builds OperatePrivilegeV2Request
type GrantPrivilegeV2Option interface {
	Request() *milvuspb.OperatePrivilegeV2Request
}

type grantPrivilegeV2Option struct {
	roleName       string
	privilegeName  string
	dbName         string
	collectionName string
}

func (opt *grantPrivilegeV2Option) Request() *milvuspb.OperatePrivilegeV2Request {
	return &milvuspb.OperatePrivilegeV2Request{
		Role: &milvuspb.RoleEntity{Name: opt.roleName},
		Grantor: &milvuspb.GrantorEntity{
			Privilege: &milvuspb.PrivilegeEntity{Name: opt.privilegeName},
		},
		Type:           milvuspb.OperatePrivilegeType_Grant,
		DbName:         opt.dbName,
		CollectionName: opt.collectionName,
	}
}

// Deprecated, use `NewGrantPrivilegeV2Option` instead
func NewGrantV2Option(roleName, privilegeName, dbName, collectionName string) *grantPrivilegeV2Option {
	return &grantPrivilegeV2Option{
		roleName:       roleName,
		privilegeName:  privilegeName,
		dbName:         dbName,
		collectionName: collectionName,
	}
}

func NewGrantPrivilegeV2Option(roleName, privilegeName, collectionName string) *grantPrivilegeV2Option {
	return &grantPrivilegeV2Option{
		roleName:       roleName,
		privilegeName:  privilegeName,
		collectionName: collectionName,
	}
}

func (opt *grantPrivilegeV2Option) WithDbName(dbName string) *grantPrivilegeV2Option {
	opt.dbName = dbName
	return opt
}

type RevokeV2Option RevokePrivilegeV2Option

// RevokePrivilegeV2Option is the interface builds OperatePrivilegeV2Request
type RevokePrivilegeV2Option interface {
	Request() *milvuspb.OperatePrivilegeV2Request
}

type revokePrivilegeV2Option struct {
	roleName       string
	privilegeName  string
	dbName         string
	collectionName string
}

func (opt *revokePrivilegeV2Option) Request() *milvuspb.OperatePrivilegeV2Request {
	return &milvuspb.OperatePrivilegeV2Request{
		Role: &milvuspb.RoleEntity{Name: opt.roleName},
		Grantor: &milvuspb.GrantorEntity{
			Privilege: &milvuspb.PrivilegeEntity{Name: opt.privilegeName},
		},
		Type:           milvuspb.OperatePrivilegeType_Revoke,
		DbName:         opt.dbName,
		CollectionName: opt.collectionName,
	}
}

// Deprecated, use `NewRevokePrivilegeV2Option` instead
func NewRevokeV2Option(roleName, privilegeName, dbName, collectionName string) *revokePrivilegeV2Option {
	return &revokePrivilegeV2Option{
		roleName:       roleName,
		privilegeName:  privilegeName,
		dbName:         dbName,
		collectionName: collectionName,
	}
}

func NewRevokePrivilegeV2Option(roleName, privilegeName, collectionName string) *revokePrivilegeV2Option {
	return &revokePrivilegeV2Option{
		roleName:       roleName,
		privilegeName:  privilegeName,
		collectionName: collectionName,
	}
}

func (opt *revokePrivilegeV2Option) WithDbName(dbName string) *revokePrivilegeV2Option {
	opt.dbName = dbName
	return opt
}

// CreatePrivilegeGroupOption is the interface builds CreatePrivilegeGroupRequest
type CreatePrivilegeGroupOption interface {
	Request() *milvuspb.CreatePrivilegeGroupRequest
}

type createPrivilegeGroupOption struct {
	groupName string
}

func (opt *createPrivilegeGroupOption) Request() *milvuspb.CreatePrivilegeGroupRequest {
	return &milvuspb.CreatePrivilegeGroupRequest{
		GroupName: opt.groupName,
	}
}

func NewCreatePrivilegeGroupOption(groupName string) *createPrivilegeGroupOption {
	return &createPrivilegeGroupOption{
		groupName: groupName,
	}
}

// DropPrivilegeGroupOption is the interface builds DropPrivilegeGroupRequest
type DropPrivilegeGroupOption interface {
	Request() *milvuspb.DropPrivilegeGroupRequest
}

type dropPrivilegeGroupOption struct {
	groupName string
}

func (opt *dropPrivilegeGroupOption) Request() *milvuspb.DropPrivilegeGroupRequest {
	return &milvuspb.DropPrivilegeGroupRequest{
		GroupName: opt.groupName,
	}
}

func NewDropPrivilegeGroupOption(groupName string) *dropPrivilegeGroupOption {
	return &dropPrivilegeGroupOption{
		groupName: groupName,
	}
}

// ListPrivilegeGroupsOption is the interface builds ListPrivilegeGroupsRequest
type ListPrivilegeGroupsOption interface {
	Request() *milvuspb.ListPrivilegeGroupsRequest
}

type listPrivilegeGroupsOption struct{}

func (opt *listPrivilegeGroupsOption) Request() *milvuspb.ListPrivilegeGroupsRequest {
	return &milvuspb.ListPrivilegeGroupsRequest{}
}

func NewListPrivilegeGroupsOption() *listPrivilegeGroupsOption {
	return &listPrivilegeGroupsOption{}
}

// OperatePrivilegeGroupOption is the interface builds OperatePrivilegeGroupRequest
type OperatePrivilegeGroupOption interface {
	Request() *milvuspb.OperatePrivilegeGroupRequest
}

type operatePrivilegeGroupOption struct {
	groupName   string
	privileges  []*milvuspb.PrivilegeEntity
	operateType milvuspb.OperatePrivilegeGroupType
}

func (opt *operatePrivilegeGroupOption) Request() *milvuspb.OperatePrivilegeGroupRequest {
	return &milvuspb.OperatePrivilegeGroupRequest{
		GroupName:  opt.groupName,
		Privileges: opt.privileges,
		Type:       opt.operateType,
	}
}

// Deprecated, use AddPrivilegeToGroupOption/ RemovePrivilegeFromGroupOption instead
func NewOperatePrivilegeGroupOption(groupName string, privileges []*milvuspb.PrivilegeEntity, operateType milvuspb.OperatePrivilegeGroupType) *operatePrivilegeGroupOption {
	return &operatePrivilegeGroupOption{
		groupName:   groupName,
		privileges:  privileges,
		operateType: operateType,
	}
}

type AddPrivilegeToGroupOption interface {
	Request() *milvuspb.OperatePrivilegeGroupRequest
}

type addPrivilegeToGroupOption struct {
	privileges []string
	groupName  string
}

func (opt *addPrivilegeToGroupOption) Request() *milvuspb.OperatePrivilegeGroupRequest {
	return &milvuspb.OperatePrivilegeGroupRequest{
		GroupName: opt.groupName,
		Privileges: lo.Map(opt.privileges, func(privilege string, _ int) *milvuspb.PrivilegeEntity {
			return &milvuspb.PrivilegeEntity{
				Name: privilege,
			}
		}),
		Type: milvuspb.OperatePrivilegeGroupType_AddPrivilegesToGroup,
	}
}

func NewAddPrivilegesToGroupOption(groupName string, privileges ...string) *addPrivilegeToGroupOption {
	return &addPrivilegeToGroupOption{
		groupName:  groupName,
		privileges: privileges,
	}
}

type RemovePrivilegeFromGroupOption interface {
	Request() *milvuspb.OperatePrivilegeGroupRequest
}

type removePrivilegeFromGroupOption struct {
	privileges []string
	groupName  string
}

func (opt *removePrivilegeFromGroupOption) Request() *milvuspb.OperatePrivilegeGroupRequest {
	return &milvuspb.OperatePrivilegeGroupRequest{
		GroupName: opt.groupName,
		Privileges: lo.Map(opt.privileges, func(privilege string, _ int) *milvuspb.PrivilegeEntity {
			return &milvuspb.PrivilegeEntity{
				Name: privilege,
			}
		}),
		Type: milvuspb.OperatePrivilegeGroupType_RemovePrivilegesFromGroup,
	}
}

func NewRemovePrivilegesFromGroupOption(groupName string, privileges ...string) *removePrivilegeFromGroupOption {
	return &removePrivilegeFromGroupOption{
		groupName:  groupName,
		privileges: privileges,
	}
}



---
File: /milvusclient/rbac_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"fmt"
	"testing"

	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/pkg/v2/util/crypto"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type UserSuite struct {
	MockSuiteBase
}

func (s *UserSuite) TestListUsers() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		s.mock.EXPECT().ListCredUsers(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.ListCredUsersRequest) (*milvuspb.ListCredUsersResponse, error) {
			return &milvuspb.ListCredUsersResponse{
				Usernames: []string{"user1", "user2"},
			}, nil
		}).Once()

		users, err := s.client.ListUsers(ctx, NewListUserOption())
		s.NoError(err)
		s.Equal([]string{"user1", "user2"}, users)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().ListCredUsers(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.ListUsers(ctx, NewListUserOption())
		s.Error(err)
	})
}

func (s *UserSuite) TestDescribeUser() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	userName := fmt.Sprintf("user_%s", s.randString(5))

	s.Run("success", func() {
		s.mock.EXPECT().SelectUser(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.SelectUserRequest) (*milvuspb.SelectUserResponse, error) {
			s.Equal(userName, r.GetUser().GetName())
			return &milvuspb.SelectUserResponse{
				Results: []*milvuspb.UserResult{
					{
						User: &milvuspb.UserEntity{Name: userName},
						Roles: []*milvuspb.RoleEntity{
							{Name: "role1"},
							{Name: "role2"},
						},
					},
				},
			}, nil
		}).Once()

		user, err := s.client.DescribeUser(ctx, NewDescribeUserOption(userName))
		s.NoError(err)
		s.Equal(userName, user.UserName)
		s.Equal([]string{"role1", "role2"}, user.Roles)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().SelectUser(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.DescribeUser(ctx, NewDescribeUserOption(userName))
		s.Error(err)
	})
}

func (s *UserSuite) TestCreateUser() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		userName := fmt.Sprintf("user_%s", s.randString(5))
		password := s.randString(12)
		s.mock.EXPECT().CreateCredential(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, ccr *milvuspb.CreateCredentialRequest) (*commonpb.Status, error) {
			s.Equal(userName, ccr.GetUsername())
			s.Equal(crypto.Base64Encode(password), ccr.GetPassword())
			return merr.Success(), nil
		}).Once()

		err := s.client.CreateUser(ctx, NewCreateUserOption(userName, password))
		s.NoError(err)
	})
}

func (s *UserSuite) TestUpdatePassword() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		userName := fmt.Sprintf("user_%s", s.randString(5))
		oldPassword := s.randString(12)
		newPassword := s.randString(12)
		s.mock.EXPECT().UpdateCredential(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, ucr *milvuspb.UpdateCredentialRequest) (*commonpb.Status, error) {
			s.Equal(userName, ucr.GetUsername())
			s.Equal(crypto.Base64Encode(oldPassword), ucr.GetOldPassword())
			s.Equal(crypto.Base64Encode(newPassword), ucr.GetNewPassword())
			return merr.Success(), nil
		}).Once()

		err := s.client.UpdatePassword(ctx, NewUpdatePasswordOption(userName, oldPassword, newPassword))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().UpdateCredential(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.UpdatePassword(ctx, NewUpdatePasswordOption("user", "old", "new"))
		s.Error(err)
	})
}

func (s *UserSuite) TestDropUser() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		userName := fmt.Sprintf("user_%s", s.randString(5))
		s.mock.EXPECT().DeleteCredential(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, dcr *milvuspb.DeleteCredentialRequest) (*commonpb.Status, error) {
			s.Equal(userName, dcr.GetUsername())
			return merr.Success(), nil
		}).Once()

		err := s.client.DropUser(ctx, NewDropUserOption(userName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().DeleteCredential(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.DropUser(ctx, NewDropUserOption("user"))
		s.Error(err)
	})
}

func TestUserRBAC(t *testing.T) {
	suite.Run(t, new(UserSuite))
}

type RoleSuite struct {
	MockSuiteBase
}

func (s *RoleSuite) TestListRoles() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		s.mock.EXPECT().SelectRole(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.SelectRoleRequest) (*milvuspb.SelectRoleResponse, error) {
			return &milvuspb.SelectRoleResponse{
				Results: []*milvuspb.RoleResult{
					{Role: &milvuspb.RoleEntity{Name: "role1"}},
					{Role: &milvuspb.RoleEntity{Name: "role2"}},
				},
			}, nil
		}).Once()

		roles, err := s.client.ListRoles(ctx, NewListRoleOption())
		s.NoError(err)
		s.Equal([]string{"role1", "role2"}, roles)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().SelectRole(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.ListRoles(ctx, NewListRoleOption())
		s.Error(err)
	})
}

func (s *RoleSuite) TestCreateRole() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		roleName := fmt.Sprintf("role_%s", s.randString(5))
		s.mock.EXPECT().CreateRole(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.CreateRoleRequest) (*commonpb.Status, error) {
			s.Equal(roleName, r.GetEntity().GetName())
			return merr.Success(), nil
		}).Once()

		err := s.client.CreateRole(ctx, NewCreateRoleOption(roleName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().CreateRole(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.CreateRole(ctx, NewCreateRoleOption("role"))
		s.Error(err)
	})
}

func (s *RoleSuite) TestGrantRole() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		userName := fmt.Sprintf("user_%s", s.randString(5))
		roleName := fmt.Sprintf("role_%s", s.randString(5))
		s.mock.EXPECT().OperateUserRole(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.OperateUserRoleRequest) (*commonpb.Status, error) {
			s.Equal(userName, r.GetUsername())
			s.Equal(roleName, r.GetRoleName())
			return merr.Success(), nil
		}).Once()

		err := s.client.GrantRole(ctx, NewGrantRoleOption(userName, roleName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().OperateUserRole(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.GrantRole(ctx, NewGrantRoleOption("user", "role"))
		s.Error(err)
	})
}

func (s *RoleSuite) TestRevokeRole() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		userName := fmt.Sprintf("user_%s", s.randString(5))
		roleName := fmt.Sprintf("role_%s", s.randString(5))
		s.mock.EXPECT().OperateUserRole(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.OperateUserRoleRequest) (*commonpb.Status, error) {
			s.Equal(userName, r.GetUsername())
			s.Equal(roleName, r.GetRoleName())
			return merr.Success(), nil
		}).Once()

		err := s.client.RevokeRole(ctx, NewRevokeRoleOption(userName, roleName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().OperateUserRole(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.RevokeRole(ctx, NewRevokeRoleOption("user", "role"))
		s.Error(err)
	})
}

func (s *RoleSuite) TestDropRole() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		roleName := fmt.Sprintf("role_%s", s.randString(5))
		s.mock.EXPECT().DropRole(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.DropRoleRequest) (*commonpb.Status, error) {
			s.Equal(roleName, r.GetRoleName())
			return merr.Success(), nil
		}).Once()

		err := s.client.DropRole(ctx, NewDropRoleOption(roleName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().DropRole(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.DropRole(ctx, NewDropRoleOption("role"))
		s.Error(err)
	})
}

func (s *RoleSuite) TestDescribeRole() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		roleName := fmt.Sprintf("role_%s", s.randString(5))
		s.mock.EXPECT().SelectRole(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.SelectRoleRequest) (*milvuspb.SelectRoleResponse, error) {
			s.Equal(roleName, r.GetRole().GetName())
			return &milvuspb.SelectRoleResponse{
				Results: []*milvuspb.RoleResult{
					{
						Role: &milvuspb.RoleEntity{Name: roleName},
					},
				},
			}, nil
		}).Once()
		s.mock.EXPECT().SelectGrant(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.SelectGrantRequest) (*milvuspb.SelectGrantResponse, error) {
			s.Equal(roleName, r.GetEntity().GetRole().GetName())
			return &milvuspb.SelectGrantResponse{
				Entities: []*milvuspb.GrantEntity{
					{
						ObjectName: "*",
						Object: &milvuspb.ObjectEntity{
							Name: "collection",
						},
						Role:    &milvuspb.RoleEntity{Name: roleName},
						Grantor: &milvuspb.GrantorEntity{User: &milvuspb.UserEntity{Name: "admin"}, Privilege: &milvuspb.PrivilegeEntity{Name: "Insert"}},
						DbName:  "aaa",
					},
					{
						ObjectName: "*",
						Object: &milvuspb.ObjectEntity{
							Name: "collection",
						},
						Role:    &milvuspb.RoleEntity{Name: roleName},
						Grantor: &milvuspb.GrantorEntity{User: &milvuspb.UserEntity{Name: "admin"}, Privilege: &milvuspb.PrivilegeEntity{Name: "Query"}},
					},
				},
			}, nil
		}).Once()

		role, err := s.client.DescribeRole(ctx, NewDescribeRoleOption(roleName))
		s.NoError(err)
		s.Equal(roleName, role.RoleName)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().SelectRole(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.DescribeRole(ctx, NewDescribeRoleOption("role"))
		s.Error(err)
	})
}

func (s *RoleSuite) TestGrantPrivilege() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		roleName := fmt.Sprintf("role_%s", s.randString(5))
		privilegeName := "Insert"
		collectionName := fmt.Sprintf("collection_%s", s.randString(6))

		s.mock.EXPECT().OperatePrivilege(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.OperatePrivilegeRequest) (*commonpb.Status, error) {
			s.Equal(roleName, r.GetEntity().GetRole().GetName())
			s.Equal("collection", r.GetEntity().GetObject().GetName())
			s.Equal(privilegeName, r.GetEntity().GetGrantor().GetPrivilege().GetName())
			s.Equal(collectionName, r.GetEntity().GetObjectName())
			s.Equal(milvuspb.OperatePrivilegeType_Grant, r.GetType())
			return merr.Success(), nil
		}).Once()

		err := s.client.GrantPrivilege(ctx, NewGrantPrivilegeOption(roleName, "collection", privilegeName, collectionName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().OperatePrivilege(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.GrantPrivilege(ctx, NewGrantPrivilegeOption("role", "collection", "privilege", "coll_1"))
		s.Error(err)
	})
}

func (s *RoleSuite) TestRevokePrivilege() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		roleName := fmt.Sprintf("role_%s", s.randString(5))
		privilegeName := "Insert"
		collectionName := fmt.Sprintf("collection_%s", s.randString(6))

		s.mock.EXPECT().OperatePrivilege(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.OperatePrivilegeRequest) (*commonpb.Status, error) {
			s.Equal(roleName, r.GetEntity().GetRole().GetName())
			s.Equal("collection", r.GetEntity().GetObject().GetName())
			s.Equal(privilegeName, r.GetEntity().GetGrantor().GetPrivilege().GetName())
			s.Equal(collectionName, r.GetEntity().GetObjectName())
			s.Equal(milvuspb.OperatePrivilegeType_Revoke, r.GetType())
			return merr.Success(), nil
		}).Once()

		err := s.client.RevokePrivilege(ctx, NewRevokePrivilegeOption(roleName, "collection", privilegeName, collectionName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().OperatePrivilege(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.RevokePrivilege(ctx, NewRevokePrivilegeOption("role", "collection", "privilege", "coll_1"))
		s.Error(err)
	})
}

func TestRoleRBAC(t *testing.T) {
	suite.Run(t, new(RoleSuite))
}

type PrivilegeGroupSuite struct {
	MockSuiteBase
}

func (s *PrivilegeGroupSuite) TestGrantV2() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	roleName := fmt.Sprintf("test_role_%s", s.randString(6))
	privilegeName := "Insert"
	dbName := fmt.Sprintf("test_db_%s", s.randString(6))
	collectionName := fmt.Sprintf("test_collection_%s", s.randString(6))

	s.Run("success", func() {
		s.mock.EXPECT().OperatePrivilegeV2(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.OperatePrivilegeV2Request) (*commonpb.Status, error) {
			s.Equal(roleName, r.GetRole().GetName())
			s.Equal(privilegeName, r.GetGrantor().GetPrivilege().GetName())
			s.Equal(dbName, r.GetDbName())
			s.Equal(collectionName, r.GetCollectionName())
			return merr.Success(), nil
		}).Once()

		err := s.client.GrantPrivilegeV2(ctx, NewGrantPrivilegeV2Option(roleName, privilegeName, collectionName).WithDbName(dbName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().OperatePrivilegeV2(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.GrantPrivilegeV2(ctx, NewGrantPrivilegeV2Option(roleName, privilegeName, collectionName).WithDbName(dbName))
		s.Error(err)
	})
}

func (s *PrivilegeGroupSuite) TestRevokeV2() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	roleName := fmt.Sprintf("test_role_%s", s.randString(6))
	privilegeName := "Insert"
	dbName := fmt.Sprintf("test_db_%s", s.randString(6))
	collectionName := fmt.Sprintf("test_collection_%s", s.randString(6))

	s.Run("success", func() {
		s.mock.EXPECT().OperatePrivilegeV2(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.OperatePrivilegeV2Request) (*commonpb.Status, error) {
			s.Equal(roleName, r.GetRole().GetName())
			s.Equal(privilegeName, r.GetGrantor().GetPrivilege().GetName())
			s.Equal(dbName, r.GetDbName())
			s.Equal(collectionName, r.GetCollectionName())
			return merr.Success(), nil
		}).Once()

		err := s.client.RevokePrivilegeV2(ctx, NewRevokePrivilegeV2Option(roleName, privilegeName, collectionName).WithDbName(dbName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().OperatePrivilegeV2(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.RevokePrivilegeV2(ctx, NewRevokePrivilegeV2Option(roleName, privilegeName, collectionName).WithDbName(dbName))
		s.Error(err)
	})
}

func (s *PrivilegeGroupSuite) TestCreatePrivilegeGroup() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	groupName := fmt.Sprintf("test_pg_%s", s.randString(6))

	s.Run("success", func() {
		s.mock.EXPECT().CreatePrivilegeGroup(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.CreatePrivilegeGroupRequest) (*commonpb.Status, error) {
			s.Equal(groupName, r.GetGroupName())
			return merr.Success(), nil
		}).Once()

		err := s.client.CreatePrivilegeGroup(ctx, NewCreatePrivilegeGroupOption(groupName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().CreatePrivilegeGroup(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.CreatePrivilegeGroup(ctx, NewCreatePrivilegeGroupOption(groupName))
		s.Error(err)
	})
}

func (s *PrivilegeGroupSuite) TestDropPrivilegeGroup() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	groupName := fmt.Sprintf("test_pg_%s", s.randString(6))

	s.Run("success", func() {
		s.mock.EXPECT().DropPrivilegeGroup(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.DropPrivilegeGroupRequest) (*commonpb.Status, error) {
			s.Equal(groupName, r.GetGroupName())
			return merr.Success(), nil
		}).Once()

		err := s.client.DropPrivilegeGroup(ctx, NewDropPrivilegeGroupOption(groupName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().DropPrivilegeGroup(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.DropPrivilegeGroup(ctx, NewDropPrivilegeGroupOption(groupName))
		s.Error(err)
	})
}

func (s *PrivilegeGroupSuite) TestListPrivilegeGroups() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		s.mock.EXPECT().ListPrivilegeGroups(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.ListPrivilegeGroupsRequest) (*milvuspb.ListPrivilegeGroupsResponse, error) {
			return &milvuspb.ListPrivilegeGroupsResponse{
				PrivilegeGroups: []*milvuspb.PrivilegeGroupInfo{
					{
						GroupName:  "pg1",
						Privileges: []*milvuspb.PrivilegeEntity{{Name: "Insert"}, {Name: "Query"}},
					},
					{
						GroupName:  "pg2",
						Privileges: []*milvuspb.PrivilegeEntity{{Name: "Delete"}, {Name: "Query"}},
					},
				},
			}, nil
		}).Once()

		pgs, err := s.client.ListPrivilegeGroups(ctx, NewListPrivilegeGroupsOption())
		s.NoError(err)
		s.Equal(2, len(pgs))
		s.Equal("pg1", pgs[0].GroupName)
		s.Equal([]string{"Insert", "Query"}, pgs[0].Privileges)
		s.Equal("pg2", pgs[1].GroupName)
		s.Equal([]string{"Delete", "Query"}, pgs[1].Privileges)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().ListPrivilegeGroups(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.ListPrivilegeGroups(ctx, NewListPrivilegeGroupsOption())
		s.Error(err)
	})
}

func (s *PrivilegeGroupSuite) TestOperatePrivilegeGroup() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	groupName := fmt.Sprintf("test_pg_%s", s.randString(6))
	privileges := []*milvuspb.PrivilegeEntity{{Name: "Insert"}, {Name: "Query"}}
	operateType := milvuspb.OperatePrivilegeGroupType_AddPrivilegesToGroup

	s.Run("success", func() {
		s.mock.EXPECT().OperatePrivilegeGroup(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.OperatePrivilegeGroupRequest) (*commonpb.Status, error) {
			s.Equal(groupName, r.GetGroupName())
			return merr.Success(), nil
		}).Once()

		err := s.client.OperatePrivilegeGroup(ctx, NewOperatePrivilegeGroupOption(groupName, privileges, operateType))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().OperatePrivilegeGroup(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.OperatePrivilegeGroup(ctx, NewOperatePrivilegeGroupOption(groupName, privileges, operateType))
		s.Error(err)
	})
}

func (s *PrivilegeGroupSuite) TestAddPrivilegesToGroup() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	groupName := fmt.Sprintf("test_pg_%s", s.randString(6))
	privileges := []string{"Insert", "Query"}

	s.Run("success", func() {
		s.mock.EXPECT().OperatePrivilegeGroup(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.OperatePrivilegeGroupRequest) (*commonpb.Status, error) {
			s.Equal(groupName, r.GetGroupName())
			s.Equal(milvuspb.OperatePrivilegeGroupType_AddPrivilegesToGroup, r.GetType())
			return merr.Success(), nil
		}).Once()

		err := s.client.AddPrivilegesToGroup(ctx, NewAddPrivilegesToGroupOption(groupName, privileges...))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().OperatePrivilegeGroup(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.AddPrivilegesToGroup(ctx, NewAddPrivilegesToGroupOption(groupName, privileges...))
		s.Error(err)
	})
}

func (s *PrivilegeGroupSuite) TestRemovePrivilegesFromGroup() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	groupName := fmt.Sprintf("test_pg_%s", s.randString(6))
	privileges := []string{"Insert", "Query"}

	s.Run("success", func() {
		s.mock.EXPECT().OperatePrivilegeGroup(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, r *milvuspb.OperatePrivilegeGroupRequest) (*commonpb.Status, error) {
			s.Equal(groupName, r.GetGroupName())
			s.Equal(milvuspb.OperatePrivilegeGroupType_RemovePrivilegesFromGroup, r.GetType())
			return merr.Success(), nil
		}).Once()

		err := s.client.RemovePrivilegesFromGroup(ctx, NewRemovePrivilegesFromGroupOption(groupName, privileges...))
		s.NoError(err)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().OperatePrivilegeGroup(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		err := s.client.RemovePrivilegesFromGroup(ctx, NewRemovePrivilegesFromGroupOption(groupName, privileges...))
		s.Error(err)
	})
}

func TestPrivilegeGroup(t *testing.T) {
	suite.Run(t, new(PrivilegeGroupSuite))
}



---
File: /milvusclient/rbac_v2.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"

	"github.com/samber/lo"
	"google.golang.org/grpc"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

func (c *Client) CreatePrivilegeGroup(ctx context.Context, option CreatePrivilegeGroupOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.CreatePrivilegeGroup(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) DropPrivilegeGroup(ctx context.Context, option DropPrivilegeGroupOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DropPrivilegeGroup(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) ListPrivilegeGroups(ctx context.Context, option ListPrivilegeGroupsOption, callOptions ...grpc.CallOption) ([]*entity.PrivilegeGroup, error) {
	req := option.Request()

	var privilegeGroups []*entity.PrivilegeGroup
	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		r, err := milvusService.ListPrivilegeGroups(ctx, req, callOptions...)
		if err != nil {
			return err
		}
		for _, pg := range r.PrivilegeGroups {
			privileges := lo.Map(pg.Privileges, func(p *milvuspb.PrivilegeEntity, _ int) string {
				return p.Name
			})
			privilegeGroups = append(privilegeGroups, &entity.PrivilegeGroup{
				GroupName:  pg.GroupName,
				Privileges: privileges,
			})
		}
		return nil
	})
	return privilegeGroups, err
}

func (c *Client) AddPrivilegesToGroup(ctx context.Context, option AddPrivilegeToGroupOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.OperatePrivilegeGroup(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) RemovePrivilegesFromGroup(ctx context.Context, option RemovePrivilegeFromGroupOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.OperatePrivilegeGroup(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) GrantPrivilegeV2(ctx context.Context, option GrantPrivilegeV2Option, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.OperatePrivilegeV2(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) RevokePrivilegeV2(ctx context.Context, option RevokePrivilegeV2Option, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.OperatePrivilegeV2(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

// Deprecated, use `AddPrivilegesToGroup` or `RemovePrivilegesFromGroup` instead
func (c *Client) OperatePrivilegeGroup(ctx context.Context, option OperatePrivilegeGroupOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.OperatePrivilegeGroup(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

// Deprecated, use `GrantPrivilegeV2` instead
func (c *Client) GrantV2(ctx context.Context, option GrantV2Option, callOptions ...grpc.CallOption) error {
	return c.GrantPrivilegeV2(ctx, option, callOptions...)
}

// Deprecated, use `RevokePrivilegeV2` instead
func (c *Client) RevokeV2(ctx context.Context, option RevokeV2Option, callOptions ...grpc.CallOption) error {
	return c.RevokePrivilegeV2(ctx, option, callOptions...)
}



---
File: /milvusclient/rbac.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"

	"github.com/cockroachdb/errors"
	"github.com/samber/lo"
	"google.golang.org/grpc"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

func (c *Client) ListUsers(ctx context.Context, opt ListUserOption, callOpts ...grpc.CallOption) ([]string, error) {
	var users []string
	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.ListCredUsers(ctx, opt.Request(), callOpts...)
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}
		users = resp.GetUsernames()
		return nil
	})
	return users, err
}

func (c *Client) DescribeUser(ctx context.Context, opt DescribeUserOption, callOpts ...grpc.CallOption) (*entity.User, error) {
	var user *entity.User
	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.SelectUser(ctx, opt.Request(), callOpts...)
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}
		if len(resp.GetResults()) == 0 {
			return errors.New("not user found")
		}
		result := resp.GetResults()[0]
		user = &entity.User{
			UserName: result.GetUser().GetName(),
			Roles:    lo.Map(result.GetRoles(), func(r *milvuspb.RoleEntity, _ int) string { return r.GetName() }),
		}

		return nil
	})

	return user, err
}

func (c *Client) CreateUser(ctx context.Context, opt CreateUserOption, callOpts ...grpc.CallOption) error {
	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.CreateCredential(ctx, opt.Request(), callOpts...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) UpdatePassword(ctx context.Context, opt UpdatePasswordOption, callOpts ...grpc.CallOption) error {
	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.UpdateCredential(ctx, opt.Request(), callOpts...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) DropUser(ctx context.Context, opt DropUserOption, callOpts ...grpc.CallOption) error {
	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DeleteCredential(ctx, opt.Request(), callOpts...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) ListRoles(ctx context.Context, opt ListRoleOption, callOpts ...grpc.CallOption) ([]string, error) {
	var roles []string
	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.SelectRole(ctx, opt.Request(), callOpts...)
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}
		roles = lo.Map(resp.GetResults(), func(r *milvuspb.RoleResult, _ int) string {
			return r.GetRole().GetName()
		})
		return nil
	})
	return roles, err
}

func (c *Client) CreateRole(ctx context.Context, opt CreateRoleOption, callOpts ...grpc.CallOption) error {
	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.CreateRole(ctx, opt.Request(), callOpts...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) GrantRole(ctx context.Context, opt GrantRoleOption, callOpts ...grpc.CallOption) error {
	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.OperateUserRole(ctx, opt.Request(), callOpts...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) RevokeRole(ctx context.Context, opt RevokeRoleOption, callOpts ...grpc.CallOption) error {
	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.OperateUserRole(ctx, opt.Request(), callOpts...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) DropRole(ctx context.Context, opt DropRoleOption, callOpts ...grpc.CallOption) error {
	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DropRole(ctx, opt.Request(), callOpts...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) DescribeRole(ctx context.Context, option DescribeRoleOption, callOptions ...grpc.CallOption) (*entity.Role, error) {
	var role *entity.Role
	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		roleResp, err := milvusService.SelectRole(ctx, option.SelectRoleRequest(), callOptions...)
		if err := merr.CheckRPCCall(roleResp, err); err != nil {
			return err
		}

		if len(roleResp.GetResults()) == 0 {
			return errors.New("role not found")
		}

		role = &entity.Role{
			RoleName: roleResp.GetResults()[0].GetRole().GetName(),
		}

		resp, err := milvusService.SelectGrant(ctx, option.Request(), callOptions...)
		if err := merr.CheckRPCCall(resp, err); err != nil {
			return err
		}

		role.Privileges = lo.Map(resp.GetEntities(), func(g *milvuspb.GrantEntity, _ int) entity.GrantItem {
			return entity.GrantItem{
				Object:     g.GetObject().GetName(),
				ObjectName: g.GetObjectName(),
				RoleName:   g.GetRole().GetName(),
				Grantor:    g.GetGrantor().GetUser().GetName(),
				Privilege:  g.GetGrantor().GetPrivilege().GetName(),
				DbName:     g.GetDbName(),
			}
		})

		return nil
	})
	return role, err
}

func (c *Client) GrantPrivilege(ctx context.Context, option GrantPrivilegeOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.OperatePrivilege(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}

func (c *Client) RevokePrivilege(ctx context.Context, option RevokePrivilegeOption, callOptions ...grpc.CallOption) error {
	req := option.Request()

	return c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.OperatePrivilege(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})
}



---
File: /milvusclient/read_example_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// nolint
package milvusclient_test

import (
	"context"
	"fmt"
	"log"

	"github.com/milvus-io/milvus/client/v2/column"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/index"
	"github.com/milvus-io/milvus/client/v2/milvusclient"
)

func ExampleClient_Search_basic() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"
	token := "root:Milvus"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
		APIKey:  token,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	queryVector := []float32{0.3580376395471989, -0.6023495712049978, 0.18414012509913835, -0.26286205330961354, 0.9029438446296592}

	resultSets, err := cli.Search(ctx, milvusclient.NewSearchOption(
		"quick_setup", // collectionName
		3,             // limit
		[]entity.Vector{entity.FloatVector(queryVector)},
	))
	if err != nil {
		log.Fatal("failed to perform basic ANN search collection: ", err.Error())
	}

	for _, resultSet := range resultSets {
		log.Println("IDs: ", resultSet.IDs)
		log.Println("Scores: ", resultSet.Scores)
	}
}

func ExampleClient_Search_multivectors() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"
	token := "root:Milvus"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
		APIKey:  token,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	queryVectors := []entity.Vector{
		entity.FloatVector([]float32{0.3580376395471989, -0.6023495712049978, 0.18414012509913835, -0.26286205330961354, 0.9029438446296592}),
		entity.FloatVector([]float32{0.19886812562848388, 0.06023560599112088, 0.6976963061752597, 0.2614474506242501, 0.838729485096104}),
	}

	resultSets, err := cli.Search(ctx, milvusclient.NewSearchOption(
		"quick_setup", // collectionName
		3,             // limit
		queryVectors,
	))
	if err != nil {
		log.Fatal("failed to perform basic ANN search collection: ", err.Error())
	}

	for _, resultSet := range resultSets {
		log.Println("IDs: ", resultSet.IDs)
		log.Println("Scores: ", resultSet.Scores)
	}
}

func ExampleClient_Search_partition() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"
	token := "root:Milvus"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
		APIKey:  token,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	queryVector := []float32{0.3580376395471989, -0.6023495712049978, 0.18414012509913835, -0.26286205330961354, 0.9029438446296592}

	resultSets, err := cli.Search(ctx, milvusclient.NewSearchOption(
		"quick_setup", // collectionName
		3,             // limit
		[]entity.Vector{entity.FloatVector(queryVector)},
	).WithPartitions("partitionA"))
	if err != nil {
		log.Fatal("failed to perform basic ANN search collection: ", err.Error())
	}

	for _, resultSet := range resultSets {
		log.Println("IDs: ", resultSet.IDs)
		log.Println("Scores: ", resultSet.Scores)
	}
}

func ExampleClient_Search_outputFields() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"
	token := "root:Milvus"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
		APIKey:  token,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	queryVector := []float32{0.3580376395471989, -0.6023495712049978, 0.18414012509913835, -0.26286205330961354, 0.9029438446296592}

	resultSets, err := cli.Search(ctx, milvusclient.NewSearchOption(
		"quick_setup", // collectionName
		3,             // limit
		[]entity.Vector{entity.FloatVector(queryVector)},
	).WithOutputFields("color"))
	if err != nil {
		log.Fatal("failed to perform basic ANN search collection: ", err.Error())
	}

	for _, resultSet := range resultSets {
		log.Println("IDs: ", resultSet.IDs)
		log.Println("Scores: ", resultSet.Scores)
		log.Println("Colors: ", resultSet.GetColumn("color"))
	}
}

func ExampleClient_Search_offsetLimit() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"
	token := "root:Milvus"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
		APIKey:  token,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	queryVector := []float32{0.3580376395471989, -0.6023495712049978, 0.18414012509913835, -0.26286205330961354, 0.9029438446296592}

	resultSets, err := cli.Search(ctx, milvusclient.NewSearchOption(
		"quick_setup", // collectionName
		3,             // limit
		[]entity.Vector{entity.FloatVector(queryVector)},
	).WithOffset(10))
	if err != nil {
		log.Fatal("failed to perform basic ANN search collection: ", err.Error())
	}

	for _, resultSet := range resultSets {
		log.Println("IDs: ", resultSet.IDs)
		log.Println("Scores: ", resultSet.Scores)
	}
}

func ExampleClient_Search_jsonExpr() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	queryVector := []float32{0.3, -0.6, -0.1}

	annParam := index.NewCustomAnnParam()
	annParam.WithExtraParam("nprobe", 10)
	resultSets, err := cli.Search(ctx, milvusclient.NewSearchOption(
		"my_json_collection", // collectionName
		5,                    // limit
		[]entity.Vector{entity.FloatVector(queryVector)},
	).WithOutputFields("metadata").WithAnnParam(annParam))
	if err != nil {
		log.Fatal("failed to perform basic ANN search collection: ", err.Error())
	}

	for _, resultSet := range resultSets {
		log.Println("IDs: ", resultSet.IDs)
		log.Println("Scores: ", resultSet.Scores)
	}
}

func ExampleClient_Search_binaryVector() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"
	token := "root:Milvus"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
		APIKey:  token,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	queryVector := []byte{0b10011011, 0b01010100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

	annSearchParams := index.NewCustomAnnParam()
	annSearchParams.WithExtraParam("nprobe", 10)
	resultSets, err := cli.Search(ctx, milvusclient.NewSearchOption(
		"my_binary_collection", // collectionName
		5,                      // limit
		[]entity.Vector{entity.BinaryVector(queryVector)},
	).WithOutputFields("pk").WithAnnParam(annSearchParams))
	if err != nil {
		log.Fatal("failed to perform basic ANN search collection: ", err.Error())
	}

	for _, resultSet := range resultSets {
		log.Println("IDs: ", resultSet.IDs)
		log.Println("Scores: ", resultSet.Scores)
		log.Println("Pks: ", resultSet.GetColumn("pk"))
	}
}

func ExampleClient_Get() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	rs, err := cli.Get(ctx, milvusclient.NewQueryOption("quick_setup").
		WithIDs(column.NewColumnInt64("id", []int64{1, 2, 3})))
	if err != nil {
		// handle error
	}

	fmt.Println(rs.GetColumn("id"))
}

func ExampleClient_Query() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	rs, err := cli.Query(ctx, milvusclient.NewQueryOption("quick_setup").
		WithFilter("emb_type == 3").
		WithOutputFields("id", "emb_type"))
	if err != nil {
		// handle error
	}

	fmt.Println(rs.GetColumn("id"))
}

func ExampleClient_Query_jsonExpr_notnull() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	rs, err := cli.Query(ctx, milvusclient.NewQueryOption("my_json_collection").
		WithFilter("metadata is not null").
		WithOutputFields("metadata", "pk"))
	if err != nil {
		// handle error
	}

	fmt.Println(rs.GetColumn("pk"))
	fmt.Println(rs.GetColumn("metadata"))
}

func ExampleClient_Query_jsonExpr_leafChild() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	rs, err := cli.Query(ctx, milvusclient.NewQueryOption("my_json_collection").
		WithFilter(`metadata["product_info"]["category"] == "electronics"`).
		WithOutputFields("metadata", "pk"))
	if err != nil {
		// handle error
	}

	fmt.Println(rs.GetColumn("pk"))
	fmt.Println(rs.GetColumn("metadata"))
}

func ExampleClient_HybridSearch() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "127.0.0.1:19530"
	token := "root:Milvus"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
		APIKey:  token,
	})
	if err != nil {
		log.Fatal("failed to connect to milvus server: ", err.Error())
	}

	defer cli.Close(ctx)

	queryVector := []float32{0.3580376395471989, -0.6023495712049978, 0.18414012509913835, -0.26286205330961354, 0.9029438446296592}
	sparseVector, _ := entity.NewSliceSparseEmbedding([]uint32{1, 21, 100}, []float32{0.1, 0.2, 0.3})

	resultSets, err := cli.HybridSearch(ctx, milvusclient.NewHybridSearchOption(
		"quick_setup",
		3,
		milvusclient.NewAnnRequest("dense_vector", 10, entity.FloatVector(queryVector)),
		milvusclient.NewAnnRequest("sparse_vector", 10, sparseVector),
	).WithReranker(milvusclient.NewRRFReranker()))
	if err != nil {
		log.Fatal("failed to perform basic ANN search collection: ", err.Error())
	}

	for _, resultSet := range resultSets {
		log.Println("IDs: ", resultSet.IDs)
		log.Println("Scores: ", resultSet.Scores)
	}
}



---
File: /milvusclient/read_option_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"fmt"
	"math/rand"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

type SearchOptionSuite struct {
	suite.Suite
}

type nonSupportData struct{}

func (d nonSupportData) Serialize() []byte {
	return []byte{}
}

func (d nonSupportData) Dim() int {
	return 0
}

func (d nonSupportData) FieldType() entity.FieldType {
	return entity.FieldType(0)
}

func (s *SearchOptionSuite) TestBasic() {
	collName := "search_opt_basic"

	topK := rand.Intn(100) + 1
	opt := NewSearchOption(collName, topK, []entity.Vector{entity.FloatVector([]float32{0.1, 0.2})})

	opt = opt.WithANNSField("test_field").WithOutputFields("ID", "Value").WithConsistencyLevel(entity.ClStrong).WithFilter("ID > 1000").WithGroupByField("group_field").WithGroupSize(10).WithStrictGroupSize(true)
	req, err := opt.Request()
	s.Require().NoError(err)

	s.Equal(collName, req.GetCollectionName())
	s.Equal("ID > 1000", req.GetDsl())
	s.ElementsMatch([]string{"ID", "Value"}, req.GetOutputFields())
	searchParams := entity.KvPairsMap(req.GetSearchParams())
	annField, ok := searchParams[spAnnsField]
	s.Require().True(ok)
	s.Equal("test_field", annField)
	groupField, ok := searchParams[spGroupBy]
	s.Require().True(ok)
	s.Equal("group_field", groupField)
	groupSize, ok := searchParams[spGroupSize]
	s.Require().True(ok)
	s.Equal("10", groupSize)
	spStrictGroupSize, ok := searchParams[spStrictGroupSize]
	s.Require().True(ok)
	s.Equal("true", spStrictGroupSize)

	opt = NewSearchOption(collName, topK, []entity.Vector{nonSupportData{}})
	_, err = opt.Request()
	s.Error(err)
}

func (s *SearchOptionSuite) TestPlaceHolder() {
	type testCase struct {
		tag         string
		input       []entity.Vector
		expectError bool
		expectType  commonpb.PlaceholderType
	}

	sparse, err := entity.NewSliceSparseEmbedding([]uint32{0, 10, 12}, []float32{0.1, 0.2, 0.3})
	s.Require().NoError(err)

	cases := []*testCase{
		{
			tag:        "empty_input",
			input:      nil,
			expectType: commonpb.PlaceholderType_None,
		},
		{
			tag:        "float_vector",
			input:      []entity.Vector{entity.FloatVector([]float32{0.1, 0.2, 0.3})},
			expectType: commonpb.PlaceholderType_FloatVector,
		},
		{
			tag:        "sparse_vector",
			input:      []entity.Vector{sparse},
			expectType: commonpb.PlaceholderType_SparseFloatVector,
		},
		{
			tag:        "fp16_vector",
			input:      []entity.Vector{entity.Float16Vector([]byte{})},
			expectType: commonpb.PlaceholderType_Float16Vector,
		},
		{
			tag:        "bf16_vector",
			input:      []entity.Vector{entity.BFloat16Vector([]byte{})},
			expectType: commonpb.PlaceholderType_BFloat16Vector,
		},
		{
			tag:        "binary_vector",
			input:      []entity.Vector{entity.BinaryVector([]byte{})},
			expectType: commonpb.PlaceholderType_BinaryVector,
		},
		{
			tag:        "text",
			input:      []entity.Vector{entity.Text("abc")},
			expectType: commonpb.PlaceholderType_VarChar,
		},
		{
			tag:         "non_supported",
			input:       []entity.Vector{nonSupportData{}},
			expectError: true,
		},
	}
	for _, tc := range cases {
		s.Run(tc.tag, func() {
			phv, err := vector2Placeholder(tc.input)
			if tc.expectError {
				s.Error(err)
			} else {
				s.NoError(err)
				s.Equal(tc.expectType, phv.GetType())
			}
		})
	}
}

func TestSearchOption(t *testing.T) {
	suite.Run(t, new(SearchOptionSuite))
}

func TestAny2TmplValue(t *testing.T) {
	t.Run("primitives", func(t *testing.T) {
		t.Run("int", func(t *testing.T) {
			v := rand.Int()
			val, err := any2TmplValue(v)
			assert.NoError(t, err)
			assert.EqualValues(t, v, val.GetInt64Val())
		})

		t.Run("int32", func(t *testing.T) {
			v := rand.Int31()
			val, err := any2TmplValue(v)
			assert.NoError(t, err)
			assert.EqualValues(t, v, val.GetInt64Val())
		})

		t.Run("int64", func(t *testing.T) {
			v := rand.Int63()
			val, err := any2TmplValue(v)
			assert.NoError(t, err)
			assert.EqualValues(t, v, val.GetInt64Val())
		})

		t.Run("float32", func(t *testing.T) {
			v := rand.Float32()
			val, err := any2TmplValue(v)
			assert.NoError(t, err)
			assert.EqualValues(t, v, val.GetFloatVal())
		})

		t.Run("float64", func(t *testing.T) {
			v := rand.Float64()
			val, err := any2TmplValue(v)
			assert.NoError(t, err)
			assert.EqualValues(t, v, val.GetFloatVal())
		})

		t.Run("bool", func(t *testing.T) {
			val, err := any2TmplValue(true)
			assert.NoError(t, err)
			assert.True(t, val.GetBoolVal())
		})

		t.Run("string", func(t *testing.T) {
			v := fmt.Sprintf("%v", rand.Int())
			val, err := any2TmplValue(v)
			assert.NoError(t, err)
			assert.EqualValues(t, v, val.GetStringVal())
		})
	})

	t.Run("slice", func(t *testing.T) {
		t.Run("int", func(t *testing.T) {
			l := rand.Intn(10) + 1
			v := make([]int, 0, l)
			for i := 0; i < l; i++ {
				v = append(v, rand.Int())
			}
			val, err := any2TmplValue(v)
			assert.NoError(t, err)
			data := val.GetArrayVal().GetLongData().GetData()
			assert.Equal(t, l, len(data))
			for i, val := range data {
				assert.EqualValues(t, v[i], val)
			}
		})

		t.Run("int32", func(t *testing.T) {
			l := rand.Intn(10) + 1
			v := make([]int32, 0, l)
			for i := 0; i < l; i++ {
				v = append(v, rand.Int31())
			}
			val, err := any2TmplValue(v)
			assert.NoError(t, err)
			data := val.GetArrayVal().GetLongData().GetData()
			assert.Equal(t, l, len(data))
			for i, val := range data {
				assert.EqualValues(t, v[i], val)
			}
		})

		t.Run("int64", func(t *testing.T) {
			l := rand.Intn(10) + 1
			v := make([]int64, 0, l)
			for i := 0; i < l; i++ {
				v = append(v, rand.Int63())
			}
			val, err := any2TmplValue(v)
			assert.NoError(t, err)
			data := val.GetArrayVal().GetLongData().GetData()
			assert.Equal(t, l, len(data))
			for i, val := range data {
				assert.EqualValues(t, v[i], val)
			}
		})

		t.Run("float32", func(t *testing.T) {
			l := rand.Intn(10) + 1
			v := make([]float32, 0, l)
			for i := 0; i < l; i++ {
				v = append(v, rand.Float32())
			}
			val, err := any2TmplValue(v)
			assert.NoError(t, err)
			data := val.GetArrayVal().GetDoubleData().GetData()
			assert.Equal(t, l, len(data))
			for i, val := range data {
				assert.EqualValues(t, v[i], val)
			}
		})

		t.Run("float64", func(t *testing.T) {
			l := rand.Intn(10) + 1
			v := make([]float64, 0, l)
			for i := 0; i < l; i++ {
				v = append(v, rand.Float64())
			}
			val, err := any2TmplValue(v)
			assert.NoError(t, err)
			data := val.GetArrayVal().GetDoubleData().GetData()
			assert.Equal(t, l, len(data))
			for i, val := range data {
				assert.EqualValues(t, v[i], val)
			}
		})

		t.Run("bool", func(t *testing.T) {
			l := rand.Intn(10) + 1
			v := make([]bool, 0, l)
			for i := 0; i < l; i++ {
				v = append(v, rand.Int()%2 == 0)
			}
			val, err := any2TmplValue(v)
			assert.NoError(t, err)
			data := val.GetArrayVal().GetBoolData().GetData()
			assert.Equal(t, l, len(data))
			for i, val := range data {
				assert.EqualValues(t, v[i], val)
			}
		})

		t.Run("string", func(t *testing.T) {
			l := rand.Intn(10) + 1
			v := make([]string, 0, l)
			for i := 0; i < l; i++ {
				v = append(v, fmt.Sprintf("%v", rand.Int()))
			}
			val, err := any2TmplValue(v)
			assert.NoError(t, err)
			data := val.GetArrayVal().GetStringData().GetData()
			assert.Equal(t, l, len(data))
			for i, val := range data {
				assert.EqualValues(t, v[i], val)
			}
		})
	})

	t.Run("unsupported", func(*testing.T) {
		_, err := any2TmplValue(struct{}{})
		assert.Error(t, err)

		_, err = any2TmplValue([]struct{}{})
		assert.Error(t, err)
	})
}



---
File: /milvusclient/read_options.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strconv"
	"strings"

	"github.com/cockroachdb/errors"
	"github.com/samber/lo"
	"google.golang.org/protobuf/proto"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/column"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/index"
)

const (
	spAnnsField       = `anns_field`
	spTopK            = `topk`
	spOffset          = `offset`
	spLimit           = `limit`
	spParams          = `params`
	spMetricsType     = `metric_type`
	spRoundDecimal    = `round_decimal`
	spIgnoreGrowing   = `ignore_growing`
	spGroupBy         = `group_by_field`
	spGroupSize       = `group_size`
	spStrictGroupSize = `strict_group_size`
)

type SearchOption interface {
	Request() (*milvuspb.SearchRequest, error)
}

var _ SearchOption = (*searchOption)(nil)

type searchOption struct {
	annRequest                 *annRequest
	collectionName             string
	partitionNames             []string
	outputFields               []string
	consistencyLevel           entity.ConsistencyLevel
	useDefaultConsistencyLevel bool
}

type annRequest struct {
	vectors []entity.Vector

	annField        string
	metricsType     entity.MetricType
	searchParam     map[string]string
	groupByField    string
	groupSize       int
	strictGroupSize bool
	annParam        index.AnnParam
	ignoreGrowing   bool
	expr            string
	topK            int
	offset          int
	templateParams  map[string]any
}

func NewAnnRequest(annField string, limit int, vectors ...entity.Vector) *annRequest {
	return &annRequest{
		annField:       annField,
		vectors:        vectors,
		topK:           limit,
		searchParam:    make(map[string]string),
		templateParams: make(map[string]any),
	}
}

func (r *annRequest) searchRequest() (*milvuspb.SearchRequest, error) {
	request := &milvuspb.SearchRequest{
		Nq:      int64(len(r.vectors)),
		Dsl:     r.expr,
		DslType: commonpb.DslType_BoolExprV1,
	}

	var err error
	// placeholder group
	request.PlaceholderGroup, err = vector2PlaceholderGroupBytes(r.vectors)
	if err != nil {
		return nil, err
	}

	params := map[string]string{
		spAnnsField:     r.annField,
		spTopK:          strconv.Itoa(r.topK),
		spOffset:        strconv.Itoa(r.offset),
		spMetricsType:   string(r.metricsType),
		spRoundDecimal:  "-1",
		spIgnoreGrowing: strconv.FormatBool(r.ignoreGrowing),
	}
	if r.groupByField != "" {
		params[spGroupBy] = r.groupByField
	}
	if r.groupSize != 0 {
		params[spGroupSize] = strconv.Itoa(r.groupSize)
	}
	if r.strictGroupSize {
		params[spStrictGroupSize] = "true"
	}
	// ann param
	if r.annParam != nil {
		bs, _ := json.Marshal(r.annParam.Params())
		params[spParams] = string(bs)
	} else {
		params[spParams] = "{}"
	}
	// use custom search param to overwrite
	for k, v := range r.searchParam {
		params[k] = v
	}
	request.SearchParams = entity.MapKvPairs(params)

	request.ExprTemplateValues = make(map[string]*schemapb.TemplateValue)
	for key, value := range r.templateParams {
		tmplVal, err := any2TmplValue(value)
		if err != nil {
			return nil, err
		}
		request.ExprTemplateValues[key] = tmplVal
	}

	return request, nil
}

func any2TmplValue(val any) (*schemapb.TemplateValue, error) {
	result := &schemapb.TemplateValue{}
	switch v := val.(type) {
	case int, int8, int16, int32:
		result.Val = &schemapb.TemplateValue_Int64Val{Int64Val: reflect.ValueOf(v).Int()}
	case int64:
		result.Val = &schemapb.TemplateValue_Int64Val{Int64Val: v}
	case float32:
		result.Val = &schemapb.TemplateValue_FloatVal{FloatVal: float64(v)}
	case float64:
		result.Val = &schemapb.TemplateValue_FloatVal{FloatVal: v}
	case bool:
		result.Val = &schemapb.TemplateValue_BoolVal{BoolVal: v}
	case string:
		result.Val = &schemapb.TemplateValue_StringVal{StringVal: v}
	default:
		if reflect.TypeOf(val).Kind() == reflect.Slice {
			return slice2TmplValue(val)
		}
		return nil, fmt.Errorf("unsupported template value type: %T", val)
	}
	return result, nil
}

func slice2TmplValue(val any) (*schemapb.TemplateValue, error) {
	arrVal := &schemapb.TemplateValue_ArrayVal{
		ArrayVal: &schemapb.TemplateArrayValue{},
	}

	rv := reflect.ValueOf(val)
	switch t := reflect.TypeOf(val).Elem().Kind(); t {
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		data := make([]int64, 0, rv.Len())
		for i := 0; i < rv.Len(); i++ {
			data = append(data, rv.Index(i).Int())
		}
		arrVal.ArrayVal.Data = &schemapb.TemplateArrayValue_LongData{
			LongData: &schemapb.LongArray{
				Data: data,
			},
		}
	case reflect.Bool:
		data := make([]bool, 0, rv.Len())
		for i := 0; i < rv.Len(); i++ {
			data = append(data, rv.Index(i).Bool())
		}
		arrVal.ArrayVal.Data = &schemapb.TemplateArrayValue_BoolData{
			BoolData: &schemapb.BoolArray{
				Data: data,
			},
		}
	case reflect.Float32, reflect.Float64:
		data := make([]float64, 0, rv.Len())
		for i := 0; i < rv.Len(); i++ {
			data = append(data, rv.Index(i).Float())
		}
		arrVal.ArrayVal.Data = &schemapb.TemplateArrayValue_DoubleData{
			DoubleData: &schemapb.DoubleArray{
				Data: data,
			},
		}
	case reflect.String:
		data := make([]string, 0, rv.Len())
		for i := 0; i < rv.Len(); i++ {
			data = append(data, rv.Index(i).String())
		}
		arrVal.ArrayVal.Data = &schemapb.TemplateArrayValue_StringData{
			StringData: &schemapb.StringArray{
				Data: data,
			},
		}
	default:
		return nil, fmt.Errorf("unsupported template type: slice of %v", t)
	}

	return &schemapb.TemplateValue{
		Val: arrVal,
	}, nil
}

func (r *annRequest) WithANNSField(annsField string) *annRequest {
	r.annField = annsField
	return r
}

func (r *annRequest) WithGroupByField(groupByField string) *annRequest {
	r.groupByField = groupByField
	return r
}

func (r *annRequest) WithGroupSize(groupSize int) *annRequest {
	r.groupSize = groupSize
	return r
}

func (r *annRequest) WithStrictGroupSize(strictGroupSize bool) *annRequest {
	r.strictGroupSize = strictGroupSize
	return r
}

func (r *annRequest) WithSearchParam(key, value string) *annRequest {
	r.searchParam[key] = value
	return r
}

func (r *annRequest) WithAnnParam(ap index.AnnParam) *annRequest {
	r.annParam = ap
	return r
}

func (r *annRequest) WithFilter(expr string) *annRequest {
	r.expr = expr
	return r
}

func (r *annRequest) WithTemplateParam(key string, val any) *annRequest {
	r.templateParams[key] = val
	return r
}

func (r *annRequest) WithOffset(offset int) *annRequest {
	r.offset = offset
	return r
}

func (r *annRequest) WithIgnoreGrowing(ignoreGrowing bool) *annRequest {
	r.ignoreGrowing = ignoreGrowing
	return r
}

func (opt *searchOption) Request() (*milvuspb.SearchRequest, error) {
	request, err := opt.annRequest.searchRequest()
	if err != nil {
		return nil, err
	}

	request.CollectionName = opt.collectionName
	request.PartitionNames = opt.partitionNames
	request.ConsistencyLevel = commonpb.ConsistencyLevel(opt.consistencyLevel)
	request.UseDefaultConsistency = opt.useDefaultConsistencyLevel
	request.OutputFields = opt.outputFields

	return request, nil
}

func (opt *searchOption) WithPartitions(partitionNames ...string) *searchOption {
	opt.partitionNames = partitionNames
	return opt
}

func (opt *searchOption) WithFilter(expr string) *searchOption {
	opt.annRequest.WithFilter(expr)
	return opt
}

func (opt *searchOption) WithTemplateParam(key string, val any) *searchOption {
	opt.annRequest.WithTemplateParam(key, val)
	return opt
}

func (opt *searchOption) WithOffset(offset int) *searchOption {
	opt.annRequest.WithOffset(offset)
	return opt
}

func (opt *searchOption) WithOutputFields(fieldNames ...string) *searchOption {
	opt.outputFields = fieldNames
	return opt
}

func (opt *searchOption) WithConsistencyLevel(consistencyLevel entity.ConsistencyLevel) *searchOption {
	opt.consistencyLevel = consistencyLevel
	opt.useDefaultConsistencyLevel = false
	return opt
}

func (opt *searchOption) WithANNSField(annsField string) *searchOption {
	opt.annRequest.WithANNSField(annsField)
	return opt
}

func (opt *searchOption) WithGroupByField(groupByField string) *searchOption {
	opt.annRequest.WithGroupByField(groupByField)
	return opt
}

func (opt *searchOption) WithGroupSize(groupSize int) *searchOption {
	opt.annRequest.WithGroupSize(groupSize)
	return opt
}

func (opt *searchOption) WithStrictGroupSize(strictGroupSize bool) *searchOption {
	opt.annRequest.WithStrictGroupSize(strictGroupSize)
	return opt
}

func (opt *searchOption) WithIgnoreGrowing(ignoreGrowing bool) *searchOption {
	opt.annRequest.WithIgnoreGrowing(ignoreGrowing)
	return opt
}

func (opt *searchOption) WithAnnParam(ap index.AnnParam) *searchOption {
	opt.annRequest.WithAnnParam(ap)
	return opt
}

func (opt *searchOption) WithSearchParam(key, value string) *searchOption {
	opt.annRequest.WithSearchParam(key, value)
	return opt
}

func NewSearchOption(collectionName string, limit int, vectors []entity.Vector) *searchOption {
	return &searchOption{
		annRequest:                 NewAnnRequest("", limit, vectors...),
		collectionName:             collectionName,
		useDefaultConsistencyLevel: true,
		consistencyLevel:           entity.ClBounded,
	}
}

func vector2PlaceholderGroupBytes(vectors []entity.Vector) ([]byte, error) {
	phv, err := vector2Placeholder(vectors)
	if err != nil {
		return nil, err
	}
	phg := &commonpb.PlaceholderGroup{
		Placeholders: []*commonpb.PlaceholderValue{
			phv,
		},
	}

	bs, err := proto.Marshal(phg)
	return bs, err
}

func vector2Placeholder(vectors []entity.Vector) (*commonpb.PlaceholderValue, error) {
	var placeHolderType commonpb.PlaceholderType
	ph := &commonpb.PlaceholderValue{
		Tag:    "$0",
		Values: make([][]byte, 0, len(vectors)),
	}
	if len(vectors) == 0 {
		return ph, nil
	}
	switch vectors[0].(type) {
	case entity.FloatVector:
		placeHolderType = commonpb.PlaceholderType_FloatVector
	case entity.BinaryVector:
		placeHolderType = commonpb.PlaceholderType_BinaryVector
	case entity.BFloat16Vector:
		placeHolderType = commonpb.PlaceholderType_BFloat16Vector
	case entity.Float16Vector:
		placeHolderType = commonpb.PlaceholderType_Float16Vector
	case entity.SparseEmbedding:
		placeHolderType = commonpb.PlaceholderType_SparseFloatVector
	case entity.Text:
		placeHolderType = commonpb.PlaceholderType_VarChar
	default:
		return nil, errors.Newf("unsupported search data type: %T", vectors[0])
	}
	ph.Type = placeHolderType
	for _, vector := range vectors {
		ph.Values = append(ph.Values, vector.Serialize())
	}
	return ph, nil
}

type HybridSearchOption interface {
	HybridRequest() (*milvuspb.HybridSearchRequest, error)
}

type hybridSearchOption struct {
	collectionName string
	partitionNames []string

	reqs []*annRequest

	outputFields          []string
	useDefaultConsistency bool
	consistencyLevel      entity.ConsistencyLevel

	limit    int
	offset   int
	reranker Reranker
}

func (opt *hybridSearchOption) WithConsistencyLevel(cl entity.ConsistencyLevel) *hybridSearchOption {
	opt.consistencyLevel = cl
	opt.useDefaultConsistency = false
	return opt
}

// Deprecated: typo, use WithPartitions instead
func (opt *hybridSearchOption) WithPartitons(partitions ...string) *hybridSearchOption {
	return opt.WithPartitions(partitions...)
}

func (opt *hybridSearchOption) WithPartitions(partitions ...string) *hybridSearchOption {
	opt.partitionNames = partitions
	return opt
}

func (opt *hybridSearchOption) WithOutputFields(outputFields ...string) *hybridSearchOption {
	opt.outputFields = outputFields
	return opt
}

func (opt *hybridSearchOption) WithReranker(reranker Reranker) *hybridSearchOption {
	opt.reranker = reranker
	return opt
}

func (opt *hybridSearchOption) WithOffset(offset int) *hybridSearchOption {
	opt.offset = offset
	return opt
}

func (opt *hybridSearchOption) HybridRequest() (*milvuspb.HybridSearchRequest, error) {
	requests := make([]*milvuspb.SearchRequest, 0, len(opt.reqs))
	for _, annRequest := range opt.reqs {
		req, err := annRequest.searchRequest()
		if err != nil {
			return nil, err
		}
		requests = append(requests, req)
	}

	var params []*commonpb.KeyValuePair
	if opt.reranker != nil {
		params = opt.reranker.GetParams()
	}
	params = append(params, &commonpb.KeyValuePair{Key: spLimit, Value: strconv.FormatInt(int64(opt.limit), 10)})
	if opt.offset > 0 {
		params = append(params, &commonpb.KeyValuePair{Key: spOffset, Value: strconv.FormatInt(int64(opt.offset), 10)})
	}

	return &milvuspb.HybridSearchRequest{
		CollectionName:        opt.collectionName,
		PartitionNames:        opt.partitionNames,
		Requests:              requests,
		UseDefaultConsistency: opt.useDefaultConsistency,
		ConsistencyLevel:      commonpb.ConsistencyLevel(opt.consistencyLevel),
		OutputFields:          opt.outputFields,
		RankParams:            params,
	}, nil
}

func NewHybridSearchOption(collectionName string, limit int, annRequests ...*annRequest) *hybridSearchOption {
	return &hybridSearchOption{
		collectionName:        collectionName,
		reqs:                  annRequests,
		useDefaultConsistency: true,
		limit:                 limit,
	}
}

type QueryOption interface {
	Request() (*milvuspb.QueryRequest, error)
}

type queryOption struct {
	collectionName             string
	partitionNames             []string
	queryParams                map[string]string
	outputFields               []string
	consistencyLevel           entity.ConsistencyLevel
	useDefaultConsistencyLevel bool
	expr                       string
	templateParams             map[string]any
}

func (opt *queryOption) Request() (*milvuspb.QueryRequest, error) {
	req := &milvuspb.QueryRequest{
		CollectionName: opt.collectionName,
		PartitionNames: opt.partitionNames,
		OutputFields:   opt.outputFields,

		Expr:                  opt.expr,
		QueryParams:           entity.MapKvPairs(opt.queryParams),
		ConsistencyLevel:      opt.consistencyLevel.CommonConsistencyLevel(),
		UseDefaultConsistency: opt.useDefaultConsistencyLevel,
	}

	req.ExprTemplateValues = make(map[string]*schemapb.TemplateValue)
	for key, value := range opt.templateParams {
		tmplVal, err := any2TmplValue(value)
		if err != nil {
			return nil, err
		}
		req.ExprTemplateValues[key] = tmplVal
	}

	return req, nil
}

func (opt *queryOption) WithFilter(expr string) *queryOption {
	opt.expr = expr
	return opt
}

func (opt *queryOption) WithTemplateParam(key string, val any) *queryOption {
	opt.templateParams[key] = val
	return opt
}

func (opt *queryOption) WithOffset(offset int) *queryOption {
	if opt.queryParams == nil {
		opt.queryParams = make(map[string]string)
	}
	opt.queryParams[spOffset] = strconv.Itoa(offset)
	return opt
}

func (opt *queryOption) WithLimit(limit int) *queryOption {
	if opt.queryParams == nil {
		opt.queryParams = make(map[string]string)
	}
	opt.queryParams[spLimit] = strconv.Itoa(limit)
	return opt
}

func (opt *queryOption) WithOutputFields(fieldNames ...string) *queryOption {
	opt.outputFields = fieldNames
	return opt
}

func (opt *queryOption) WithConsistencyLevel(consistencyLevel entity.ConsistencyLevel) *queryOption {
	opt.consistencyLevel = consistencyLevel
	opt.useDefaultConsistencyLevel = false
	return opt
}

func (opt *queryOption) WithPartitions(partitionNames ...string) *queryOption {
	opt.partitionNames = partitionNames
	return opt
}

func (opt *queryOption) WithIDs(ids column.Column) *queryOption {
	opt.expr = pks2Expr(ids)
	return opt
}

func pks2Expr(ids column.Column) string {
	var expr string
	pkName := ids.Name()
	switch ids.Type() {
	case entity.FieldTypeInt64:
		expr = fmt.Sprintf("%s in %s", pkName, strings.Join(strings.Fields(fmt.Sprint(ids.FieldData().GetScalars().GetLongData().GetData())), ","))
	case entity.FieldTypeVarChar:
		data := ids.FieldData().GetScalars().GetData().(*schemapb.ScalarField_StringData).StringData.GetData()
		for i := range data {
			data[i] = fmt.Sprintf("\"%s\"", data[i])
		}
		expr = fmt.Sprintf("%s in [%s]", pkName, strings.Join(data, ","))
	}
	return expr
}

func NewQueryOption(collectionName string) *queryOption {
	return &queryOption{
		collectionName:             collectionName,
		useDefaultConsistencyLevel: true,
		consistencyLevel:           entity.ClBounded,
		templateParams:             make(map[string]any),
	}
}

type RunAnalyzerOption interface {
	Request() (*milvuspb.RunAnalyzerRequest, error)
}

type runAnalyzerOption struct {
	text           []string
	analyzerParams string
	withDetail     bool
	withHash       bool
}

func (opt *runAnalyzerOption) Request() (*milvuspb.RunAnalyzerRequest, error) {
	return &milvuspb.RunAnalyzerRequest{
		Placeholder:    lo.Map(opt.text, func(str string, _ int) []byte { return []byte(str) }),
		AnalyzerParams: opt.analyzerParams,
	}, nil
}

func (opt *runAnalyzerOption) WithAnalyzerParams(params string) *runAnalyzerOption {
	opt.analyzerParams = params
	return opt
}

func (opt *runAnalyzerOption) WithDetail() *runAnalyzerOption {
	opt.withDetail = true
	return opt
}

func (opt *runAnalyzerOption) WithHash() *runAnalyzerOption {
	opt.withHash = true
	return opt
}

func NewRunAnalyzerOption(text []string) *runAnalyzerOption {
	return &runAnalyzerOption{
		text: text,
	}
}



---
File: /milvusclient/read_test.go
---

package milvusclient

import (
	"context"
	"fmt"
	"math/rand"
	"testing"

	"github.com/samber/lo"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/index"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type ReadSuite struct {
	MockSuiteBase

	schema    *entity.Schema
	schemaDyn *entity.Schema
}

func (s *ReadSuite) SetupSuite() {
	s.MockSuiteBase.SetupSuite()
	s.schema = entity.NewSchema().
		WithField(entity.NewField().WithName("ID").WithDataType(entity.FieldTypeInt64).WithIsPrimaryKey(true)).
		WithField(entity.NewField().WithName("Vector").WithDataType(entity.FieldTypeFloatVector).WithDim(128))

	s.schemaDyn = entity.NewSchema().WithDynamicFieldEnabled(true).
		WithField(entity.NewField().WithName("ID").WithDataType(entity.FieldTypeInt64).WithIsPrimaryKey(true)).
		WithField(entity.NewField().WithName("vector").WithDataType(entity.FieldTypeFloatVector).WithDim(128))
}

func (s *ReadSuite) TestSearch() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))
		s.setupCache(collectionName, s.schema)
		s.mock.EXPECT().Search(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, sr *milvuspb.SearchRequest) (*milvuspb.SearchResults, error) {
			s.Equal(collectionName, sr.GetCollectionName())
			s.ElementsMatch([]string{partitionName}, sr.GetPartitionNames())

			return &milvuspb.SearchResults{
				Status: merr.Success(),
				Results: &schemapb.SearchResultData{
					NumQueries: 1,
					TopK:       10,
					FieldsData: []*schemapb.FieldData{
						s.getInt64FieldData("ID", []int64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}),
					},
					Ids: &schemapb.IDs{
						IdField: &schemapb.IDs_IntId{
							IntId: &schemapb.LongArray{
								Data: []int64{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
							},
						},
					},
					Scores: make([]float32, 10),
					Topks:  []int64{10},
				},
			}, nil
		}).Once()

		ap := index.NewCustomAnnParam()
		ap.WithExtraParam("custom_level", 1)
		_, err := s.client.Search(ctx, NewSearchOption(collectionName, 10, []entity.Vector{
			entity.FloatVector(lo.RepeatBy(128, func(_ int) float32 {
				return rand.Float32()
			})),
		}).WithPartitions(partitionName).
			WithFilter("id > {tmpl_id}").
			WithTemplateParam("tmpl_id", 100).
			WithGroupByField("group_by").
			WithSearchParam("ignore_growing", "true").
			WithAnnParam(ap),
		)
		s.NoError(err)
	})

	s.Run("dynamic_schema", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))
		s.setupCache(collectionName, s.schemaDyn)
		s.mock.EXPECT().Search(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, sr *milvuspb.SearchRequest) (*milvuspb.SearchResults, error) {
			return &milvuspb.SearchResults{
				Status: merr.Success(),
				Results: &schemapb.SearchResultData{
					NumQueries: 1,
					TopK:       2,
					FieldsData: []*schemapb.FieldData{
						s.getInt64FieldData("ID", []int64{1, 2}),
						s.getJSONBytesFieldData("$meta", [][]byte{
							[]byte(`{"A": 123, "B": "456"}`),
							[]byte(`{"B": "abc", "A": 456}`),
						}, true),
					},
					Ids: &schemapb.IDs{
						IdField: &schemapb.IDs_IntId{
							IntId: &schemapb.LongArray{
								Data: []int64{1, 2},
							},
						},
					},
					Scores: make([]float32, 2),
					Topks:  []int64{2},
				},
			}, nil
		}).Once()

		_, err := s.client.Search(ctx, NewSearchOption(collectionName, 10, []entity.Vector{
			entity.FloatVector(lo.RepeatBy(128, func(_ int) float32 {
				return rand.Float32()
			})),
		}).WithPartitions(partitionName))
		s.NoError(err)
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		s.setupCache(collectionName, s.schemaDyn)

		_, err := s.client.Search(ctx, NewSearchOption(collectionName, 10, []entity.Vector{nonSupportData{}}))
		s.Error(err)

		s.mock.EXPECT().Search(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, sr *milvuspb.SearchRequest) (*milvuspb.SearchResults, error) {
			return nil, merr.WrapErrServiceInternal("mocked")
		}).Once()

		_, err = s.client.Search(ctx, NewSearchOption(collectionName, 10, []entity.Vector{
			entity.FloatVector(lo.RepeatBy(128, func(_ int) float32 {
				return rand.Float32()
			})),
		}))
		s.Error(err)
	})
}

func (s *ReadSuite) TestHybridSearch() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))
		s.setupCache(collectionName, s.schema)

		s.mock.EXPECT().HybridSearch(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, hsr *milvuspb.HybridSearchRequest) (*milvuspb.SearchResults, error) {
			s.Equal(collectionName, hsr.GetCollectionName())
			s.ElementsMatch([]string{partitionName}, hsr.GetPartitionNames())
			s.ElementsMatch([]string{"*"}, hsr.GetOutputFields())
			return &milvuspb.SearchResults{
				Status: merr.Success(),
				Results: &schemapb.SearchResultData{
					NumQueries: 1,
					TopK:       2,
					FieldsData: []*schemapb.FieldData{
						s.getInt64FieldData("ID", []int64{1, 2}),
						s.getJSONBytesFieldData("$meta", [][]byte{
							[]byte(`{"A": 123, "B": "456"}`),
							[]byte(`{"B": "abc", "A": 456}`),
						}, true),
					},
					Ids: &schemapb.IDs{
						IdField: &schemapb.IDs_IntId{
							IntId: &schemapb.LongArray{
								Data: []int64{1, 2},
							},
						},
					},
					Scores: make([]float32, 2),
					Topks:  []int64{2},
				},
			}, nil
		}).Once()

		_, err := s.client.HybridSearch(ctx, NewHybridSearchOption(collectionName, 5, NewAnnRequest("vector", 10, entity.FloatVector(lo.RepeatBy(128, func(_ int) float32 {
			return rand.Float32()
		}))).WithFilter("ID > 100"), NewAnnRequest("vector", 10, entity.FloatVector(lo.RepeatBy(128, func(_ int) float32 {
			return rand.Float32()
		})))).WithConsistencyLevel(entity.ClStrong).WithPartitons(partitionName).WithReranker(NewRRFReranker()).WithOutputFields("*"))
		s.NoError(err)
	})

	s.Run("failure", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		s.setupCache(collectionName, s.schemaDyn)

		_, err := s.client.HybridSearch(ctx, NewHybridSearchOption(collectionName, 5, NewAnnRequest("vector", 10, nonSupportData{})))
		s.Error(err)

		s.mock.EXPECT().HybridSearch(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, hsr *milvuspb.HybridSearchRequest) (*milvuspb.SearchResults, error) {
			return nil, merr.WrapErrServiceInternal("mocked")
		}).Once()

		_, err = s.client.HybridSearch(ctx, NewHybridSearchOption(collectionName, 5, NewAnnRequest("vector", 10, entity.FloatVector(lo.RepeatBy(128, func(_ int) float32 {
			return rand.Float32()
		}))).WithFilter("ID > 100"), NewAnnRequest("vector", 10, entity.FloatVector(lo.RepeatBy(128, func(_ int) float32 {
			return rand.Float32()
		})))))
		s.Error(err)
	})
}

func (s *ReadSuite) TestQuery() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		partitionName := fmt.Sprintf("part_%s", s.randString(6))
		s.setupCache(collectionName, s.schema)

		s.mock.EXPECT().Query(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, qr *milvuspb.QueryRequest) (*milvuspb.QueryResults, error) {
			s.Equal(collectionName, qr.GetCollectionName())

			return &milvuspb.QueryResults{}, nil
		}).Once()

		rs, err := s.client.Query(ctx, NewQueryOption(collectionName).WithPartitions(partitionName))
		s.NoError(err)
		s.NotNil(rs.sch)
	})

	s.Run("bad_request", func() {
		collectionName := fmt.Sprintf("coll_%s", s.randString(6))
		s.setupCache(collectionName, s.schema)

		_, err := s.client.Query(ctx, NewQueryOption(collectionName).WithFilter("id > {tmpl_id}").WithTemplateParam("tmpl_id", struct{}{}))
		s.Error(err)
	})
}

func TestRead(t *testing.T) {
	suite.Run(t, new(ReadSuite))
}



---
File: /milvusclient/read.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"

	"github.com/cockroachdb/errors"
	"github.com/samber/lo"
	"google.golang.org/grpc"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/column"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
	"github.com/milvus-io/milvus/pkg/v2/util/typeutil"
)

func (c *Client) Search(ctx context.Context, option SearchOption, callOptions ...grpc.CallOption) ([]ResultSet, error) {
	req, err := option.Request()
	if err != nil {
		return nil, err
	}
	collection, err := c.getCollection(ctx, req.GetCollectionName())
	if err != nil {
		return nil, err
	}

	var resultSets []ResultSet

	err = c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.Search(ctx, req, callOptions...)
		err = merr.CheckRPCCall(resp, err)
		if err != nil {
			return err
		}
		resultSets, err = c.handleSearchResult(collection.Schema, req.GetOutputFields(), int(resp.GetResults().GetNumQueries()), resp)

		return err
	})

	return resultSets, err
}

func (c *Client) handleSearchResult(schema *entity.Schema, outputFields []string, nq int, resp *milvuspb.SearchResults) ([]ResultSet, error) {
	sr := make([]ResultSet, 0, nq)
	results := resp.GetResults()
	offset := 0
	fieldDataList := results.GetFieldsData()
	gb := results.GetGroupByFieldValue()
	for i := 0; i < int(results.GetNumQueries()); i++ {
		rc := int(results.GetTopks()[i]) // result entry count for current query
		entry := ResultSet{
			ResultCount: rc,
			Scores:      results.GetScores()[offset : offset+rc],
			sch:         schema,
		}

		// set recall if returned
		if i < len(results.Recalls) {
			entry.Recall = results.Recalls[i]
		}

		entry.IDs, entry.Err = column.IDColumns(schema, results.GetIds(), offset, offset+rc)
		if entry.Err != nil {
			offset += rc
			continue
		}
		// parse group-by values
		if gb != nil {
			entry.GroupByValue, entry.Err = column.FieldDataColumn(gb, offset, offset+rc)
			if entry.Err != nil {
				offset += rc
				continue
			}
		}
		entry.Fields, entry.Err = c.parseSearchResult(schema, outputFields, fieldDataList, i, offset, offset+rc)
		sr = append(sr, entry)

		offset += rc
	}
	return sr, nil
}

func (c *Client) parseSearchResult(sch *entity.Schema, outputFields []string, fieldDataList []*schemapb.FieldData, _, from, to int) ([]column.Column, error) {
	var wildcard bool
	// serveral cases shall be handled here
	// 1. output fields contains "*" wildcard => the schema shall be checked
	// 2. dynamic schema $meta column, with field name not exist in schema
	// 3. explicitly specified json column name
	// 4. partial load field

	// translate "*" into possible field names
	// if partial load enabled, result set could miss some column
	outputFields, wildcard = expandWildcard(sch, outputFields)
	// duplicated field name will be merged into one column
	outputSet := typeutil.NewSet(outputFields...)

	// setup schema valid field name to get possible dynamic field name
	schemaFieldSet := typeutil.NewSet(lo.Map(sch.Fields, func(f *entity.Field, _ int) string {
		return f.Name
	})...)
	dynamicNames := outputSet.Complement(schemaFieldSet)

	columns := make([]column.Column, 0, len(outputFields))
	var dynamicColumn *column.ColumnJSONBytes
	for _, fieldData := range fieldDataList {
		col, err := column.FieldDataColumn(fieldData, from, to)
		if err != nil {
			return nil, err
		}

		// if output data contains dynamic json, setup dynamicColumn
		if fieldData.GetIsDynamic() {
			var ok bool
			dynamicColumn, ok = col.(*column.ColumnJSONBytes)
			if !ok {
				return nil, errors.New("dynamic field not json")
			}

			// return json column only explicitly specified in output fields and not in wildcard mode
			if _, ok := outputSet[fieldData.GetFieldName()]; !ok && !wildcard {
				continue
			}
		}

		// remove processed field, remove from possible dynamic set
		delete(dynamicNames, fieldData.GetFieldName())

		columns = append(columns, col)
	}

	// extra name found and not json output
	if len(dynamicNames) > 0 && dynamicColumn == nil {
		var extraFields []string
		for output := range dynamicNames {
			extraFields = append(extraFields, output)
		}
		return nil, errors.Newf("extra output fields %v found and result does not contain dynamic field", extraFields)
	}
	// add dynamic column for extra fields
	for outputField := range dynamicNames {
		column := column.NewColumnDynamic(dynamicColumn, outputField)
		columns = append(columns, column)
	}

	return columns, nil
}

func (c *Client) Query(ctx context.Context, option QueryOption, callOptions ...grpc.CallOption) (ResultSet, error) {
	var resultSet ResultSet
	req, err := option.Request()
	if err != nil {
		return resultSet, err
	}

	collection, err := c.getCollection(ctx, req.GetCollectionName())
	if err != nil {
		return resultSet, err
	}

	err = c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.Query(ctx, req, callOptions...)
		err = merr.CheckRPCCall(resp, err)
		if err != nil {
			return err
		}

		columns, err := c.parseSearchResult(collection.Schema, resp.GetOutputFields(), resp.GetFieldsData(), 0, 0, -1)
		if err != nil {
			return err
		}
		resultSet = ResultSet{
			sch:    collection.Schema,
			Fields: columns,
		}
		if len(columns) > 0 {
			resultSet.ResultCount = columns[0].Len()
		}

		return nil
	})
	return resultSet, err
}

func (c *Client) Get(ctx context.Context, option QueryOption, callOptions ...grpc.CallOption) (ResultSet, error) {
	return c.Query(ctx, option, callOptions...)
}

func (c *Client) HybridSearch(ctx context.Context, option HybridSearchOption, callOptions ...grpc.CallOption) ([]ResultSet, error) {
	req, err := option.HybridRequest()
	if err != nil {
		return nil, err
	}

	collection, err := c.getCollection(ctx, req.GetCollectionName())
	if err != nil {
		return nil, err
	}

	var resultSets []ResultSet

	err = c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.HybridSearch(ctx, req, callOptions...)
		err = merr.CheckRPCCall(resp, err)
		if err != nil {
			return err
		}

		resultSets, err = c.handleSearchResult(collection.Schema, req.GetOutputFields(), int(resp.GetResults().GetNumQueries()), resp)

		return err
	})
	return resultSets, err
}

func (c *Client) RunAnalyzer(ctx context.Context, option RunAnalyzerOption, callOptions ...grpc.CallOption) ([]*entity.AnalyzerResult, error) {
	req, err := option.Request()
	if err != nil {
		return nil, err
	}

	var result []*entity.AnalyzerResult
	err = c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.RunAnalyzer(ctx, req, callOptions...)
		err = merr.CheckRPCCall(resp, err)
		if err != nil {
			return err
		}

		result = lo.Map(resp.Results, func(result *milvuspb.AnalyzerResult, _ int) *entity.AnalyzerResult {
			return &entity.AnalyzerResult{
				Tokens: lo.Map(result.Tokens, func(token *milvuspb.AnalyzerToken, _ int) *entity.Token {
					return &entity.Token{
						Text:           token.GetToken(),
						StartOffset:    token.GetStartOffset(),
						EndOffset:      token.GetEndOffset(),
						Position:       token.GetPosition(),
						PositionLength: token.GetPositionLength(),
						Hash:           token.GetHash(),
					}
				}),
			}
		})
		return err
	})

	return result, err
}

func expandWildcard(schema *entity.Schema, outputFields []string) ([]string, bool) {
	wildcard := false
	for _, outputField := range outputFields {
		if outputField == "*" {
			wildcard = true
		}
	}
	if !wildcard {
		return outputFields, false
	}

	set := make(map[string]struct{})
	result := make([]string, 0, len(schema.Fields))
	for _, field := range schema.Fields {
		result = append(result, field.Name)
		set[field.Name] = struct{}{}
	}

	// add dynamic fields output
	for _, output := range outputFields {
		if output == "*" {
			continue
		}
		_, ok := set[output]
		if !ok {
			result = append(result, output)
		}
	}
	return result, true
}



---
File: /milvusclient/reranker_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
)

func TestReranker(t *testing.T) {
	checkParam := func(params []*commonpb.KeyValuePair, key string, value string) bool {
		for _, kv := range params {
			if kv.Key == key && kv.Value == value {
				return true
			}
		}
		return false
	}

	t.Run("rffReranker", func(t *testing.T) {
		rr := NewRRFReranker()
		params := rr.GetParams()
		assert.True(t, checkParam(params, rerankType, rrfRerankType))
		assert.True(t, checkParam(params, rerankParams, `{"k":60}`), "default k shall be 60")

		rr.WithK(50)
		params = rr.GetParams()
		assert.True(t, checkParam(params, rerankType, rrfRerankType))
		assert.True(t, checkParam(params, rerankParams, `{"k":50}`))
	})

	t.Run("weightedReranker", func(t *testing.T) {
		rr := NewWeightedReranker([]float64{1, 2, 1})
		params := rr.GetParams()
		assert.True(t, checkParam(params, rerankType, weightedRerankType))
		assert.True(t, checkParam(params, rerankParams, `{"weights":[1,2,1]}`))
	})
}



---
File: /milvusclient/reranker.go
---

package milvusclient

import (
	"encoding/json"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
)

const (
	rerankType    = "strategy"
	rerankParams  = "params"
	rffParam      = "k"
	weightedParam = "weights"

	rrfRerankType      = `rrf`
	weightedRerankType = `weighted`
)

type Reranker interface {
	GetParams() []*commonpb.KeyValuePair
}

type rrfReranker struct {
	K float64 `json:"k,omitempty"`
}

func (r *rrfReranker) WithK(k float64) *rrfReranker {
	r.K = k
	return r
}

func (r *rrfReranker) GetParams() []*commonpb.KeyValuePair {
	bs, _ := json.Marshal(r)

	return []*commonpb.KeyValuePair{
		{Key: rerankType, Value: rrfRerankType},
		{Key: rerankParams, Value: string(bs)},
	}
}

func NewRRFReranker() *rrfReranker {
	return &rrfReranker{K: 60}
}

type weightedReranker struct {
	Weights []float64 `json:"weights,omitempty"`
}

func (r *weightedReranker) GetParams() []*commonpb.KeyValuePair {
	bs, _ := json.Marshal(r)

	return []*commonpb.KeyValuePair{
		{Key: rerankType, Value: weightedRerankType},
		{Key: rerankParams, Value: string(bs)},
	}
}

func NewWeightedReranker(weights []float64) *weightedReranker {
	return &weightedReranker{
		Weights: weights,
	}
}



---
File: /milvusclient/resource_group_example_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// nolint
package milvusclient_test

import (
	"context"
	"fmt"

	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/milvusclient"
)

func ExampleClient_CreateResourceGroup() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	err = cli.CreateResourceGroup(ctx, milvusclient.NewCreateResourceGroupOption("my_rg"))
	if err != nil {
		// handle error
	}
}

func ExampleClient_UpdateResourceGroup() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	err = cli.UpdateResourceGroup(ctx, milvusclient.NewUpdateResourceGroupOption("my_rg", &entity.ResourceGroupConfig{
		Requests: entity.ResourceGroupLimit{NodeNum: 10},
		Limits:   entity.ResourceGroupLimit{NodeNum: 10},
		NodeFilter: entity.ResourceGroupNodeFilter{
			NodeLabels: map[string]string{"my_label1": "a"},
		},
	}))
	if err != nil {
		// handle error
	}
}

func ExampleClient_TransferReplica() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	err = cli.TransferReplica(ctx, milvusclient.NewTransferReplicaOption("quick_setup", "rg_1", "rg_2", 1))
	if err != nil {
		// handle error
	}
}

func ExampleClient_DropResourceGroup() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	err = cli.DropResourceGroup(ctx, milvusclient.NewDropResourceGroupOption("my_rg"))
	if err != nil {
		// handle error
	}
}

func ExampleClient_DescribeResourceGroup() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	rg, err := cli.DescribeResourceGroup(ctx, milvusclient.NewDescribeResourceGroupOption("my_rg"))
	if err != nil {
		// handle error
	}
	fmt.Println(rg)
}

func ExampleClient_ListResourceGroups() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	rgNames, err := cli.ListResourceGroups(ctx, milvusclient.NewListResourceGroupsOption())
	if err != nil {
		// handle error
	}
	fmt.Println(rgNames)
}



---
File: /milvusclient/resource_group_option.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"github.com/samber/lo"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus-proto/go-api/v2/rgpb"
	"github.com/milvus-io/milvus/client/v2/entity"
)

type ListResourceGroupsOption interface {
	Request() *milvuspb.ListResourceGroupsRequest
}

type listResourceGroupsOption struct{}

func (opt *listResourceGroupsOption) Request() *milvuspb.ListResourceGroupsRequest {
	return &milvuspb.ListResourceGroupsRequest{}
}

func NewListResourceGroupsOption() *listResourceGroupsOption {
	return &listResourceGroupsOption{}
}

type CreateResourceGroupOption interface {
	Request() *milvuspb.CreateResourceGroupRequest
}

type createResourceGroupOption struct {
	name        string
	nodeRequest int
	nodeLimit   int
}

func (opt *createResourceGroupOption) WithNodeRequest(nodeRequest int) *createResourceGroupOption {
	opt.nodeRequest = nodeRequest
	return opt
}

func (opt *createResourceGroupOption) WithNodeLimit(nodeLimit int) *createResourceGroupOption {
	opt.nodeLimit = nodeLimit
	return opt
}

func (opt *createResourceGroupOption) Request() *milvuspb.CreateResourceGroupRequest {
	return &milvuspb.CreateResourceGroupRequest{
		ResourceGroup: opt.name,
		Config: &rgpb.ResourceGroupConfig{
			Requests: &rgpb.ResourceGroupLimit{
				NodeNum: int32(opt.nodeRequest),
			},
			Limits: &rgpb.ResourceGroupLimit{
				NodeNum: int32(opt.nodeLimit),
			},
		},
	}
}

func NewCreateResourceGroupOption(name string) *createResourceGroupOption {
	return &createResourceGroupOption{name: name}
}

type DropResourceGroupOption interface {
	Request() *milvuspb.DropResourceGroupRequest
}

type dropResourceGroupOption struct {
	name string
}

func (opt *dropResourceGroupOption) Request() *milvuspb.DropResourceGroupRequest {
	return &milvuspb.DropResourceGroupRequest{
		ResourceGroup: opt.name,
	}
}

func NewDropResourceGroupOption(name string) *dropResourceGroupOption {
	return &dropResourceGroupOption{name: name}
}

type DescribeResourceGroupOption interface {
	Request() *milvuspb.DescribeResourceGroupRequest
}

type describeResourceGroupOption struct {
	name string
}

func (opt *describeResourceGroupOption) Request() *milvuspb.DescribeResourceGroupRequest {
	return &milvuspb.DescribeResourceGroupRequest{
		ResourceGroup: opt.name,
	}
}

func NewDescribeResourceGroupOption(name string) *describeResourceGroupOption {
	return &describeResourceGroupOption{name: name}
}

type UpdateResourceGroupOption interface {
	Request() *milvuspb.UpdateResourceGroupsRequest
}

type updateResourceGroupOption struct {
	name     string
	rgConfig *entity.ResourceGroupConfig
}

func (opt *updateResourceGroupOption) Request() *milvuspb.UpdateResourceGroupsRequest {
	return &milvuspb.UpdateResourceGroupsRequest{
		ResourceGroups: map[string]*rgpb.ResourceGroupConfig{
			opt.name: {
				Requests: &rgpb.ResourceGroupLimit{
					NodeNum: opt.rgConfig.Requests.NodeNum,
				},
				Limits: &rgpb.ResourceGroupLimit{
					NodeNum: opt.rgConfig.Limits.NodeNum,
				},
				TransferFrom: lo.Map(opt.rgConfig.TransferFrom, func(transfer *entity.ResourceGroupTransfer, i int) *rgpb.ResourceGroupTransfer {
					return &rgpb.ResourceGroupTransfer{
						ResourceGroup: transfer.ResourceGroup,
					}
				}),
				TransferTo: lo.Map(opt.rgConfig.TransferTo, func(transfer *entity.ResourceGroupTransfer, i int) *rgpb.ResourceGroupTransfer {
					return &rgpb.ResourceGroupTransfer{
						ResourceGroup: transfer.ResourceGroup,
					}
				}),
				NodeFilter: &rgpb.ResourceGroupNodeFilter{
					NodeLabels: entity.MapKvPairs(opt.rgConfig.NodeFilter.NodeLabels),
				},
			},
		},
	}
}

func NewUpdateResourceGroupOption(name string, resourceGroupConfig *entity.ResourceGroupConfig) *updateResourceGroupOption {
	return &updateResourceGroupOption{
		name:     name,
		rgConfig: resourceGroupConfig,
	}
}

type TransferReplicaOption interface {
	Request() *milvuspb.TransferReplicaRequest
}

type transferReplicaOption struct {
	collectionName string
	sourceRG       string
	targetRG       string
	replicaNum     int64
	dbName         string
}

func (opt *transferReplicaOption) WithDBName(dbName string) *transferReplicaOption {
	opt.dbName = dbName
	return opt
}

func (opt *transferReplicaOption) Request() *milvuspb.TransferReplicaRequest {
	return &milvuspb.TransferReplicaRequest{
		CollectionName:      opt.collectionName,
		SourceResourceGroup: opt.sourceRG,
		TargetResourceGroup: opt.targetRG,
		NumReplica:          opt.replicaNum,
		DbName:              opt.dbName,
	}
}

func NewTransferReplicaOption(collectionName, sourceGroup, targetGroup string, replicaNum int64) *transferReplicaOption {
	return &transferReplicaOption{
		collectionName: collectionName,
		sourceRG:       sourceGroup,
		targetRG:       targetGroup,
		replicaNum:     replicaNum,
	}
}

type DescribeReplicaOption interface {
	Request() *milvuspb.GetReplicasRequest
}

type describeReplicaOption struct {
	collectionName string
}

func (opt *describeReplicaOption) Request() *milvuspb.GetReplicasRequest {
	return &milvuspb.GetReplicasRequest{
		CollectionName: opt.collectionName,
	}
}

func NewDescribeReplicaOption(collectionName string) *describeReplicaOption {
	return &describeReplicaOption{collectionName: collectionName}
}



---
File: /milvusclient/resource_group_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"fmt"
	"math/rand"
	"testing"

	"github.com/cockroachdb/errors"
	"github.com/samber/lo"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus-proto/go-api/v2/rgpb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type ResourceGroupSuite struct {
	MockSuiteBase
}

func (s *ResourceGroupSuite) TestListResourceGroups() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		s.mock.EXPECT().ListResourceGroups(mock.Anything, mock.Anything).Return(&milvuspb.ListResourceGroupsResponse{
			ResourceGroups: []string{"rg1", "rg2"},
		}, nil).Once()
		rgs, err := s.client.ListResourceGroups(ctx, NewListResourceGroupsOption())
		s.NoError(err)
		s.Equal([]string{"rg1", "rg2"}, rgs)
	})

	s.Run("failure", func() {
		s.mock.EXPECT().ListResourceGroups(mock.Anything, mock.Anything).Return(nil, errors.New("mocked")).Once()
		_, err := s.client.ListResourceGroups(ctx, NewListResourceGroupsOption())
		s.Error(err)
	})
}

func (s *ResourceGroupSuite) TestCreateResourceGroup() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		rgName := fmt.Sprintf("rg_%s", s.randString(6))
		s.mock.EXPECT().CreateResourceGroup(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, crgr *milvuspb.CreateResourceGroupRequest) (*commonpb.Status, error) {
			s.Equal(rgName, crgr.GetResourceGroup())
			s.Equal(int32(5), crgr.GetConfig().GetRequests().GetNodeNum())
			s.Equal(int32(10), crgr.GetConfig().GetLimits().GetNodeNum())
			return &commonpb.Status{ErrorCode: commonpb.ErrorCode_Success}, nil
		}).Once()
		opt := NewCreateResourceGroupOption(rgName).WithNodeLimit(10).WithNodeRequest(5)
		err := s.client.CreateResourceGroup(ctx, opt)
		s.NoError(err)
	})

	s.Run("failure", func() {
		rgName := fmt.Sprintf("rg_%s", s.randString(6))
		s.mock.EXPECT().CreateResourceGroup(mock.Anything, mock.Anything).Return(nil, errors.New("mocked")).Once()
		opt := NewCreateResourceGroupOption(rgName).WithNodeLimit(10).WithNodeRequest(5)
		err := s.client.CreateResourceGroup(ctx, opt)
		s.Error(err)
	})
}

func (s *ResourceGroupSuite) TestDropResourceGroup() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		rgName := fmt.Sprintf("rg_%s", s.randString(6))
		s.mock.EXPECT().DropResourceGroup(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, drgr *milvuspb.DropResourceGroupRequest) (*commonpb.Status, error) {
			s.Equal(rgName, drgr.GetResourceGroup())
			return &commonpb.Status{ErrorCode: commonpb.ErrorCode_Success}, nil
		}).Once()
		opt := NewDropResourceGroupOption(rgName)
		err := s.client.DropResourceGroup(ctx, opt)
		s.NoError(err)
	})

	s.Run("failure", func() {
		rgName := fmt.Sprintf("rg_%s", s.randString(6))
		s.mock.EXPECT().DropResourceGroup(mock.Anything, mock.Anything).Return(nil, errors.New("mocked")).Once()
		opt := NewDropResourceGroupOption(rgName)
		err := s.client.DropResourceGroup(ctx, opt)
		s.Error(err)
	})
}

func (s *ResourceGroupSuite) TestDescribeResourceGroup() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		limit := rand.Int31n(10) + 1
		request := rand.Int31n(10) + 1
		rgName := fmt.Sprintf("rg_%s", s.randString(6))
		transferFroms := []string{s.randString(6), s.randString(6)}
		transferTos := []string{s.randString(6), s.randString(6)}
		labels := map[string]string{
			"label1": s.randString(10),
		}
		node := entity.NodeInfo{
			NodeID:   rand.Int63(),
			Address:  s.randString(6),
			HostName: s.randString(10),
		}
		s.mock.EXPECT().DescribeResourceGroup(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, drgr *milvuspb.DescribeResourceGroupRequest) (*milvuspb.DescribeResourceGroupResponse, error) {
			s.Equal(rgName, drgr.GetResourceGroup())
			return &milvuspb.DescribeResourceGroupResponse{
				ResourceGroup: &milvuspb.ResourceGroup{
					Name: rgName,
					Config: &rgpb.ResourceGroupConfig{
						Requests: &rgpb.ResourceGroupLimit{
							NodeNum: request,
						},
						Limits: &rgpb.ResourceGroupLimit{
							NodeNum: limit,
						},
						TransferFrom: lo.Map(transferFroms, func(transfer string, i int) *rgpb.ResourceGroupTransfer {
							return &rgpb.ResourceGroupTransfer{
								ResourceGroup: transfer,
							}
						}),
						TransferTo: lo.Map(transferTos, func(transfer string, i int) *rgpb.ResourceGroupTransfer {
							return &rgpb.ResourceGroupTransfer{
								ResourceGroup: transfer,
							}
						}),
						NodeFilter: &rgpb.ResourceGroupNodeFilter{
							NodeLabels: entity.MapKvPairs(labels),
						},
					},
					Nodes: []*commonpb.NodeInfo{
						{NodeId: node.NodeID, Address: node.Address, Hostname: node.HostName},
					},
				},
			}, nil
		}).Once()
		opt := NewDescribeResourceGroupOption(rgName)
		rg, err := s.client.DescribeResourceGroup(ctx, opt)
		s.NoError(err)
		s.Equal(rgName, rg.Name)
		s.Equal(limit, rg.Config.Limits.NodeNum)
		s.Equal(request, rg.Config.Requests.NodeNum)
		s.ElementsMatch(lo.Map(transferFroms, func(transferFrom string, _ int) *entity.ResourceGroupTransfer {
			return &entity.ResourceGroupTransfer{ResourceGroup: transferFrom}
		}), rg.Config.TransferFrom)
		s.ElementsMatch(lo.Map(transferTos, func(transferTo string, _ int) *entity.ResourceGroupTransfer {
			return &entity.ResourceGroupTransfer{ResourceGroup: transferTo}
		}), rg.Config.TransferTo)
		s.Equal(labels, rg.Config.NodeFilter.NodeLabels)
		s.ElementsMatch([]entity.NodeInfo{node}, rg.Nodes)
	})

	s.Run("failure", func() {
		rgName := fmt.Sprintf("rg_%s", s.randString(6))
		s.mock.EXPECT().DescribeResourceGroup(mock.Anything, mock.Anything).Return(nil, errors.New("mocked")).Once()
		opt := NewDescribeResourceGroupOption(rgName)
		_, err := s.client.DescribeResourceGroup(ctx, opt)
		s.Error(err)
	})
}

func (s *ResourceGroupSuite) TestUpdateResourceGroup() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		limit := rand.Int31n(10) + 1
		request := rand.Int31n(10) + 1
		rgName := fmt.Sprintf("rg_%s", s.randString(6))
		transferFroms := []string{s.randString(6), s.randString(6)}
		transferTos := []string{s.randString(6), s.randString(6)}
		labels := map[string]string{
			"label1": s.randString(10),
		}
		s.mock.EXPECT().UpdateResourceGroups(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, urgr *milvuspb.UpdateResourceGroupsRequest) (*commonpb.Status, error) {
			config, ok := urgr.GetResourceGroups()[rgName]
			s.Require().True(ok)
			s.Equal(request, config.GetRequests().GetNodeNum())
			s.Equal(limit, config.GetLimits().GetNodeNum())
			s.ElementsMatch(transferFroms, lo.Map(config.GetTransferFrom(), func(transfer *rgpb.ResourceGroupTransfer, i int) string {
				return transfer.GetResourceGroup()
			}))
			s.ElementsMatch(transferTos, lo.Map(config.GetTransferTo(), func(transfer *rgpb.ResourceGroupTransfer, i int) string {
				return transfer.GetResourceGroup()
			}))
			s.Equal(labels, entity.KvPairsMap(config.GetNodeFilter().GetNodeLabels()))
			return merr.Success(), nil
		}).Once()
		opt := NewUpdateResourceGroupOption(rgName, &entity.ResourceGroupConfig{
			Requests: entity.ResourceGroupLimit{NodeNum: request},
			Limits:   entity.ResourceGroupLimit{NodeNum: limit},
			TransferFrom: []*entity.ResourceGroupTransfer{
				{ResourceGroup: transferFroms[0]},
				{ResourceGroup: transferFroms[1]},
			},
			TransferTo: []*entity.ResourceGroupTransfer{
				{ResourceGroup: transferTos[0]},
				{ResourceGroup: transferTos[1]},
			},
			NodeFilter: entity.ResourceGroupNodeFilter{
				NodeLabels: labels,
			},
		})
		err := s.client.UpdateResourceGroup(ctx, opt)
		s.NoError(err)
	})

	s.Run("failure", func() {
		rgName := fmt.Sprintf("rg_%s", s.randString(6))
		s.mock.EXPECT().UpdateResourceGroups(mock.Anything, mock.Anything).Return(nil, errors.New("mocked")).Once()
		opt := NewUpdateResourceGroupOption(rgName, &entity.ResourceGroupConfig{})
		err := s.client.UpdateResourceGroup(ctx, opt)
		s.Error(err)
	})
}

func (s *ResourceGroupSuite) TestTransferReplica() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collName := fmt.Sprintf("rg_%s", s.randString(6))
		dbName := fmt.Sprintf("db_%s", s.randString(6))
		from := fmt.Sprintf("rg_%s", s.randString(6))
		to := fmt.Sprintf("rg_%s", s.randString(6))
		replicaNum := rand.Int63n(10) + 1
		s.mock.EXPECT().TransferReplica(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, tr *milvuspb.TransferReplicaRequest) (*commonpb.Status, error) {
			s.Equal(collName, tr.GetCollectionName())
			s.Equal(dbName, tr.GetDbName())
			s.Equal(from, tr.GetSourceResourceGroup())
			s.Equal(to, tr.GetTargetResourceGroup())
			return merr.Success(), nil
		}).Once()
		opt := NewTransferReplicaOption(collName, from, to, replicaNum).WithDBName(dbName)
		err := s.client.TransferReplica(ctx, opt)
		s.NoError(err)
	})

	s.Run("failure", func() {
		rgName := fmt.Sprintf("rg_%s", s.randString(6))
		from := fmt.Sprintf("rg_%s", s.randString(6))
		to := fmt.Sprintf("rg_%s", s.randString(6))
		s.mock.EXPECT().TransferReplica(mock.Anything, mock.Anything).Return(nil, errors.New("mocked")).Once()
		opt := NewTransferReplicaOption(rgName, from, to, 1)
		err := s.client.TransferReplica(ctx, opt)
		s.Error(err)
	})
}

func (s *ResourceGroupSuite) TestDescribeReplica() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collName := fmt.Sprintf("rg_%s", s.randString(6))
		replicas := map[int64]*entity.ReplicaInfo{
			1: {
				ReplicaID:         1,
				ResourceGroupName: "rg_1",
				Shards: []*entity.Shard{
					{ChannelName: "dml_1", ShardNodes: []int64{1, 2, 3}, ShardLeader: 2},
				},
				Nodes:           []int64{1, 2, 3},
				NumOutboundNode: map[string]int32{"dml_1": 1},
			},
		}
		s.mock.EXPECT().GetReplicas(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, grr *milvuspb.GetReplicasRequest) (*milvuspb.GetReplicasResponse, error) {
			return &milvuspb.GetReplicasResponse{
				Replicas: lo.MapToSlice(replicas, func(_ int64, r *entity.ReplicaInfo) *milvuspb.ReplicaInfo {
					return &milvuspb.ReplicaInfo{
						ReplicaID: r.ReplicaID,
						ShardReplicas: lo.Map(r.Shards, func(shard *entity.Shard, _ int) *milvuspb.ShardReplica {
							return &milvuspb.ShardReplica{
								DmChannelName: shard.ChannelName,
								NodeIds:       shard.ShardNodes,
								LeaderID:      shard.ShardLeader,
							}
						}),
						ResourceGroupName: r.ResourceGroupName,
						NodeIds:           r.Nodes,
						NumOutboundNode:   r.NumOutboundNode,
					}
				}),
			}, nil
		}).Once()
		result, err := s.client.DescribeReplica(ctx, NewDescribeReplicaOption(collName))
		s.NoError(err)
		for _, replica := range result {
			expect, ok := replicas[replica.ReplicaID]
			if s.True(ok) {
				s.Equal(expect, replica)
			}
		}
	})

	s.Run("failure", func() {
		collName := fmt.Sprintf("rg_%s", s.randString(6))
		s.mock.EXPECT().GetReplicas(mock.Anything, mock.Anything).Return(nil, errors.New("mock")).Once()
		_, err := s.client.DescribeReplica(ctx, NewDescribeReplicaOption(collName))
		s.Error(err)
	})
}

func TestResourceGroup(t *testing.T) {
	suite.Run(t, new(ResourceGroupSuite))
}



---
File: /milvusclient/resource_group.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"

	"github.com/samber/lo"
	"google.golang.org/grpc"

	"github.com/milvus-io/milvus-proto/go-api/v2/commonpb"
	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus-proto/go-api/v2/rgpb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

func (c *Client) ListResourceGroups(ctx context.Context, opt ListResourceGroupsOption, callOptions ...grpc.CallOption) ([]string, error) {
	req := opt.Request()

	var rgs []string
	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.ListResourceGroups(ctx, req, callOptions...)
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}

		rgs = resp.GetResourceGroups()
		return nil
	})

	return rgs, err
}

func (c *Client) CreateResourceGroup(ctx context.Context, opt CreateResourceGroupOption, callOptions ...grpc.CallOption) error {
	req := opt.Request()

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.CreateResourceGroup(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})

	return err
}

func (c *Client) DropResourceGroup(ctx context.Context, opt DropResourceGroupOption, callOptions ...grpc.CallOption) error {
	req := opt.Request()

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DropResourceGroup(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})

	return err
}

func (c *Client) DescribeResourceGroup(ctx context.Context, opt DescribeResourceGroupOption, callOptions ...grpc.CallOption) (*entity.ResourceGroup, error) {
	req := opt.Request()

	var rg *entity.ResourceGroup
	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.DescribeResourceGroup(ctx, req, callOptions...)
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}

		resultRg := resp.GetResourceGroup()
		rg = &entity.ResourceGroup{
			Name:             resultRg.GetName(),
			Capacity:         resultRg.GetCapacity(),
			NumAvailableNode: resultRg.GetNumAvailableNode(),
			NumLoadedReplica: resultRg.GetNumLoadedReplica(),
			NumOutgoingNode:  resultRg.GetNumOutgoingNode(),
			NumIncomingNode:  resultRg.GetNumIncomingNode(),
			Config: &entity.ResourceGroupConfig{
				Requests: entity.ResourceGroupLimit{
					NodeNum: resultRg.GetConfig().GetRequests().GetNodeNum(),
				},
				Limits: entity.ResourceGroupLimit{
					NodeNum: resultRg.GetConfig().GetLimits().GetNodeNum(),
				},
				TransferFrom: lo.Map(resultRg.GetConfig().GetTransferFrom(), func(transfer *rgpb.ResourceGroupTransfer, i int) *entity.ResourceGroupTransfer {
					return &entity.ResourceGroupTransfer{
						ResourceGroup: transfer.GetResourceGroup(),
					}
				}),
				TransferTo: lo.Map(resultRg.GetConfig().GetTransferTo(), func(transfer *rgpb.ResourceGroupTransfer, i int) *entity.ResourceGroupTransfer {
					return &entity.ResourceGroupTransfer{
						ResourceGroup: transfer.GetResourceGroup(),
					}
				}),
				NodeFilter: entity.ResourceGroupNodeFilter{
					NodeLabels: entity.KvPairsMap(resultRg.GetConfig().GetNodeFilter().GetNodeLabels()),
				},
			},
			Nodes: lo.Map(resultRg.GetNodes(), func(node *commonpb.NodeInfo, i int) entity.NodeInfo {
				return entity.NodeInfo{
					NodeID:   node.GetNodeId(),
					Address:  node.GetAddress(),
					HostName: node.GetHostname(),
				}
			}),
		}

		return nil
	})
	return rg, err
}

func (c *Client) UpdateResourceGroup(ctx context.Context, opt UpdateResourceGroupOption, callOptions ...grpc.CallOption) error {
	req := opt.Request()

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.UpdateResourceGroups(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})

	return err
}

func (c *Client) TransferReplica(ctx context.Context, opt TransferReplicaOption, callOptions ...grpc.CallOption) error {
	req := opt.Request()

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.TransferReplica(ctx, req, callOptions...)
		return merr.CheckRPCCall(resp, err)
	})

	return err
}

func (c *Client) DescribeReplica(ctx context.Context, opt DescribeReplicaOption, callOptions ...grpc.CallOption) ([]*entity.ReplicaInfo, error) {
	req := opt.Request()

	var result []*entity.ReplicaInfo

	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.GetReplicas(ctx, req, callOptions...)

		if err := merr.CheckRPCCall(resp, err); err != nil {
			return err
		}

		result = lo.Map(resp.GetReplicas(), func(replica *milvuspb.ReplicaInfo, _ int) *entity.ReplicaInfo {
			return &entity.ReplicaInfo{
				ReplicaID: replica.GetReplicaID(),
				Shards: lo.Map(replica.GetShardReplicas(), func(shardReplica *milvuspb.ShardReplica, _ int) *entity.Shard {
					return &entity.Shard{
						ChannelName: shardReplica.GetDmChannelName(),
						ShardNodes:  shardReplica.GetNodeIds(),
						ShardLeader: shardReplica.GetLeaderID(),
					}
				}),
				Nodes:             replica.GetNodeIds(),
				ResourceGroupName: replica.GetResourceGroupName(),
				NumOutboundNode:   replica.GetNumOutboundNode(),
			}
		})

		return nil
	})
	return result, err
}



---
File: /milvusclient/results_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"testing"

	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus/client/v2/column"
	"github.com/milvus-io/milvus/client/v2/entity"
)

type ResultSetSuite struct {
	suite.Suite
}

func (s *ResultSetSuite) TestResultsetUnmarshal() {
	type MyData struct {
		A     int64     `milvus:"name:id"`
		V     []float32 `milvus:"name:vector"`
		Fp16V []byte    `milvus:"name:fp16_vector"`
		Bf16V []byte    `milvus:"name:bf16_vector"`
	}
	type OtherData struct {
		A     string    `milvus:"name:id"`
		V     []float32 `milvus:"name:vector"`
		Fp16V []byte    `milvus:"name:fp16_vector"`
		Bf16V []byte    `milvus:"name:bf16_vector"`
	}

	var (
		idData     = []int64{1, 2, 3}
		vectorData = [][]float32{
			{0.1, 0.2},
			{0.1, 0.2},
			{0.1, 0.2},
		}
	)

	rs := DataSet([]column.Column{
		column.NewColumnInt64("id", idData),
		column.NewColumnFloatVector("vector", 2, vectorData),
		column.NewColumnFloat16VectorFromFp32Vector("fp16_vector", 2, vectorData),
		column.NewColumnBFloat16VectorFromFp32Vector("bf16_vector", 2, vectorData),
	})
	err := rs.Unmarshal([]MyData{})
	s.Error(err)

	receiver := []MyData{}
	err = rs.Unmarshal(&receiver)
	s.Error(err)

	var ptrReceiver []*MyData
	err = rs.Unmarshal(&ptrReceiver)
	s.NoError(err)

	for idx, row := range ptrReceiver {
		s.Equal(row.A, idData[idx])
		s.Equal(row.V, vectorData[idx])
		s.Equal(entity.Float16Vector(row.Fp16V), entity.FloatVector(vectorData[idx]).ToFloat16Vector())
		s.Equal(entity.BFloat16Vector(row.Bf16V), entity.FloatVector(vectorData[idx]).ToBFloat16Vector())
	}

	var otherReceiver []*OtherData
	err = rs.Unmarshal(&otherReceiver)
	s.Error(err)
}

func (s *ResultSetSuite) TestSearchResultUnmarshal() {
	type MyData struct {
		A     int64     `milvus:"name:id"`
		V     []float32 `milvus:"name:vector"`
		Fp16V []byte    `milvus:"name:fp16_vector"`
		Bf16V []byte    `milvus:"name:bf16_vector"`
	}
	type OtherData struct {
		A     string    `milvus:"name:id"`
		V     []float32 `milvus:"name:vector"`
		Fp16V []byte    `milvus:"name:fp16_vector"`
		Bf16V []byte    `milvus:"name:bf16_vector"`
	}

	var (
		idData     = []int64{1, 2, 3}
		vectorData = [][]float32{
			{0.1, 0.2},
			{0.1, 0.2},
			{0.1, 0.2},
		}
	)

	sr := ResultSet{
		sch: entity.NewSchema().
			WithField(entity.NewField().WithName("id").WithIsPrimaryKey(true).WithDataType(entity.FieldTypeInt64)).
			WithField(entity.NewField().WithName("vector").WithDim(2).WithDataType(entity.FieldTypeFloatVector)).
			WithField(entity.NewField().WithName("fp16_vector").WithDim(2).WithDataType(entity.FieldTypeFloat16Vector)).
			WithField(entity.NewField().WithName("bf16_vector").WithDim(2).WithDataType(entity.FieldTypeBFloat16Vector)),
		IDs: column.NewColumnInt64("id", idData),
		Fields: DataSet([]column.Column{
			column.NewColumnFloatVector("vector", 2, vectorData),
			column.NewColumnFloat16VectorFromFp32Vector("fp16_vector", 2, vectorData),
			column.NewColumnBFloat16VectorFromFp32Vector("bf16_vector", 2, vectorData),
		}),
	}
	err := sr.Unmarshal([]MyData{})
	s.Error(err)

	receiver := []MyData{}
	err = sr.Unmarshal(&receiver)
	s.Error(err)

	var ptrReceiver []*MyData
	err = sr.Unmarshal(&ptrReceiver)
	s.NoError(err)

	for idx, row := range ptrReceiver {
		s.Equal(row.A, idData[idx])
		s.Equal(row.V, vectorData[idx])
		s.Equal(entity.Float16Vector(row.Fp16V), entity.FloatVector(vectorData[idx]).ToFloat16Vector())
		s.Equal(entity.BFloat16Vector(row.Bf16V), entity.FloatVector(vectorData[idx]).ToBFloat16Vector())
	}

	var otherReceiver []*OtherData
	err = sr.Unmarshal(&otherReceiver)
	s.Error(err)
}

func TestResults(t *testing.T) {
	suite.Run(t, new(ResultSetSuite))
}



---
File: /milvusclient/results.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"reflect"
	"runtime/debug"

	"github.com/cockroachdb/errors"

	"github.com/milvus-io/milvus/client/v2/column"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/row"
)

// ResultSet is struct for search result set.
type ResultSet struct {
	// internal schema for unmarshaling
	sch *entity.Schema

	ResultCount  int // the returning entry count
	GroupByValue column.Column
	IDs          column.Column // auto generated id, can be mapped to the columns from `Insert` API
	Fields       DataSet       // output field data
	Scores       []float32     // distance to the target vector
	Recall       float32       // recall of the query vector's search result (estimated by zilliz cloud)
	Err          error         // search error if any
}

// GetColumn returns column with provided field name.
func (rs *ResultSet) GetColumn(fieldName string) column.Column {
	for _, column := range rs.Fields {
		if column.Name() == fieldName {
			return column
		}
	}
	return nil
}

// Unmarshal puts dataset into receiver in row based way.
// `receiver` shall be a slice of pointer of model struct
// eg, []*Records, in which type `Record` defines the row data.
// note that distance/score is not unmarshaled here.
func (sr *ResultSet) Unmarshal(receiver any) (err error) {
	err = sr.Fields.Unmarshal(receiver)
	if err != nil {
		return err
	}
	return sr.fillPKEntry(receiver)
}

func (sr *ResultSet) fillPKEntry(receiver any) (err error) {
	defer func() {
		if x := recover(); x != nil {
			err = errors.Newf("failed to unmarshal result set: %v, stack: %v", x, string(debug.Stack()))
		}
	}()
	rr := reflect.ValueOf(receiver)

	if rr.Kind() == reflect.Ptr {
		if rr.IsNil() && rr.CanAddr() {
			rr.Set(reflect.New(rr.Type().Elem()))
		}
		rr = rr.Elem()
	}

	rt := rr.Type()
	rv := rr

	switch rt.Kind() {
	case reflect.Slice:
		pkField := sr.sch.PKField()

		et := rt.Elem()
		for et.Kind() == reflect.Ptr {
			et = et.Elem()
		}

		candidates := row.ParseCandidate(et)
		candi, ok := candidates[pkField.Name]
		if !ok {
			// pk field not found in struct, skip
			return nil
		}
		for i := 0; i < sr.IDs.Len(); i++ {
			row := rv.Index(i)
			for row.Kind() == reflect.Ptr {
				row = row.Elem()
			}

			val, err := sr.IDs.Get(i)
			if err != nil {
				return err
			}
			row.Field(candi).Set(reflect.ValueOf(val))
		}
		rr.Set(rv)
	default:
		return errors.Newf("receiver need to be slice or array but get %v", rt.Kind())
	}
	return nil
}

// DataSet is an alias type for column slice.
// Returned by query API.
type DataSet []column.Column

// Len returns the row count of dataset.
// if there is no column, it shall return 0.
func (ds DataSet) Len() int {
	if len(ds) == 0 {
		return 0
	}
	return ds[0].Len()
}

// Unmarshal puts dataset into receiver in row based way.
// `receiver` shall be a slice of pointer of model struct
// eg, []*Records, in which type `Record` defines the row data.
func (ds DataSet) Unmarshal(receiver any) (err error) {
	defer func() {
		if x := recover(); x != nil {
			err = errors.Newf("failed to unmarshal result set: %v, stack: %v", x, string(debug.Stack()))
		}
	}()
	rr := reflect.ValueOf(receiver)

	if rr.Kind() == reflect.Ptr {
		if rr.IsNil() && rr.CanAddr() {
			rr.Set(reflect.New(rr.Type().Elem()))
		}
		rr = rr.Elem()
	}

	rt := rr.Type()
	rv := rr

	switch rt.Kind() {
	// TODO maybe support Array and just fill data
	// case reflect.Array:
	case reflect.Slice:
		et := rt.Elem()
		if et.Kind() != reflect.Ptr {
			return errors.Newf("receiver must be slice of pointers but get: %v", et.Kind())
		}
		for et.Kind() == reflect.Ptr {
			et = et.Elem()
		}
		for i := 0; i < ds.Len(); i++ {
			data := reflect.New(et)
			err := ds.fillData(data.Elem(), et, i)
			if err != nil {
				return err
			}
			rv = reflect.Append(rv, data)
		}
		rr.Set(rv)
	default:
		return errors.Newf("receiver need to be slice or array but get %v", rt.Kind())
	}
	return nil
}

func (ds DataSet) fillData(data reflect.Value, dataType reflect.Type, idx int) error {
	m := row.ParseCandidate(dataType)
	for i := 0; i < len(ds); i++ {
		name := ds[i].Name()
		fidx, ok := m[name]
		if !ok {
			// if target is not found, the behavior here is to ignore the column
			// `strict` mode could be added in the future to return error if any column missing
			continue
		}
		val, err := ds[i].Get(idx)
		if err != nil {
			return err
		}
		// TODO check datatype, return error here instead of reflect panicking & recover
		data.Field(fidx).Set(reflect.ValueOf(val))
	}
	return nil
}



---
File: /milvusclient/write_example_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// nolint
package milvusclient_test

import (
	"context"
	"fmt"

	"github.com/milvus-io/milvus/client/v2/column"
	"github.com/milvus-io/milvus/client/v2/milvusclient"
)

func ExampleClient_Insert_columnbase() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	resp, err := cli.Insert(ctx, milvusclient.NewColumnBasedInsertOption("quick_setup").
		WithInt64Column("id", []int64{1, 2, 3, 4, 5, 6, 7, 8, 9}).
		WithVarcharColumn("color", []string{"pink_8682", "red_7025", "orange_6781", "pink_9298", "red_4794", "yellow_4222", "red_9392", "grey_8510", "white_9381", "purple_4976"}).
		WithFloatVectorColumn("vector", 5, [][]float32{
			{0.3580376395471989, -0.6023495712049978, 0.18414012509913835, -0.26286205330961354, 0.9029438446296592},
			{0.19886812562848388, 0.06023560599112088, 0.6976963061752597, 0.2614474506242501, 0.838729485096104},
			{0.43742130801983836, -0.5597502546264526, 0.6457887650909682, 0.7894058910881185, 0.20785793220625592},
			{0.3172005263489739, 0.9719044792798428, -0.36981146090600725, -0.4860894583077995, 0.95791889146345},
			{0.4452349528804562, -0.8757026943054742, 0.8220779437047674, 0.46406290649483184, 0.30337481143159106},
			{0.985825131989184, -0.8144651566660419, 0.6299267002202009, 0.1206906911183383, -0.1446277761879955},
			{0.8371977790571115, -0.015764369584852833, -0.31062937026679327, -0.562666951622192, -0.8984947637863987},
			{-0.33445148015177995, -0.2567135004164067, 0.8987539745369246, 0.9402995886420709, 0.5378064918413052},
			{0.39524717779832685, 0.4000257286739164, -0.5890507376891594, -0.8650502298996872, -0.6140360785406336},
			{0.5718280481994695, 0.24070317428066512, -0.3737913482606834, -0.06726932177492717, -0.6980531615588608},
		}),
	)
	if err != nil {
		// handle err
	}
	fmt.Println(resp)
}

func ExampleClient_Insert_binaryVector() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	resp, err := cli.Insert(ctx, milvusclient.NewColumnBasedInsertOption("quick_setup").
		WithBinaryVectorColumn("binary_vector", 128, [][]byte{
			{0b10011011, 0b01010100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0b10011011, 0b01010101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
		}))
	if err != nil {
		// handle err
	}
	fmt.Println(resp)
}

func ExampleClient_Insert_jsonData() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	resp, err := cli.Insert(ctx, milvusclient.NewColumnBasedInsertOption("my_json_collection").
		WithInt64Column("pk", []int64{1, 2, 3, 4}).
		WithFloatVectorColumn("embedding", 3, [][]float32{
			{0.12, 0.34, 0.56},
			{0.56, 0.78, 0.90},
			{0.91, 0.18, 0.23},
			{0.56, 0.38, 0.21},
		}).WithColumns(
		column.NewColumnJSONBytes("metadata", [][]byte{
			[]byte(`{
            "product_info": {"category": "electronics", "brand": "BrandA"},
            "price": 99.99,
            "in_stock": True,
            "tags": ["summer_sale"]
        }`),
			[]byte(`null`),
			[]byte(`null`),
			[]byte(`"metadata": {
            "product_info": {"category": None, "brand": "BrandB"},
            "price": 59.99,
            "in_stock": None
        }`),
		}),
	))
	if err != nil {
		// handle err
	}
	fmt.Println(resp)
}

func ExampleClient_Upsert_columnBase() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	resp, err := cli.Upsert(ctx, milvusclient.NewColumnBasedInsertOption("quick_setup").
		WithInt64Column("id", []int64{1, 2, 3, 4, 5, 6, 7, 8, 9}).
		WithVarcharColumn("color", []string{"pink_8682", "red_7025", "orange_6781", "pink_9298", "red_4794", "yellow_4222", "red_9392", "grey_8510", "white_9381", "purple_4976"}).
		WithFloatVectorColumn("vector", 5, [][]float32{
			{0.3580376395471989, -0.6023495712049978, 0.18414012509913835, -0.26286205330961354, 0.9029438446296592},
			{0.19886812562848388, 0.06023560599112088, 0.6976963061752597, 0.2614474506242501, 0.838729485096104},
			{0.43742130801983836, -0.5597502546264526, 0.6457887650909682, 0.7894058910881185, 0.20785793220625592},
			{0.3172005263489739, 0.9719044792798428, -0.36981146090600725, -0.4860894583077995, 0.95791889146345},
			{0.4452349528804562, -0.8757026943054742, 0.8220779437047674, 0.46406290649483184, 0.30337481143159106},
			{0.985825131989184, -0.8144651566660419, 0.6299267002202009, 0.1206906911183383, -0.1446277761879955},
			{0.8371977790571115, -0.015764369584852833, -0.31062937026679327, -0.562666951622192, -0.8984947637863987},
			{-0.33445148015177995, -0.2567135004164067, 0.8987539745369246, 0.9402995886420709, 0.5378064918413052},
			{0.39524717779832685, 0.4000257286739164, -0.5890507376891594, -0.8650502298996872, -0.6140360785406336},
			{0.5718280481994695, 0.24070317428066512, -0.3737913482606834, -0.06726932177492717, -0.6980531615588608},
		}),
	)
	if err != nil {
		// handle err
	}
	fmt.Println(resp)
}

func ExampleClient_Delete() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
	}

	defer cli.Close(ctx)

	res, err := cli.Delete(ctx, milvusclient.NewDeleteOption("quick_setup").
		WithInt64IDs("id", []int64{1, 2, 3}))
	if err != nil {
		// handle error
	}

	fmt.Println(res.DeleteCount)
}



---
File: /milvusclient/write_option_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus/client/v2/column"
	"github.com/milvus-io/milvus/client/v2/entity"
)

type ColumnBasedDataOptionSuite struct {
	MockSuiteBase
}

func (s *ColumnBasedDataOptionSuite) NullableCompatible() {
	intCol := column.NewColumnInt64("rbdo_field", []int64{1, 2, 3})
	rbdo := NewColumnBasedInsertOption("rbdo_nullable", intCol)

	coll := &entity.Collection{
		Schema: entity.NewSchema().WithField(entity.NewField().WithName("rbdo_field").WithDataType(entity.FieldTypeInt64).WithNullable(true)),
	}
	req, err := rbdo.InsertRequest(coll)
	s.NoError(err)

	s.Require().Len(req.GetFieldsData(), 1)
	fd := req.GetFieldsData()[0]
	s.ElementsMatch([]int64{1, 2, 3}, fd.GetScalars().GetLongData())
	s.ElementsMatch([]bool{true, true, true}, fd.GetValidData())
}

func TestRowBasedDataOption(t *testing.T) {
	suite.Run(t, new(ColumnBasedDataOptionSuite))
}

type DeleteOptionSuite struct {
	MockSuiteBase
}

func (s *DeleteOptionSuite) TestBasic() {
	collectionName := fmt.Sprintf("coll_%s", s.randString(6))
	opt := NewDeleteOption(collectionName)

	s.Equal(collectionName, opt.Request().GetCollectionName())
}

func TestDeleteOption(t *testing.T) {
	suite.Run(t, new(DeleteOptionSuite))
}



---
File: /milvusclient/write_options.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/cockroachdb/errors"
	"github.com/samber/lo"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/column"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/client/v2/row"
	"github.com/milvus-io/milvus/pkg/v2/util/typeutil"
)

type InsertOption interface {
	InsertRequest(coll *entity.Collection) (*milvuspb.InsertRequest, error)
	CollectionName() string
	WriteBackPKs(schema *entity.Schema, pks column.Column) error
}

type UpsertOption interface {
	UpsertRequest(coll *entity.Collection) (*milvuspb.UpsertRequest, error)
	CollectionName() string
}

var (
	_ UpsertOption = (*columnBasedDataOption)(nil)
	_ InsertOption = (*columnBasedDataOption)(nil)
)

type columnBasedDataOption struct {
	collName      string
	partitionName string
	columns       []column.Column
}

func (opt *columnBasedDataOption) WriteBackPKs(_ *entity.Schema, _ column.Column) error {
	// column based data option need not write back pk
	return nil
}

func (opt *columnBasedDataOption) processInsertColumns(colSchema *entity.Schema, columns ...column.Column) ([]*schemapb.FieldData, int, error) {
	// setup dynamic related var
	isDynamic := colSchema.EnableDynamicField

	// check columns and field matches
	var rowSize int
	mNameField := make(map[string]*entity.Field)
	for _, field := range colSchema.Fields {
		mNameField[field.Name] = field
	}
	mNameColumn := make(map[string]column.Column)
	var dynamicColumns []column.Column
	for _, col := range columns {
		_, dup := mNameColumn[col.Name()]
		if dup {
			return nil, 0, fmt.Errorf("duplicated column %s found", col.Name())
		}
		l := col.Len()
		if rowSize == 0 {
			rowSize = l
		} else if rowSize != l {
			return nil, 0, errors.New("column size not match")
		}
		field, has := mNameField[col.Name()]
		if !has {
			if !isDynamic {
				return nil, 0, fmt.Errorf("field %s does not exist in collection %s", col.Name(), colSchema.CollectionName)
			}
			// add to dynamic column list for further processing
			dynamicColumns = append(dynamicColumns, col)
			continue
		}
		// make non-nullable created column fit nullable field definition
		if field.Nullable {
			col.SetNullable(true)
		}

		mNameColumn[col.Name()] = col
		if col.Type() != field.DataType {
			return nil, 0, fmt.Errorf("param column %s has type %v but collection field definition is %v", col.Name(), col.Type(), field.DataType)
		}
		if field.DataType == entity.FieldTypeFloatVector || field.DataType == entity.FieldTypeBinaryVector ||
			field.DataType == entity.FieldTypeFloat16Vector || field.DataType == entity.FieldTypeBFloat16Vector {
			dim := 0
			switch column := col.(type) {
			case *column.ColumnFloatVector:
				dim = column.Dim()
			case *column.ColumnBinaryVector:
				dim = column.Dim()
			case *column.ColumnFloat16Vector:
				dim = column.Dim()
			case *column.ColumnBFloat16Vector:
				dim = column.Dim()
			}
			if fmt.Sprintf("%d", dim) != field.TypeParams[entity.TypeParamDim] {
				return nil, 0, fmt.Errorf("params column %s vector dim %d not match collection definition, which has dim of %s", field.Name, dim, field.TypeParams[entity.TypeParamDim])
			}
		}
	}

	// missing field shall be checked in server side
	// // check all fixed field pass value
	// for _, field := range colSchema.Fields {
	// 	_, has := mNameColumn[field.Name]
	// 	if !has &&
	// 		!field.AutoID && !field.IsDynamic {
	// 		return nil, 0, fmt.Errorf("field %s not passed", field.Name)
	// 	}
	// }

	fieldsData := make([]*schemapb.FieldData, 0, len(mNameColumn)+1)
	for _, fixedColumn := range mNameColumn {
		// make sure the field data in compact mode
		fixedColumn.CompactNullableValues()
		fieldsData = append(fieldsData, fixedColumn.FieldData())
	}
	if len(dynamicColumns) > 0 {
		// use empty column name here
		col, err := opt.mergeDynamicColumns("", rowSize, dynamicColumns)
		if err != nil {
			return nil, 0, err
		}
		fieldsData = append(fieldsData, col)
	}

	return fieldsData, rowSize, nil
}

func (opt *columnBasedDataOption) mergeDynamicColumns(dynamicName string, rowSize int, columns []column.Column) (*schemapb.FieldData, error) {
	values := make([][]byte, 0, rowSize)
	for i := 0; i < rowSize; i++ {
		m := make(map[string]interface{})
		for _, column := range columns {
			// range guaranteed
			m[column.Name()], _ = column.Get(i)
		}
		bs, err := json.Marshal(m)
		if err != nil {
			return nil, err
		}
		values = append(values, bs)
	}
	return &schemapb.FieldData{
		Type:      schemapb.DataType_JSON,
		FieldName: dynamicName,
		Field: &schemapb.FieldData_Scalars{
			Scalars: &schemapb.ScalarField{
				Data: &schemapb.ScalarField_JsonData{
					JsonData: &schemapb.JSONArray{
						Data: values,
					},
				},
			},
		},
		IsDynamic: true,
	}, nil
}

func (opt *columnBasedDataOption) WithColumns(columns ...column.Column) *columnBasedDataOption {
	opt.columns = append(opt.columns, columns...)
	return opt
}

func (opt *columnBasedDataOption) WithBoolColumn(colName string, data []bool) *columnBasedDataOption {
	column := column.NewColumnBool(colName, data)
	return opt.WithColumns(column)
}

func (opt *columnBasedDataOption) WithInt8Column(colName string, data []int8) *columnBasedDataOption {
	column := column.NewColumnInt8(colName, data)
	return opt.WithColumns(column)
}

func (opt *columnBasedDataOption) WithInt16Column(colName string, data []int16) *columnBasedDataOption {
	column := column.NewColumnInt16(colName, data)
	return opt.WithColumns(column)
}

func (opt *columnBasedDataOption) WithInt32Column(colName string, data []int32) *columnBasedDataOption {
	column := column.NewColumnInt32(colName, data)
	return opt.WithColumns(column)
}

func (opt *columnBasedDataOption) WithInt64Column(colName string, data []int64) *columnBasedDataOption {
	column := column.NewColumnInt64(colName, data)
	return opt.WithColumns(column)
}

func (opt *columnBasedDataOption) WithVarcharColumn(colName string, data []string) *columnBasedDataOption {
	column := column.NewColumnVarChar(colName, data)
	return opt.WithColumns(column)
}

func (opt *columnBasedDataOption) WithFloatVectorColumn(colName string, dim int, data [][]float32) *columnBasedDataOption {
	column := column.NewColumnFloatVector(colName, dim, data)
	return opt.WithColumns(column)
}

func (opt *columnBasedDataOption) WithFloat16VectorColumn(colName string, dim int, data [][]float32) *columnBasedDataOption {
	f16v := make([][]byte, 0, len(data))
	for i := 0; i < len(data); i++ {
		f16v = append(f16v, typeutil.Float32ArrayToFloat16Bytes(data[i]))
	}
	column := column.NewColumnFloat16Vector(colName, dim, f16v)
	return opt.WithColumns(column)
}

func (opt *columnBasedDataOption) WithBFloat16VectorColumn(colName string, dim int, data [][]float32) *columnBasedDataOption {
	bf16v := make([][]byte, 0, len(data))
	for i := 0; i < len(data); i++ {
		bf16v = append(bf16v, typeutil.Float32ArrayToBFloat16Bytes(data[i]))
	}
	column := column.NewColumnBFloat16Vector(colName, dim, bf16v)
	return opt.WithColumns(column)
}

func (opt *columnBasedDataOption) WithBinaryVectorColumn(colName string, dim int, data [][]byte) *columnBasedDataOption {
	column := column.NewColumnBinaryVector(colName, dim, data)
	return opt.WithColumns(column)
}

func (opt *columnBasedDataOption) WithPartition(partitionName string) *columnBasedDataOption {
	opt.partitionName = partitionName
	return opt
}

func (opt *columnBasedDataOption) CollectionName() string {
	return opt.collName
}

func (opt *columnBasedDataOption) InsertRequest(coll *entity.Collection) (*milvuspb.InsertRequest, error) {
	fieldsData, rowNum, err := opt.processInsertColumns(coll.Schema, opt.columns...)
	if err != nil {
		return nil, err
	}
	return &milvuspb.InsertRequest{
		CollectionName:  opt.collName,
		PartitionName:   opt.partitionName,
		FieldsData:      fieldsData,
		NumRows:         uint32(rowNum),
		SchemaTimestamp: coll.UpdateTimestamp,
	}, nil
}

func (opt *columnBasedDataOption) UpsertRequest(coll *entity.Collection) (*milvuspb.UpsertRequest, error) {
	fieldsData, rowNum, err := opt.processInsertColumns(coll.Schema, opt.columns...)
	if err != nil {
		return nil, err
	}
	return &milvuspb.UpsertRequest{
		CollectionName:  opt.collName,
		PartitionName:   opt.partitionName,
		FieldsData:      fieldsData,
		NumRows:         uint32(rowNum),
		SchemaTimestamp: coll.UpdateTimestamp,
	}, nil
}

func NewColumnBasedInsertOption(collName string, columns ...column.Column) *columnBasedDataOption {
	return &columnBasedDataOption{
		columns:  columns,
		collName: collName,
		// leave partition name empty, using default partition
	}
}

type rowBasedDataOption struct {
	*columnBasedDataOption
	rows []any
}

func NewRowBasedInsertOption(collName string, rows ...any) *rowBasedDataOption {
	return &rowBasedDataOption{
		columnBasedDataOption: &columnBasedDataOption{
			collName: collName,
		},
		rows: rows,
	}
}

func (opt *rowBasedDataOption) InsertRequest(coll *entity.Collection) (*milvuspb.InsertRequest, error) {
	columns, err := row.AnyToColumns(opt.rows, coll.Schema)
	if err != nil {
		return nil, err
	}
	opt.columnBasedDataOption.columns = columns
	fieldsData, rowNum, err := opt.processInsertColumns(coll.Schema, opt.columns...)
	if err != nil {
		return nil, err
	}
	return &milvuspb.InsertRequest{
		CollectionName: opt.collName,
		PartitionName:  opt.partitionName,
		FieldsData:     fieldsData,
		NumRows:        uint32(rowNum),
	}, nil
}

func (opt *rowBasedDataOption) UpsertRequest(coll *entity.Collection) (*milvuspb.UpsertRequest, error) {
	columns, err := row.AnyToColumns(opt.rows, coll.Schema)
	if err != nil {
		return nil, err
	}
	opt.columnBasedDataOption.columns = columns
	fieldsData, rowNum, err := opt.processInsertColumns(coll.Schema, opt.columns...)
	if err != nil {
		return nil, err
	}
	return &milvuspb.UpsertRequest{
		CollectionName: opt.collName,
		PartitionName:  opt.partitionName,
		FieldsData:     fieldsData,
		NumRows:        uint32(rowNum),
	}, nil
}

func (opt *rowBasedDataOption) WriteBackPKs(sch *entity.Schema, pks column.Column) error {
	pkField := sch.PKField()
	// not auto id, return
	if pkField == nil || !pkField.AutoID {
		return nil
	}
	if len(opt.rows) != pks.Len() {
		return errors.New("input row count is not equal to result pk length")
	}

	for i, r := range opt.rows {
		// index range checked
		v, _ := pks.Get(i)
		err := row.SetField(r, pkField.Name, v)
		if err != nil {
			return err
		}
	}

	return nil
}

type DeleteOption interface {
	Request() *milvuspb.DeleteRequest
}

type deleteOption struct {
	collectionName string
	partitionName  string
	expr           string
}

func (opt *deleteOption) Request() *milvuspb.DeleteRequest {
	return &milvuspb.DeleteRequest{
		CollectionName: opt.collectionName,
		PartitionName:  opt.partitionName,
		Expr:           opt.expr,
	}
}

func (opt *deleteOption) WithExpr(expr string) *deleteOption {
	opt.expr = expr
	return opt
}

func (opt *deleteOption) WithInt64IDs(fieldName string, ids []int64) *deleteOption {
	opt.expr = fmt.Sprintf("%s in %s", fieldName, strings.Join(strings.Fields(fmt.Sprint(ids)), ","))
	return opt
}

func (opt *deleteOption) WithStringIDs(fieldName string, ids []string) *deleteOption {
	opt.expr = fmt.Sprintf("%s in [%s]", fieldName, strings.Join(lo.Map(ids, func(id string, _ int) string { return fmt.Sprintf("\"%s\"", id) }), ","))
	return opt
}

func (opt *deleteOption) WithPartition(partitionName string) *deleteOption {
	opt.partitionName = partitionName
	return opt
}

func NewDeleteOption(collectionName string) *deleteOption {
	return &deleteOption{collectionName: collectionName}
}



---
File: /milvusclient/write_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"fmt"
	"math/rand"
	"testing"

	"github.com/samber/lo"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus-proto/go-api/v2/schemapb"
	"github.com/milvus-io/milvus/client/v2/entity"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type WriteSuite struct {
	MockSuiteBase

	schema    *entity.Schema
	schemaDyn *entity.Schema
}

func (s *WriteSuite) SetupSuite() {
	s.MockSuiteBase.SetupSuite()
	s.schema = entity.NewSchema().
		WithField(entity.NewField().WithName("id").WithDataType(entity.FieldTypeInt64).WithIsPrimaryKey(true)).
		WithField(entity.NewField().WithName("vector").WithDataType(entity.FieldTypeFloatVector).WithDim(128)).
		WithField(entity.NewField().WithName("fp16_vector").WithDataType(entity.FieldTypeFloat16Vector).WithDim(128)).
		WithField(entity.NewField().WithName("bf16_vector").WithDataType(entity.FieldTypeBFloat16Vector).WithDim(128))

	s.schemaDyn = entity.NewSchema().WithDynamicFieldEnabled(true).
		WithField(entity.NewField().WithName("id").WithDataType(entity.FieldTypeInt64).WithIsPrimaryKey(true)).
		WithField(entity.NewField().WithName("vector").WithDataType(entity.FieldTypeFloatVector).WithDim(128)).
		WithField(entity.NewField().WithName("fp16_vector").WithDataType(entity.FieldTypeFloat16Vector).WithDim(128)).
		WithField(entity.NewField().WithName("bf16_vector").WithDataType(entity.FieldTypeBFloat16Vector).WithDim(128))
}

func (s *WriteSuite) TestInsert() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collName := fmt.Sprintf("coll_%s", s.randString(6))
		partName := fmt.Sprintf("part_%s", s.randString(6))
		s.setupCache(collName, s.schema)

		s.mock.EXPECT().Insert(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, ir *milvuspb.InsertRequest) (*milvuspb.MutationResult, error) {
			s.Equal(collName, ir.GetCollectionName())
			s.Equal(partName, ir.GetPartitionName())
			s.Require().Len(ir.GetFieldsData(), 4)
			s.EqualValues(3, ir.GetNumRows())
			return &milvuspb.MutationResult{
				Status:    merr.Success(),
				InsertCnt: 3,
				IDs: &schemapb.IDs{
					IdField: &schemapb.IDs_IntId{
						IntId: &schemapb.LongArray{
							Data: []int64{1, 2, 3},
						},
					},
				},
			}, nil
		}).Once()

		result, err := s.client.Insert(ctx, NewColumnBasedInsertOption(collName).
			WithFloatVectorColumn("vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithFloat16VectorColumn("fp16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithBFloat16VectorColumn("bf16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithInt64Column("id", []int64{1, 2, 3}).WithPartition(partName))
		s.NoError(err)
		s.EqualValues(3, result.InsertCount)
	})

	s.Run("dynamic_schema", func() {
		collName := fmt.Sprintf("coll_%s", s.randString(6))
		partName := fmt.Sprintf("part_%s", s.randString(6))
		s.setupCache(collName, s.schemaDyn)

		s.mock.EXPECT().Insert(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, ir *milvuspb.InsertRequest) (*milvuspb.MutationResult, error) {
			s.Equal(collName, ir.GetCollectionName())
			s.Equal(partName, ir.GetPartitionName())
			s.Require().Len(ir.GetFieldsData(), 5)
			s.EqualValues(3, ir.GetNumRows())
			return &milvuspb.MutationResult{
				Status:    merr.Success(),
				InsertCnt: 3,
				IDs: &schemapb.IDs{
					IdField: &schemapb.IDs_IntId{
						IntId: &schemapb.LongArray{
							Data: []int64{1, 2, 3},
						},
					},
				},
			}, nil
		}).Once()

		result, err := s.client.Insert(ctx, NewColumnBasedInsertOption(collName).
			WithFloatVectorColumn("vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithFloat16VectorColumn("fp16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithBFloat16VectorColumn("bf16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithVarcharColumn("extra", []string{"a", "b", "c"}).
			WithInt64Column("id", []int64{1, 2, 3}).WithPartition(partName))
		s.NoError(err)
		s.EqualValues(3, result.InsertCount)
	})

	s.Run("bad_input", func() {
		collName := fmt.Sprintf("coll_%s", s.randString(6))
		s.setupCache(collName, s.schema)

		type badCase struct {
			tag   string
			input InsertOption
		}

		cases := []badCase{
			{
				tag: "row_count_not_match",
				input: NewColumnBasedInsertOption(collName).WithInt64Column("id", []int64{1}).
					WithFloatVectorColumn("vector", 128, lo.RepeatBy(3, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})),
			},
			{
				tag: "duplicated_columns",
				input: NewColumnBasedInsertOption(collName).
					WithInt64Column("id", []int64{1}).
					WithInt64Column("id", []int64{2}).
					WithFloatVectorColumn("vector", 128, lo.RepeatBy(1, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})).
					WithFloat16VectorColumn("fp16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})).
					WithBFloat16VectorColumn("bf16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})),
			},
			{
				tag: "different_data_type",
				input: NewColumnBasedInsertOption(collName).
					WithVarcharColumn("id", []string{"1"}).
					WithFloatVectorColumn("vector", 128, lo.RepeatBy(1, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})).
					WithFloat16VectorColumn("fp16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})).
					WithBFloat16VectorColumn("bf16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})),
			},
		}

		for _, tc := range cases {
			s.Run(tc.tag, func() {
				_, err := s.client.Insert(ctx, tc.input)
				s.Error(err)
			})
		}
	})

	s.Run("failure", func() {
		collName := fmt.Sprintf("coll_%s", s.randString(6))
		s.setupCache(collName, s.schema)

		s.mock.EXPECT().Insert(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.Insert(ctx, NewColumnBasedInsertOption(collName).
			WithFloatVectorColumn("vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithFloat16VectorColumn("fp16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithBFloat16VectorColumn("bf16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithInt64Column("id", []int64{1, 2, 3}))
		s.Error(err)
	})
}

func (s *WriteSuite) TestUpsert() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collName := fmt.Sprintf("coll_%s", s.randString(6))
		partName := fmt.Sprintf("part_%s", s.randString(6))
		s.setupCache(collName, s.schema)

		s.mock.EXPECT().Upsert(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, ur *milvuspb.UpsertRequest) (*milvuspb.MutationResult, error) {
			s.Equal(collName, ur.GetCollectionName())
			s.Equal(partName, ur.GetPartitionName())
			s.Require().Len(ur.GetFieldsData(), 4)
			s.EqualValues(3, ur.GetNumRows())
			return &milvuspb.MutationResult{
				Status:    merr.Success(),
				UpsertCnt: 3,
				IDs: &schemapb.IDs{
					IdField: &schemapb.IDs_IntId{
						IntId: &schemapb.LongArray{
							Data: []int64{1, 2, 3},
						},
					},
				},
			}, nil
		}).Once()

		result, err := s.client.Upsert(ctx, NewColumnBasedInsertOption(collName).
			WithFloatVectorColumn("vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithFloat16VectorColumn("fp16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithBFloat16VectorColumn("bf16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithInt64Column("id", []int64{1, 2, 3}).WithPartition(partName))
		s.NoError(err)
		s.EqualValues(3, result.UpsertCount)
	})

	s.Run("dynamic_schema", func() {
		collName := fmt.Sprintf("coll_%s", s.randString(6))
		partName := fmt.Sprintf("part_%s", s.randString(6))
		s.setupCache(collName, s.schemaDyn)

		s.mock.EXPECT().Upsert(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, ur *milvuspb.UpsertRequest) (*milvuspb.MutationResult, error) {
			s.Equal(collName, ur.GetCollectionName())
			s.Equal(partName, ur.GetPartitionName())
			s.Require().Len(ur.GetFieldsData(), 5)
			s.EqualValues(3, ur.GetNumRows())
			return &milvuspb.MutationResult{
				Status:    merr.Success(),
				UpsertCnt: 3,
				IDs: &schemapb.IDs{
					IdField: &schemapb.IDs_IntId{
						IntId: &schemapb.LongArray{
							Data: []int64{1, 2, 3},
						},
					},
				},
			}, nil
		}).Once()

		result, err := s.client.Upsert(ctx, NewColumnBasedInsertOption(collName).
			WithFloatVectorColumn("vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithFloat16VectorColumn("fp16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithBFloat16VectorColumn("bf16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithVarcharColumn("extra", []string{"a", "b", "c"}).
			WithInt64Column("id", []int64{1, 2, 3}).WithPartition(partName))
		s.NoError(err)
		s.EqualValues(3, result.UpsertCount)
	})

	s.Run("bad_input", func() {
		collName := fmt.Sprintf("coll_%s", s.randString(6))
		s.setupCache(collName, s.schema)

		type badCase struct {
			tag   string
			input UpsertOption
		}

		cases := []badCase{
			{
				tag: "row_count_not_match",
				input: NewColumnBasedInsertOption(collName).WithInt64Column("id", []int64{1}).
					WithFloatVectorColumn("vector", 128, lo.RepeatBy(3, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})).
					WithFloat16VectorColumn("fp16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})).
					WithBFloat16VectorColumn("bf16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})),
			},
			{
				tag: "duplicated_columns",
				input: NewColumnBasedInsertOption(collName).
					WithInt64Column("id", []int64{1}).
					WithInt64Column("id", []int64{2}).
					WithFloatVectorColumn("vector", 128, lo.RepeatBy(1, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})).
					WithFloat16VectorColumn("fp16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})).
					WithBFloat16VectorColumn("bf16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})),
			},
			{
				tag: "different_data_type",
				input: NewColumnBasedInsertOption(collName).
					WithVarcharColumn("id", []string{"1"}).
					WithFloatVectorColumn("vector", 128, lo.RepeatBy(1, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})).
					WithFloat16VectorColumn("fp16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})).
					WithBFloat16VectorColumn("bf16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
						return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
					})),
			},
		}

		for _, tc := range cases {
			s.Run(tc.tag, func() {
				_, err := s.client.Upsert(ctx, tc.input)
				s.Error(err)
			})
		}
	})

	s.Run("failure", func() {
		collName := fmt.Sprintf("coll_%s", s.randString(6))
		s.setupCache(collName, s.schema)

		s.mock.EXPECT().Upsert(mock.Anything, mock.Anything).Return(nil, merr.WrapErrServiceInternal("mocked")).Once()

		_, err := s.client.Upsert(ctx, NewColumnBasedInsertOption(collName).
			WithFloatVectorColumn("vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithFloat16VectorColumn("fp16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithBFloat16VectorColumn("bf16_vector", 128, lo.RepeatBy(3, func(i int) []float32 {
				return lo.RepeatBy(128, func(i int) float32 { return rand.Float32() })
			})).
			WithInt64Column("id", []int64{1, 2, 3}))
		s.Error(err)
	})
}

func (s *WriteSuite) TestDelete() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	s.Run("success", func() {
		collName := fmt.Sprintf("coll_%s", s.randString(6))
		partName := fmt.Sprintf("part_%s", s.randString(6))

		type testCase struct {
			tag        string
			input      DeleteOption
			expectExpr string
		}

		cases := []testCase{
			{
				tag:        "raw_expr",
				input:      NewDeleteOption(collName).WithPartition(partName).WithExpr("id > 100"),
				expectExpr: "id > 100",
			},
			{
				tag:        "int_ids",
				input:      NewDeleteOption(collName).WithPartition(partName).WithInt64IDs("id", []int64{1, 2, 3}),
				expectExpr: "id in [1,2,3]",
			},
			{
				tag:        "str_ids",
				input:      NewDeleteOption(collName).WithPartition(partName).WithStringIDs("id", []string{"a", "b", "c"}),
				expectExpr: `id in ["a","b","c"]`,
			},
		}

		for _, tc := range cases {
			s.Run(tc.tag, func() {
				s.mock.EXPECT().Delete(mock.Anything, mock.Anything).RunAndReturn(func(ctx context.Context, dr *milvuspb.DeleteRequest) (*milvuspb.MutationResult, error) {
					s.Equal(collName, dr.GetCollectionName())
					s.Equal(partName, dr.GetPartitionName())
					s.Equal(tc.expectExpr, dr.GetExpr())
					return &milvuspb.MutationResult{
						Status:    merr.Success(),
						DeleteCnt: 100,
					}, nil
				}).Once()
				result, err := s.client.Delete(ctx, tc.input)
				s.NoError(err)
				s.EqualValues(100, result.DeleteCount)
			})
		}
	})
}

func TestWrite(t *testing.T) {
	suite.Run(t, new(WriteSuite))
}



---
File: /milvusclient/write.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package milvusclient

import (
	"context"
	"math"

	"google.golang.org/grpc"

	"github.com/milvus-io/milvus-proto/go-api/v2/milvuspb"
	"github.com/milvus-io/milvus/client/v2/column"
	"github.com/milvus-io/milvus/pkg/v2/util/merr"
)

type InsertResult struct {
	InsertCount int64
	IDs         column.Column
}

func (c *Client) Insert(ctx context.Context, option InsertOption, callOptions ...grpc.CallOption) (InsertResult, error) {
	result := InsertResult{}
	err := c.retryIfSchemaError(ctx, option.CollectionName(), func(ctx context.Context) (uint64, error) {
		collection, err := c.getCollection(ctx, option.CollectionName())
		if err != nil {
			return math.MaxUint64, err
		}
		req, err := option.InsertRequest(collection)
		if err != nil {
			return collection.UpdateTimestamp, err
		}

		return collection.UpdateTimestamp, c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
			resp, err := milvusService.Insert(ctx, req, callOptions...)

			err = merr.CheckRPCCall(resp, err)
			if err != nil {
				return err
			}

			result.InsertCount = resp.GetInsertCnt()
			result.IDs, err = column.IDColumns(collection.Schema, resp.GetIDs(), 0, -1)
			if err != nil {
				return err
			}

			// write back pks if needed
			// pks values shall be written back to struct if receiver field exists
			return option.WriteBackPKs(collection.Schema, result.IDs)
		})
	})
	return result, err
}

type DeleteResult struct {
	DeleteCount int64
}

func (c *Client) Delete(ctx context.Context, option DeleteOption, callOptions ...grpc.CallOption) (DeleteResult, error) {
	req := option.Request()

	result := DeleteResult{}
	err := c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
		resp, err := milvusService.Delete(ctx, req, callOptions...)
		if err = merr.CheckRPCCall(resp, err); err != nil {
			return err
		}
		result.DeleteCount = resp.GetDeleteCnt()
		return nil
	})
	return result, err
}

type UpsertResult struct {
	UpsertCount int64
	IDs         column.Column
}

func (c *Client) Upsert(ctx context.Context, option UpsertOption, callOptions ...grpc.CallOption) (UpsertResult, error) {
	result := UpsertResult{}
	err := c.retryIfSchemaError(ctx, option.CollectionName(), func(ctx context.Context) (uint64, error) {
		collection, err := c.getCollection(ctx, option.CollectionName())
		if err != nil {
			return math.MaxUint64, err
		}
		req, err := option.UpsertRequest(collection)
		if err != nil {
			return collection.UpdateTimestamp, err
		}
		return collection.UpdateTimestamp, c.callService(func(milvusService milvuspb.MilvusServiceClient) error {
			resp, err := milvusService.Upsert(ctx, req, callOptions...)
			if err = merr.CheckRPCCall(resp, err); err != nil {
				return err
			}
			result.UpsertCount = resp.GetUpsertCnt()
			result.IDs, err = column.IDColumns(collection.Schema, resp.GetIDs(), 0, -1)
			if err != nil {
				return err
			}
			return nil
		})
	})
	return result, err
}



---
File: /row/data_test.go
---

package row

import (
	"fmt"
	"reflect"
	"testing"

	"github.com/stretchr/testify/suite"

	"github.com/milvus-io/milvus/client/v2/entity"
)

type ValidStruct struct {
	ID      int64 `milvus:"primary_key"`
	Attr1   int8
	Attr2   int16
	Attr3   int32
	Attr4   float32
	Attr5   float64
	Attr6   string
	Attr7   bool
	Vector  []float32 `milvus:"dim:16"`
	Vector2 []byte    `milvus:"dim:32"`
}

type ValidStruct2 struct {
	ID      int64 `milvus:"primary_key"`
	Vector  [16]float32
	Attr1   float64
	Ignored bool `milvus:"-"`
}

type ValidStructWithNamedTag struct {
	ID     int64       `milvus:"primary_key;name:id"`
	Vector [16]float32 `milvus:"name:vector"`
}

type RowsSuite struct {
	suite.Suite
}

func (s *RowsSuite) TestRowsToColumns() {
	s.Run("valid_cases", func() {
		columns, err := AnyToColumns([]any{&ValidStruct{}})
		s.Nil(err)
		s.Equal(10, len(columns))

		columns, err = AnyToColumns([]any{&ValidStruct2{}})
		s.Nil(err)
		s.Equal(3, len(columns))
	})

	s.Run("auto_id_pk", func() {
		type AutoPK struct {
			ID     int64     `milvus:"primary_key;auto_id"`
			Vector []float32 `milvus:"dim:32"`
		}
		columns, err := AnyToColumns([]any{&AutoPK{}})
		s.Nil(err)
		s.Require().Equal(1, len(columns))
		s.Equal("Vector", columns[0].Name())
	})

	s.Run("fp16", func() {
		type BF16Struct struct {
			ID     int64  `milvus:"primary_key;auto_id"`
			Vector []byte `milvus:"dim:16;vector_type:bf16"`
		}
		columns, err := AnyToColumns([]any{&BF16Struct{}})
		s.Nil(err)
		s.Require().Equal(1, len(columns))
		s.Equal("Vector", columns[0].Name())
		s.Equal(entity.FieldTypeBFloat16Vector, columns[0].Type())
	})

	s.Run("fp16", func() {
		type FP16Struct struct {
			ID     int64  `milvus:"primary_key;auto_id"`
			Vector []byte `milvus:"dim:16;vector_type:fp16"`
		}
		columns, err := AnyToColumns([]any{&FP16Struct{}})
		s.Nil(err)
		s.Require().Equal(1, len(columns))
		s.Equal("Vector", columns[0].Name())
		s.Equal(entity.FieldTypeFloat16Vector, columns[0].Type())
	})

	s.Run("invalid_cases", func() {
		// empty input
		_, err := AnyToColumns([]any{})
		s.NotNil(err)

		// incompatible rows
		_, err = AnyToColumns([]any{&ValidStruct{}, &ValidStruct2{}})
		s.NotNil(err)

		// schema & row not compatible
		_, err = AnyToColumns([]any{&ValidStruct{}}, &entity.Schema{
			Fields: []*entity.Field{
				{
					Name:     "Attr1",
					DataType: entity.FieldTypeInt64,
				},
			},
		})
		s.NotNil(err)
	})
}

func (s *RowsSuite) TestDynamicSchema() {
	s.Run("all_fallback_dynamic", func() {
		columns, err := AnyToColumns([]any{&ValidStruct{}},
			entity.NewSchema().WithDynamicFieldEnabled(true),
		)
		s.NoError(err)
		s.Equal(1, len(columns))
	})

	s.Run("dynamic_not_found", func() {
		_, err := AnyToColumns([]any{&ValidStruct{}},
			entity.NewSchema().WithField(
				entity.NewField().WithName("ID").WithDataType(entity.FieldTypeInt64).WithIsPrimaryKey(true),
			).WithDynamicFieldEnabled(true),
		)
		s.NoError(err)
	})
}

func (s *RowsSuite) TestReflectValueCandi() {
	type DynamicRows struct {
		Float float32 `json:"float" milvus:"name:float"`
	}

	cases := []struct {
		tag       string
		v         reflect.Value
		expect    map[string]fieldCandi
		expectErr bool
	}{
		{
			tag: "MapRow",
			v: reflect.ValueOf(map[string]interface{}{
				"A": "abd", "B": int64(8),
			}),
			expect: map[string]fieldCandi{
				"A": {
					name: "A",
					v:    reflect.ValueOf("abd"),
				},
				"B": {
					name: "B",
					v:    reflect.ValueOf(int64(8)),
				},
			},
			expectErr: false,
		},
		{
			tag: "StructRow",
			v: reflect.ValueOf(struct {
				A string
				B int64
			}{A: "abc", B: 16}),
			expect: map[string]fieldCandi{
				"A": {
					name: "A",
					v:    reflect.ValueOf("abc"),
				},
				"B": {
					name: "B",
					v:    reflect.ValueOf(int64(16)),
				},
			},
			expectErr: false,
		},
		{
			tag: "StructRow_DuplicateName",
			v: reflect.ValueOf(struct {
				A string `milvus:"name:a"`
				B int64  `milvus:"name:a"`
			}{A: "abc", B: 16}),
			expectErr: true,
		},
		{
			tag: "StructRow_EmbedStruct",
			v: reflect.ValueOf(struct {
				A string `milvus:"name:a"`
				DynamicRows
			}{A: "emb", DynamicRows: DynamicRows{Float: 0.1}}),
			expect: map[string]fieldCandi{
				"a": {
					name: "a",
					v:    reflect.ValueOf("emb"),
				},
				"float": {
					name: "float",
					v:    reflect.ValueOf(float32(0.1)),
				},
			},
			expectErr: false,
		},
		{
			tag: "StructRow_EmbedDuplicateName",
			v: reflect.ValueOf(struct {
				Int64    int64     `json:"int64" milvus:"name:int64"`
				Float    float32   `json:"float" milvus:"name:float"`
				FloatVec []float32 `json:"floatVec" milvus:"name:floatVec"`
				DynamicRows
			}{}),
			expectErr: true,
		},
		{
			tag:       "Unsupported_primitive",
			v:         reflect.ValueOf(int64(1)),
			expectErr: true,
		},
	}

	for _, c := range cases {
		s.Run(c.tag, func() {
			r, err := reflectValueCandi(c.v)
			if c.expectErr {
				s.Error(err)
				return
			}
			s.NoError(err)
			s.Equal(len(c.expect), len(r))
			for k, v := range c.expect {
				rv, has := r[k]
				s.Require().True(has, fmt.Sprintf("candidate with key(%s) must provided", k))
				s.Equal(v.name, rv.name)
			}
		})
	}
}

func TestRows(t *testing.T) {
	suite.Run(t, new(RowsSuite))
}



---
File: /row/data.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package row

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strconv"

	"github.com/cockroachdb/errors"
	"github.com/samber/lo"

	"github.com/milvus-io/milvus/client/v2/column"
	"github.com/milvus-io/milvus/client/v2/entity"
)

const (
	// MilvusTag struct tag const for milvus row based struct
	MilvusTag = `milvus`

	// MilvusSkipTagValue struct tag const for skip this field.
	MilvusSkipTagValue = `-`

	// MilvusTagSep struct tag const for attribute separator
	MilvusTagSep = `;`

	// MilvusTagName struct tag const for field name
	MilvusTagName = `NAME`

	// VectorDimTag struct tag const for vector dimension
	VectorDimTag = `DIM`

	// VectorTypeTag struct tag const for binary vector type
	VectorTypeTag = `VECTOR_TYPE`

	// MilvusPrimaryKey struct tag const for primary key indicator
	MilvusPrimaryKey = `PRIMARY_KEY`

	// MilvusAutoID struct tag const for auto id indicator
	MilvusAutoID = `AUTO_ID`

	// MilvusMaxLength struct tag const for max length
	MilvusMaxLength = `MAX_LENGTH`

	// DimMax dimension max value
	DimMax = 65535
)

// AnyToColumns converts input rows into column-based data.
// when schemas are provided, this method will use 0-th element
// otherwise, it shall try to parse schema from row[0]
func AnyToColumns(rows []interface{}, schemas ...*entity.Schema) ([]column.Column, error) {
	rowsLen := len(rows)
	if rowsLen == 0 {
		return []column.Column{}, errors.New("0 length column")
	}

	var sch *entity.Schema
	var err error
	// if schema not provided, try to parse from row
	if len(schemas) == 0 {
		//nolint rows number checked before
		sch, err = ParseSchema(rows[0])
		if err != nil {
			return []column.Column{}, err
		}
	} else {
		// use first schema provided
		sch = schemas[0]
	}

	isDynamic := sch.EnableDynamicField
	var dynamicCol *column.ColumnJSONBytes

	nameColumns := make(map[string]column.Column)
	nameSchemas := lo.SliceToMap(sch.Fields, func(fieldSchema *entity.Field) (string, entity.Field) {
		return fieldSchema.Name, *fieldSchema
	})
	columnCreators := getColumnCreators(sch)

	if isDynamic {
		dynamicCol = column.NewColumnJSONBytes("", make([][]byte, 0, rowsLen)).WithIsDynamic(true)
	}

	// getColumn is a closure to wrap fetch column related to field name
	getColumn := func(fieldName string) (column.Column, error) {
		// existing one
		column, ok := nameColumns[fieldName]
		if ok {
			return column, nil
		}

		fn, ok := columnCreators[fieldName]
		if ok {
			return fn(rowsLen)
		}

		return nil, errors.New("column not found")
	}

	for _, row := range rows {
		// collection schema name need not to be same, since receiver could has other names
		v := reflect.ValueOf(row)
		set, err := reflectValueCandi(v)
		if err != nil {
			return nil, err
		}

		for fieldName, candi := range set {
			fieldSch, ok := nameSchemas[fieldName]
			if ok && fieldSch.PrimaryKey && fieldSch.AutoID {
				// remove pk field from candidates set, avoid adding it into dynamic column
				delete(set, fieldName)
				continue
			}

			column, err := getColumn(fieldName)
			if err != nil {
				// ignore candidate not exist in schema for now
				// if dynamic schema enabled, left candidates will be processed
				// TODO @congqixia, add strict mode if needed
				continue
			}
			nameColumns[fieldName] = column

			err = column.AppendValue(candi.v.Interface())
			if err != nil {
				return nil, err
			}
			delete(set, fieldName)
		}

		if isDynamic {
			m := make(map[string]interface{})
			for name, candi := range set {
				m[name] = candi.v.Interface()
			}
			bs, err := json.Marshal(m)
			if err != nil {
				return nil, fmt.Errorf("failed to marshal dynamic field %w", err)
			}
			err = dynamicCol.AppendValue(bs)
			if err != nil {
				return nil, fmt.Errorf("failed to append value to dynamic field %w", err)
			}
		}
	}
	columns := make([]column.Column, 0, len(nameColumns))
	for _, column := range nameColumns {
		columns = append(columns, column)
	}
	if isDynamic {
		columns = append(columns, dynamicCol)
	}
	return columns, nil
}

type columnCreator func(int) (column.Column, error)

func getColumnCreators(sch *entity.Schema) map[string]columnCreator {
	result := make(map[string]columnCreator)
	for _, field := range sch.Fields {
		// skip auto id pk field
		// if field.PrimaryKey && field.AutoID {
		// continue
		// }
		field := field
		result[field.Name] = func(rowsLen int) (column.Column, error) {
			var col column.Column
			switch field.DataType {
			case entity.FieldTypeBool:
				data := make([]bool, 0, rowsLen)
				col = column.NewColumnBool(field.Name, data)
			case entity.FieldTypeInt8:
				data := make([]int8, 0, rowsLen)
				col = column.NewColumnInt8(field.Name, data)
			case entity.FieldTypeInt16:
				data := make([]int16, 0, rowsLen)
				col = column.NewColumnInt16(field.Name, data)
			case entity.FieldTypeInt32:
				data := make([]int32, 0, rowsLen)
				col = column.NewColumnInt32(field.Name, data)
			case entity.FieldTypeInt64:
				data := make([]int64, 0, rowsLen)
				col = column.NewColumnInt64(field.Name, data)
			case entity.FieldTypeFloat:
				data := make([]float32, 0, rowsLen)
				col = column.NewColumnFloat(field.Name, data)
			case entity.FieldTypeDouble:
				data := make([]float64, 0, rowsLen)
				col = column.NewColumnDouble(field.Name, data)
			case entity.FieldTypeString, entity.FieldTypeVarChar:
				data := make([]string, 0, rowsLen)
				col = column.NewColumnVarChar(field.Name, data)
			case entity.FieldTypeJSON:
				data := make([][]byte, 0, rowsLen)
				col = column.NewColumnJSONBytes(field.Name, data)
			case entity.FieldTypeArray:
				col = NewArrayColumn(field)
				if col == nil {
					return nil, errors.Newf("unsupported element type %s for Array", field.ElementType.String())
				}
			case entity.FieldTypeFloatVector:
				data := make([][]float32, 0, rowsLen)
				dimStr, has := field.TypeParams[entity.TypeParamDim]
				if !has {
					return nil, errors.New("vector field with no dim")
				}
				dim, err := strconv.ParseInt(dimStr, 10, 64)
				if err != nil {
					return nil, fmt.Errorf("vector field with bad format dim: %s", err.Error())
				}
				col = column.NewColumnFloatVector(field.Name, int(dim), data)
			case entity.FieldTypeBinaryVector:
				data := make([][]byte, 0, rowsLen)
				dim, err := field.GetDim()
				if err != nil {
					return nil, err
				}
				col = column.NewColumnBinaryVector(field.Name, int(dim), data)
			case entity.FieldTypeFloat16Vector:
				data := make([][]byte, 0, rowsLen)
				dim, err := field.GetDim()
				if err != nil {
					return nil, err
				}
				col = column.NewColumnFloat16Vector(field.Name, int(dim), data)
			case entity.FieldTypeBFloat16Vector:
				data := make([][]byte, 0, rowsLen)
				dim, err := field.GetDim()
				if err != nil {
					return nil, err
				}
				col = column.NewColumnBFloat16Vector(field.Name, int(dim), data)
			case entity.FieldTypeSparseVector:
				data := make([]entity.SparseEmbedding, 0, rowsLen)
				col = column.NewColumnSparseVectors(field.Name, data)
			}

			if field.Nullable {
				col.SetNullable(true)
			}
			return col, nil
		}
	}
	return result
}

func NewArrayColumn(f *entity.Field) column.Column {
	switch f.ElementType {
	case entity.FieldTypeBool:
		return column.NewColumnBoolArray(f.Name, nil)

	case entity.FieldTypeInt8:
		return column.NewColumnInt8Array(f.Name, nil)

	case entity.FieldTypeInt16:
		return column.NewColumnInt16Array(f.Name, nil)

	case entity.FieldTypeInt32:
		return column.NewColumnInt32Array(f.Name, nil)

	case entity.FieldTypeInt64:
		return column.NewColumnInt64Array(f.Name, nil)

	case entity.FieldTypeFloat:
		return column.NewColumnFloatArray(f.Name, nil)

	case entity.FieldTypeDouble:
		return column.NewColumnDoubleArray(f.Name, nil)

	case entity.FieldTypeVarChar:
		return column.NewColumnVarCharArray(f.Name, nil)

	default:
		return nil
	}
}

func SetField(receiver any, fieldName string, value any) error {
	candidates, err := reflectValueCandi(reflect.ValueOf(receiver))
	if err != nil {
		return err
	}

	candidate, ok := candidates[fieldName]
	// if field not found, just return
	if !ok {
		return nil
	}

	if candidate.v.CanSet() {
		candidate.v.Set(reflect.ValueOf(value))
	}

	return nil
}

type fieldCandi struct {
	name    string
	v       reflect.Value
	options map[string]string
}

func reflectValueCandi(v reflect.Value) (map[string]fieldCandi, error) {
	// unref **/***/... struct{}
	for v.Kind() == reflect.Ptr {
		v = v.Elem()
	}

	switch v.Kind() {
	case reflect.Map: // map[string]any
		return getMapReflectCandidates(v), nil
	case reflect.Struct:
		return getStructReflectCandidates(v)
	default:
		return nil, fmt.Errorf("unsupport row type: %s", v.Kind().String())
	}
}

// getMapReflectCandidates converts input map into fieldCandidate struct.
// if value is struct/map etc, it will be treated as json data type directly(if schema say so).
func getMapReflectCandidates(v reflect.Value) map[string]fieldCandi {
	result := make(map[string]fieldCandi)
	iter := v.MapRange()
	for iter.Next() {
		key := iter.Key().String()
		result[key] = fieldCandi{
			name: key,
			v:    iter.Value(),
		}
	}
	return result
}

// getStructReflectCandidates parses struct fields into fieldCandidates.
// embedded struct will be flatten as field as well.
func getStructReflectCandidates(v reflect.Value) (map[string]fieldCandi, error) {
	result := make(map[string]fieldCandi)
	for i := 0; i < v.NumField(); i++ {
		ft := v.Type().Field(i)
		name := ft.Name

		// embedded struct, flatten all fields
		if ft.Anonymous && ft.Type.Kind() == reflect.Struct {
			embedCandidate, err := reflectValueCandi(v.Field(i))
			if err != nil {
				return nil, err
			}
			for key, candi := range embedCandidate {
				// check duplicated field name in different structs
				_, ok := result[key]
				if ok {
					return nil, fmt.Errorf("column has duplicated name: %s when parsing field: %s", key, ft.Name)
				}
				result[key] = candi
			}
			continue
		}

		tag, ok := ft.Tag.Lookup(MilvusTag)
		settings := make(map[string]string)
		if ok {
			if tag == MilvusSkipTagValue {
				continue
			}
			settings = ParseTagSetting(tag, MilvusTagSep)
			fn, has := settings[MilvusTagName]
			if has {
				// overwrite column to tag name
				name = fn
			}
		}
		_, ok = result[name]
		// duplicated
		if ok {
			return nil, fmt.Errorf("column has duplicated name: %s when parsing field: %s", name, ft.Name)
		}

		v := v.Field(i)
		if v.Kind() == reflect.Array {
			v = v.Slice(0, v.Len())
		}

		result[name] = fieldCandi{
			name:    name,
			v:       v,
			options: settings,
		}
	}

	return result, nil
}



---
File: /row/schema_test.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package row

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/milvus-io/milvus/client/v2/entity"
)

// ArrayRow test case type
type ArrayRow [16]float32

func (ar *ArrayRow) Collection() string  { return "" }
func (ar *ArrayRow) Partition() string   { return "" }
func (ar *ArrayRow) Description() string { return "" }

type Uint8Struct struct {
	Attr uint8
}

type StringArrayStruct struct {
	Vector [8]string
}

type StringSliceStruct struct {
	Vector []string `milvus:"dim:8"`
}

type SliceNoDimStruct struct {
	Vector []float32 `milvus:""`
}

type SliceBadDimStruct struct {
	Vector []float32 `milvus:"dim:str"`
}

type SliceBadDimStruct2 struct {
	Vector []float32 `milvus:"dim:0"`
}

func TestParseSchema(t *testing.T) {
	t.Run("invalid cases", func(t *testing.T) {
		// anonymous struct with default collection name ("") will cause error
		anonymusStruct := struct{}{}
		sch, err := ParseSchema(anonymusStruct)
		assert.Nil(t, sch)
		assert.NotNil(t, err)

		// non struct
		arrayRow := ArrayRow([16]float32{})
		sch, err = ParseSchema(&arrayRow)
		assert.Nil(t, sch)
		assert.NotNil(t, err)

		// uint8 not supported
		sch, err = ParseSchema(&Uint8Struct{})
		assert.Nil(t, sch)
		assert.NotNil(t, err)

		// string array not supported
		sch, err = ParseSchema(&StringArrayStruct{})
		assert.Nil(t, sch)
		assert.NotNil(t, err)

		// string slice not supported
		sch, err = ParseSchema(&StringSliceStruct{})
		assert.Nil(t, sch)
		assert.NotNil(t, err)

		// slice vector with no dim
		sch, err = ParseSchema(&SliceNoDimStruct{})
		assert.Nil(t, sch)
		assert.NotNil(t, err)

		// slice vector with bad format dim
		sch, err = ParseSchema(&SliceBadDimStruct{})
		assert.Nil(t, sch)
		assert.NotNil(t, err)

		// slice vector with bad format dim 2
		sch, err = ParseSchema(&SliceBadDimStruct2{})
		assert.Nil(t, sch)
		assert.NotNil(t, err)
	})

	t.Run("valid cases", func(t *testing.T) {
		getVectorField := func(schema *entity.Schema) *entity.Field {
			for _, field := range schema.Fields {
				if field.DataType == entity.FieldTypeFloatVector ||
					field.DataType == entity.FieldTypeBinaryVector ||
					field.DataType == entity.FieldTypeBFloat16Vector ||
					field.DataType == entity.FieldTypeFloat16Vector {
					return field
				}
			}
			return nil
		}

		type ValidStruct struct {
			ID     int64 `milvus:"primary_key"`
			Attr1  int8
			Attr2  int16
			Attr3  int32
			Attr4  float32
			Attr5  float64
			Attr6  string
			Vector []float32 `milvus:"dim:128"`
		}
		vs := &ValidStruct{}
		sch, err := ParseSchema(vs)
		assert.Nil(t, err)
		assert.NotNil(t, sch)
		assert.Equal(t, "ValidStruct", sch.CollectionName)

		type ValidFp16Struct struct {
			ID     int64 `milvus:"primary_key"`
			Attr1  int8
			Attr2  int16
			Attr3  int32
			Attr4  float32
			Attr5  float64
			Attr6  string
			Vector []byte `milvus:"dim:128;vector_type:fp16"`
		}
		fp16Vs := &ValidFp16Struct{}
		sch, err = ParseSchema(fp16Vs)
		assert.Nil(t, err)
		assert.NotNil(t, sch)
		assert.Equal(t, "ValidFp16Struct", sch.CollectionName)
		vectorField := getVectorField(sch)
		assert.Equal(t, entity.FieldTypeFloat16Vector, vectorField.DataType)

		type ValidBf16Struct struct {
			ID     int64 `milvus:"primary_key"`
			Attr1  int8
			Attr2  int16
			Attr3  int32
			Attr4  float32
			Attr5  float64
			Attr6  string
			Vector []byte `milvus:"dim:128;vector_type:bf16"`
		}
		bf16Vs := &ValidBf16Struct{}
		sch, err = ParseSchema(bf16Vs)
		assert.Nil(t, err)
		assert.NotNil(t, sch)
		assert.Equal(t, "ValidBf16Struct", sch.CollectionName)
		vectorField = getVectorField(sch)
		assert.Equal(t, entity.FieldTypeBFloat16Vector, vectorField.DataType)

		type ValidByteStruct struct {
			ID     int64  `milvus:"primary_key"`
			Vector []byte `milvus:"dim:128"`
		}
		vs2 := &ValidByteStruct{}
		sch, err = ParseSchema(vs2)
		assert.Nil(t, err)
		assert.NotNil(t, sch)

		type ValidArrayStruct struct {
			ID     int64 `milvus:"primary_key"`
			Vector [64]float32
		}
		vs3 := &ValidArrayStruct{}
		sch, err = ParseSchema(vs3)
		assert.Nil(t, err)
		assert.NotNil(t, sch)

		type ValidArrayStructByte struct {
			ID     int64   `milvus:"primary_key;auto_id"`
			Data   *string `milvus:"extra:test\\;false"`
			Vector [64]byte
		}
		vs4 := &ValidArrayStructByte{}
		sch, err = ParseSchema(vs4)
		assert.Nil(t, err)
		assert.NotNil(t, sch)

		vs5 := &ValidStructWithNamedTag{}
		sch, err = ParseSchema(vs5)
		assert.Nil(t, err)
		assert.NotNil(t, sch)
		i64f, vecf := false, false
		for _, field := range sch.Fields {
			if field.Name == "id" {
				i64f = true
			}
			if field.Name == "vector" {
				vecf = true
			}
		}

		assert.True(t, i64f)
		assert.True(t, vecf)
	})
}



---
File: /row/schema.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package row

import (
	"fmt"
	"go/ast"
	"reflect"
	"strconv"
	"strings"

	"github.com/cockroachdb/errors"

	"github.com/milvus-io/milvus/client/v2/entity"
)

// ParseSchema parses schema from interface{}.
func ParseSchema(r interface{}) (*entity.Schema, error) {
	sch := &entity.Schema{}
	t := reflect.TypeOf(r)
	if t.Kind() == reflect.Array || t.Kind() == reflect.Slice || t.Kind() == reflect.Ptr {
		t = t.Elem()
	}

	// MapRow is not supported for schema definition
	// TODO add PrimaryKey() interface later
	if t.Kind() == reflect.Map {
		return nil, errors.New("map row is not supported for schema definition")
	}

	if t.Kind() != reflect.Struct {
		return nil, fmt.Errorf("unsupported data type: %+v", r)
	}

	// Collection method not overwrited, try use Row type name
	if sch.CollectionName == "" {
		sch.CollectionName = t.Name()
		if sch.CollectionName == "" {
			return nil, errors.New("collection name not provided")
		}
	}
	sch.Fields = make([]*entity.Field, 0, t.NumField())
	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)
		// ignore anonymous field for now
		if f.Anonymous || !ast.IsExported(f.Name) {
			continue
		}

		field := &entity.Field{
			Name: f.Name,
		}
		ft := f.Type
		if f.Type.Kind() == reflect.Ptr {
			ft = ft.Elem()
		}
		fv := reflect.New(ft)
		tag := f.Tag.Get(MilvusTag)
		if tag == MilvusSkipTagValue {
			continue
		}
		tagSettings := ParseTagSetting(tag, MilvusTagSep)
		if _, has := tagSettings[MilvusPrimaryKey]; has {
			field.PrimaryKey = true
		}
		if _, has := tagSettings[MilvusAutoID]; has {
			field.AutoID = true
		}
		if name, has := tagSettings[MilvusTagName]; has {
			field.Name = name
		}
		switch reflect.Indirect(fv).Kind() {
		case reflect.Bool:
			field.DataType = entity.FieldTypeBool
		case reflect.Int8:
			field.DataType = entity.FieldTypeInt8
		case reflect.Int16:
			field.DataType = entity.FieldTypeInt16
		case reflect.Int32:
			field.DataType = entity.FieldTypeInt32
		case reflect.Int64:
			field.DataType = entity.FieldTypeInt64
		case reflect.Float32:
			field.DataType = entity.FieldTypeFloat
		case reflect.Float64:
			field.DataType = entity.FieldTypeDouble
		case reflect.String:
			field.DataType = entity.FieldTypeVarChar
			if maxLengthVal, has := tagSettings[MilvusMaxLength]; has {
				maxLength, err := strconv.ParseInt(maxLengthVal, 10, 64)
				if err != nil {
					return nil, fmt.Errorf("max length value %s is not valued", maxLengthVal)
				}
				field.WithMaxLength(maxLength)
			}
		case reflect.Array:
			arrayLen := ft.Len()
			elemType := ft.Elem()
			switch elemType.Kind() {
			case reflect.Uint8:
				field.WithDataType(entity.FieldTypeBinaryVector)
				field.WithDim(int64(arrayLen) * 8)
			case reflect.Float32:
				field.WithDataType(entity.FieldTypeFloatVector)
				field.WithDim(int64(arrayLen))
			default:
				return nil, fmt.Errorf("field %s is array of %v, which is not supported", f.Name, elemType)
			}
		case reflect.Slice:
			dimStr, has := tagSettings[VectorDimTag]
			if !has {
				return nil, fmt.Errorf("field %s is slice but dim not provided", f.Name)
			}
			dim, err := strconv.ParseInt(dimStr, 10, 64)
			if err != nil {
				return nil, fmt.Errorf("dim value %s is not valid", dimStr)
			}
			if dim < 1 || dim > DimMax {
				return nil, fmt.Errorf("dim value %d is out of range", dim)
			}
			field.WithDim(dim)

			elemType := ft.Elem()
			switch elemType.Kind() {
			case reflect.Uint8: // []byte, could be BinaryVector, fp16, bf 6
				switch tagSettings[VectorTypeTag] {
				case "fp16":
					field.DataType = entity.FieldTypeFloat16Vector
				case "bf16":
					field.DataType = entity.FieldTypeBFloat16Vector
				default:
					field.DataType = entity.FieldTypeBinaryVector
				}
			case reflect.Float32:
				field.DataType = entity.FieldTypeFloatVector
			default:
				return nil, fmt.Errorf("field %s is slice of %v, which is not supported", f.Name, elemType)
			}
		default:
			return nil, fmt.Errorf("field %s is %v, which is not supported", field.Name, ft)
		}
		sch.Fields = append(sch.Fields, field)
	}

	return sch, nil
}

// ParseTagSetting parses struct tag into map settings
func ParseTagSetting(str string, sep string) map[string]string {
	settings := map[string]string{}
	names := strings.Split(str, sep)

	for i := 0; i < len(names); i++ {
		j := i
		if len(names[j]) > 0 {
			for {
				if names[j][len(names[j])-1] == '\\' {
					i++
					names[j] = names[j][0:len(names[j])-1] + sep + names[i]
					names[i] = ""
				} else {
					break
				}
			}
		}

		values := strings.Split(names[j], ":")
		k := strings.TrimSpace(strings.ToUpper(values[0]))

		if len(values) >= 2 {
			settings[k] = strings.Join(values[1:], ":")
		} else if k != "" {
			settings[k] = k
		}
	}

	return settings
}



---
File: /row/type.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package row

import (
	"go/ast"
	"reflect"
)

func ParseCandidate(dataType reflect.Type) map[string]int {
	result := make(map[string]int)
	for i := 0; i < dataType.NumField(); i++ {
		f := dataType.Field(i)
		// ignore anonymous field for now
		if f.Anonymous || !ast.IsExported(f.Name) {
			continue
		}

		name := f.Name
		tag := f.Tag.Get(MilvusTag)
		tagSettings := ParseTagSetting(tag, MilvusTagSep)
		if tagName, has := tagSettings[MilvusTagName]; has {
			name = tagName
		}

		result[name] = i
	}
	return result
}



---
File: /ruleguard/rules.go
---

// Licensed to the LF AI & Data foundation under one
// or more contributor license agreements. See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership. The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package gorules

import (
	"github.com/quasilyte/go-ruleguard/dsl"
)

// This is a collection of rules for ruleguard: https://github.com/quasilyte/go-ruleguard

// Remove extra conversions: mdempsky/unconvert
func unconvert(m dsl.Matcher) {
	m.Match("int($x)").Where(m["x"].Type.Is("int") && !m["x"].Const).Report("unnecessary conversion").Suggest("$x")

	m.Match("float32($x)").Where(m["x"].Type.Is("float32") && !m["x"].Const).Report("unnecessary conversion").Suggest("$x")
	m.Match("float64($x)").Where(m["x"].Type.Is("float64") && !m["x"].Const).Report("unnecessary conversion").Suggest("$x")

	// m.Match("byte($x)").Where(m["x"].Type.Is("byte")).Report("unnecessary conversion").Suggest("$x")
	// m.Match("rune($x)").Where(m["x"].Type.Is("rune")).Report("unnecessary conversion").Suggest("$x")
	m.Match("bool($x)").Where(m["x"].Type.Is("bool") && !m["x"].Const).Report("unnecessary conversion").Suggest("$x")

	m.Match("int8($x)").Where(m["x"].Type.Is("int8") && !m["x"].Const).Report("unnecessary conversion").Suggest("$x")
	m.Match("int16($x)").Where(m["x"].Type.Is("int16") && !m["x"].Const).Report("unnecessary conversion").Suggest("$x")
	m.Match("int32($x)").Where(m["x"].Type.Is("int32") && !m["x"].Const).Report("unnecessary conversion").Suggest("$x")
	m.Match("int64($x)").Where(m["x"].Type.Is("int64") && !m["x"].Const).Report("unnecessary conversion").Suggest("$x")

	m.Match("uint8($x)").Where(m["x"].Type.Is("uint8") && !m["x"].Const).Report("unnecessary conversion").Suggest("$x")
	m.Match("uint16($x)").Where(m["x"].Type.Is("uint16") && !m["x"].Const).Report("unnecessary conversion").Suggest("$x")
	m.Match("uint32($x)").Where(m["x"].Type.Is("uint32") && !m["x"].Const).Report("unnecessary conversion").Suggest("$x")
	m.Match("uint64($x)").Where(m["x"].Type.Is("uint64") && !m["x"].Const).Report("unnecessary conversion").Suggest("$x")

	m.Match("time.Duration($x)").Where(m["x"].Type.Is("time.Duration") && !m["x"].Text.Matches("^[0-9]*$")).Report("unnecessary conversion").Suggest("$x")
}

// Don't use == or != with time.Time
// https://github.com/dominikh/go-tools/issues/47 : Wontfix
func timeeq(m dsl.Matcher) {
	m.Match("$t0 == $t1").Where(m["t0"].Type.Is("time.Time")).Report("using == with time.Time")
	m.Match("$t0 != $t1").Where(m["t0"].Type.Is("time.Time")).Report("using != with time.Time")
	m.Match(`map[$k]$v`).Where(m["k"].Type.Is("time.Time")).Report("map with time.Time keys are easy to misuse")
}

// err but no an error
func errnoterror(m dsl.Matcher) {
	// Would be easier to check for all err identifiers instead, but then how do we get the type from m[] ?

	m.Match(
		"if $*_, err := $x; $err != nil { $*_ } else if $_ { $*_ }",
		"if $*_, err := $x; $err != nil { $*_ } else { $*_ }",
		"if $*_, err := $x; $err != nil { $*_ }",

		"if $*_, err = $x; $err != nil { $*_ } else if $_ { $*_ }",
		"if $*_, err = $x; $err != nil { $*_ } else { $*_ }",
		"if $*_, err = $x; $err != nil { $*_ }",

		"$*_, err := $x; if $err != nil { $*_ } else if $_ { $*_ }",
		"$*_, err := $x; if $err != nil { $*_ } else { $*_ }",
		"$*_, err := $x; if $err != nil { $*_ }",

		"$*_, err = $x; if $err != nil { $*_ } else if $_ { $*_ }",
		"$*_, err = $x; if $err != nil { $*_ } else { $*_ }",
		"$*_, err = $x; if $err != nil { $*_ }",
	).
		Where(m["err"].Text == "err" && !m["err"].Type.Is("error") && m["x"].Text != "recover()").
		Report("err variable not error type")
}

// Identical if and else bodies
func ifbodythenbody(m dsl.Matcher) {
	m.Match("if $*_ { $body } else { $body }").
		Report("identical if and else bodies")

	// Lots of false positives.
	// m.Match("if $*_ { $body } else if $*_ { $body }").
	//	Report("identical if and else bodies")
}

// Odd inequality: A - B < 0 instead of !=
// Too many false positives.
/*
func subtractnoteq(m dsl.Matcher) {
	m.Match("$a - $b < 0").Report("consider $a != $b")
	m.Match("$a - $b > 0").Report("consider $a != $b")
	m.Match("0 < $a - $b").Report("consider $a != $b")
	m.Match("0 > $a - $b").Report("consider $a != $b")
}
*/

// Self-assignment
func selfassign(m dsl.Matcher) {
	m.Match("$x = $x").Report("useless self-assignment")
}

// Odd nested ifs
func oddnestedif(m dsl.Matcher) {
	m.Match("if $x { if $x { $*_ }; $*_ }",
		"if $x == $y { if $x != $y {$*_ }; $*_ }",
		"if $x != $y { if $x == $y {$*_ }; $*_ }",
		"if $x { if !$x { $*_ }; $*_ }",
		"if !$x { if $x { $*_ }; $*_ }").
		Report("odd nested ifs")

	m.Match("for $x { if $x { $*_ }; $*_ }",
		"for $x == $y { if $x != $y {$*_ }; $*_ }",
		"for $x != $y { if $x == $y {$*_ }; $*_ }",
		"for $x { if !$x { $*_ }; $*_ }",
		"for !$x { if $x { $*_ }; $*_ }").
		Report("odd nested for/ifs")
}

// odd bitwise expressions
func oddbitwise(m dsl.Matcher) {
	m.Match("$x | $x",
		"$x | ^$x",
		"^$x | $x").
		Report("odd bitwise OR")

	m.Match("$x & $x",
		"$x & ^$x",
		"^$x & $x").
		Report("odd bitwise AND")

	m.Match("$x &^ $x").
		Report("odd bitwise AND-NOT")
}

// odd sequence of if tests with return
func ifreturn(m dsl.Matcher) {
	m.Match("if $x { return $*_ }; if $x {$*_ }").Report("odd sequence of if test")
	m.Match("if $x { return $*_ }; if !$x {$*_ }").Report("odd sequence of if test")
	m.Match("if !$x { return $*_ }; if $x {$*_ }").Report("odd sequence of if test")
	m.Match("if $x == $y { return $*_ }; if $x != $y {$*_ }").Report("odd sequence of if test")
	m.Match("if $x != $y { return $*_ }; if $x == $y {$*_ }").Report("odd sequence of if test")
}

func oddifsequence(m dsl.Matcher) {
	/*
		m.Match("if $x { $*_ }; if $x {$*_ }").Report("odd sequence of if test")

		m.Match("if $x == $y { $*_ }; if $y == $x {$*_ }").Report("odd sequence of if tests")
		m.Match("if $x != $y { $*_ }; if $y != $x {$*_ }").Report("odd sequence of if tests")

		m.Match("if $x < $y { $*_ }; if $y > $x {$*_ }").Report("odd sequence of if tests")
		m.Match("if $x <= $y { $*_ }; if $y >= $x {$*_ }").Report("odd sequence of if tests")

		m.Match("if $x > $y { $*_ }; if $y < $x {$*_ }").Report("odd sequence of if tests")
		m.Match("if $x >= $y { $*_ }; if $y <= $x {$*_ }").Report("odd sequence of if tests")
	*/
}

// odd sequence of nested if tests
func nestedifsequence(m dsl.Matcher) {
	/*
		m.Match("if $x < $y { if $x >= $y {$*_ }; $*_ }").Report("odd sequence of nested if tests")
		m.Match("if $x <= $y { if $x > $y {$*_ }; $*_ }").Report("odd sequence of nested if tests")
		m.Match("if $x > $y { if $x <= $y {$*_ }; $*_ }").Report("odd sequence of nested if tests")
		m.Match("if $x >= $y { if $x < $y {$*_ }; $*_ }").Report("odd sequence of nested if tests")
	*/
}

// odd sequence of assignments
func identicalassignments(m dsl.Matcher) {
	m.Match("$x  = $y; $y = $x").Report("odd sequence of assignments")
}

func oddcompoundop(m dsl.Matcher) {
	m.Match("$x += $x + $_",
		"$x += $x - $_").
		Report("odd += expression")

	m.Match("$x -= $x + $_",
		"$x -= $x - $_").
		Report("odd -= expression")
}

func constswitch(m dsl.Matcher) {
	m.Match("switch $x { $*_ }", "switch $*_; $x { $*_ }").
		Where(m["x"].Const && !m["x"].Text.Matches(`^runtime\.`)).
		Report("constant switch")
}

func oddcomparisons(m dsl.Matcher) {
	m.Match(
		"$x - $y == 0",
		"$x - $y != 0",
		"$x - $y < 0",
		"$x - $y <= 0",
		"$x - $y > 0",
		"$x - $y >= 0",
		"$x ^ $y == 0",
		"$x ^ $y != 0",
	).Report("odd comparison")
}

func oddmathbits(m dsl.Matcher) {
	m.Match(
		"64 - bits.LeadingZeros64($x)",
		"32 - bits.LeadingZeros32($x)",
		"16 - bits.LeadingZeros16($x)",
		"8 - bits.LeadingZeros8($x)",
	).Report("odd math/bits expression: use bits.Len*() instead?")
}

// func floateq(m dsl.Matcher) {
// 	m.Match(
// 		"$x == $y",
// 		"$x != $y",
// 	).
// 		Where(m["x"].Type.Is("float32") && !m["x"].Const && !m["y"].Text.Matches("0(.0+)?") && !m.File().Name.Matches("floating_comparision.go")).
// 		Report("floating point tested for equality")

// 	m.Match(
// 		"$x == $y",
// 		"$x != $y",
// 	).
// 		Where(m["x"].Type.Is("float64") && !m["x"].Const && !m["y"].Text.Matches("0(.0+)?") && !m.File().Name.Matches("floating_comparision.go")).
// 		Report("floating point tested for equality")

// 	m.Match("switch $x { $*_ }", "switch $*_; $x { $*_ }").
// 		Where(m["x"].Type.Is("float32")).
// 		Report("floating point as switch expression")

// 	m.Match("switch $x { $*_ }", "switch $*_; $x { $*_ }").
// 		Where(m["x"].Type.Is("float64")).
// 		Report("floating point as switch expression")

// }

func badexponent(m dsl.Matcher) {
	m.Match(
		"2 ^ $x",
		"10 ^ $x",
	).
		Report("caret (^) is not exponentiation")
}

func floatloop(m dsl.Matcher) {
	m.Match(
		"for $i := $x; $i < $y; $i += $z { $*_ }",
		"for $i = $x; $i < $y; $i += $z { $*_ }",
	).
		Where(m["i"].Type.Is("float64")).
		Report("floating point for loop counter")

	m.Match(
		"for $i := $x; $i < $y; $i += $z { $*_ }",
		"for $i = $x; $i < $y; $i += $z { $*_ }",
	).
		Where(m["i"].Type.Is("float32")).
		Report("floating point for loop counter")
}

func urlredacted(m dsl.Matcher) {
	m.Match(
		"log.Println($x, $*_)",
		"log.Println($*_, $x, $*_)",
		"log.Println($*_, $x)",
		"log.Printf($*_, $x, $*_)",
		"log.Printf($*_, $x)",

		"log.Println($x, $*_)",
		"log.Println($*_, $x, $*_)",
		"log.Println($*_, $x)",
		"log.Printf($*_, $x, $*_)",
		"log.Printf($*_, $x)",
	).
		Where(m["x"].Type.Is("*url.URL")).
		Report("consider $x.Redacted() when outputting URLs")
}

func sprinterr(m dsl.Matcher) {
	m.Match(`fmt.Sprint($err)`,
		`fmt.Sprintf("%s", $err)`,
		`fmt.Sprintf("%v", $err)`,
	).
		Where(m["err"].Type.Is("error")).
		Report("maybe call $err.Error() instead of fmt.Sprint()?")
}

// disable this check, because it can not apply to generic type
//func largeloopcopy(m dsl.Matcher) {
//	m.Match(
//		`for $_, $v := range $_ { $*_ }`,
//	).
//		Where(m["v"].Type.Size > 1024).
//		Report(`loop copies large value each iteration`)
//}

func joinpath(m dsl.Matcher) {
	m.Match(
		`strings.Join($_, "/")`,
		`strings.Join($_, "\\")`,
		"strings.Join($_, `\\`)",
	).
		Report(`did you mean path.Join() or filepath.Join() ?`)
}

func readfull(m dsl.Matcher) {
	m.Match(`$n, $err := io.ReadFull($_, $slice)
                 if $err != nil || $n != len($slice) {
                              $*_
		 }`,
		`$n, $err := io.ReadFull($_, $slice)
                 if $n != len($slice) || $err != nil {
                              $*_
		 }`,
		`$n, $err = io.ReadFull($_, $slice)
                 if $err != nil || $n != len($slice) {
                              $*_
		 }`,
		`$n, $err = io.ReadFull($_, $slice)
                 if $n != len($slice) || $err != nil {
                              $*_
		 }`,
		`if $n, $err := io.ReadFull($_, $slice); $n != len($slice) || $err != nil {
                              $*_
		 }`,
		`if $n, $err := io.ReadFull($_, $slice); $err != nil || $n != len($slice) {
                              $*_
		 }`,
		`if $n, $err = io.ReadFull($_, $slice); $n != len($slice) || $err != nil {
                              $*_
		 }`,
		`if $n, $err = io.ReadFull($_, $slice); $err != nil || $n != len($slice) {
                              $*_
		 }`,
	).Report("io.ReadFull() returns err == nil iff n == len(slice)")
}

func nilerr(m dsl.Matcher) {
	m.Match(
		`if err == nil { return err }`,
		`if err == nil { return $*_, err }`,
	).
		Report(`return nil error instead of nil value`)
}

func mailaddress(m dsl.Matcher) {
	m.Match(
		"fmt.Sprintf(`\"%s\" <%s>`, $NAME, $EMAIL)",
		"fmt.Sprintf(`\"%s\"<%s>`, $NAME, $EMAIL)",
		"fmt.Sprintf(`%s <%s>`, $NAME, $EMAIL)",
		"fmt.Sprintf(`%s<%s>`, $NAME, $EMAIL)",
		`fmt.Sprintf("\"%s\"<%s>", $NAME, $EMAIL)`,
		`fmt.Sprintf("\"%s\" <%s>", $NAME, $EMAIL)`,
		`fmt.Sprintf("%s<%s>", $NAME, $EMAIL)`,
		`fmt.Sprintf("%s <%s>", $NAME, $EMAIL)`,
	).
		Report("use net/mail Address.String() instead of fmt.Sprintf()").
		Suggest("(&mail.Address{Name:$NAME, Address:$EMAIL}).String()")
}

func errnetclosed(m dsl.Matcher) {
	m.Match(
		`strings.Contains($err.Error(), $text)`,
	).
		Where(m["text"].Text.Matches("\".*closed network connection.*\"")).
		Report(`String matching against error texts is fragile; use net.ErrClosed instead`).
		Suggest(`errors.Is($err, net.ErrClosed)`)
}

func httpheaderadd(m dsl.Matcher) {
	m.Match(
		`$H.Add($KEY, $VALUE)`,
	).
		Where(m["H"].Type.Is("http.Header")).
		Report("use http.Header.Set method instead of Add to overwrite all existing header values").
		Suggest(`$H.Set($KEY, $VALUE)`)
}

func hmacnew(m dsl.Matcher) {
	m.Match("hmac.New(func() hash.Hash { return $x }, $_)",
		`$f := func() hash.Hash { return $x }
	$*_
	hmac.New($f, $_)`,
	).Where(m["x"].Pure).
		Report("invalid hash passed to hmac.New()")
}

func writestring(m dsl.Matcher) {
	m.Match(`io.WriteString($w, string($b))`).
		Where(m["b"].Type.Is("[]byte")).
		Suggest("$w.Write($b)")
}

func badlock(m dsl.Matcher) {
	// Shouldn't give many false positives without type filter
	// as Lock+Unlock pairs in combination with defer gives us pretty
	// a good chance to guess correctly. If we constrain the type to sync.Mutex
	// then it'll be harder to match embedded locks and custom methods
	// that may forward the call to the sync.Mutex (or other synchronization primitive).

	m.Match(`$mu.Lock(); defer $mu.RUnlock()`).Report(`maybe $mu.RLock() was intended?`)
	m.Match(`$mu.RLock(); defer $mu.Unlock()`).Report(`maybe $mu.Lock() was intended?`)
}



---
File: /.golangci.yml
---

run:
  go: "1.22"
  build-tags:
    - dynamic
    - test

linters:
  disable-all: true
  enable:
    - gosimple
    - govet
    - ineffassign
    - staticcheck
    - decorder
    - depguard
    - gofmt
    - goimports
    - gosec
    - revive
    - unconvert
    - misspell
    - typecheck
    - durationcheck
    - forbidigo
    - gci
    - whitespace
    - gofumpt
    - gocritic

linters-settings:
  gci:
    sections:
      - standard
      - default
      - prefix(github.com/milvus-io)
    custom-order: true
  gofumpt:
    lang-version: "1.18"
    module-path: github.com/milvus-io
  goimports:
    local-prefixes: github.com/milvus-io
  revive:
    rules:
      - name: unused-parameter
        disabled: true
      - name: var-naming
        severity: warning
        disabled: false
        arguments:
          - ["ID", "IDS"] # Allow list
      - name: context-as-argument
        severity: warning
        disabled: false
        arguments:
          - allowTypesBefore: "*testing.T"
      - name: datarace
        severity: warning
        disabled: false
      - name: duplicated-imports
        severity: warning
        disabled: false
      - name: waitgroup-by-value
        severity: warning
        disabled: false
      - name: indent-error-flow
        severity: warning
        disabled: false
        arguments:
          - "preserveScope"
      - name: range-val-in-closure
        severity: warning
        disabled: false
      - name: range-val-address
        severity: warning
        disabled: false
      - name: string-of-int
        severity: warning
        disabled: false
  misspell:
    locale: US
  gocritic:
    enabled-checks:
      - ruleguard
    settings:
      ruleguard:
        failOnError: true
        rules: "ruleguard/rules.go"
  depguard:
    rules:
      main:
        deny:
          - pkg: "errors"
            desc: not allowed, use github.com/cockroachdb/errors
          - pkg: "github.com/pkg/errors"
            desc: not allowed, use github.com/cockroachdb/errors
          - pkg: "github.com/pingcap/errors"
            desc: not allowed, use github.com/cockroachdb/errors
          - pkg: "golang.org/x/xerrors"
            desc: not allowed, use github.com/cockroachdb/errors
          - pkg: "github.com/go-errors/errors"
            desc: not allowed, use github.com/cockroachdb/errors
          - pkg: "io/ioutil"
            desc: ioutil is deprecated after 1.16, 1.17, use os and io package instead
          - pkg: "github.com/tikv/client-go/rawkv"
            desc: not allowed, use github.com/tikv/client-go/v2/txnkv
          - pkg: "github.com/tikv/client-go/v2/rawkv"
            desc: not allowed, use github.com/tikv/client-go/v2/txnkv
  forbidigo:
    forbid:
      - '^time\.Tick$'
      - 'return merr\.Err[a-zA-Z]+'
      - 'merr\.Wrap\w+\(\)\.Error\(\)'
      - '\.(ErrorCode|Reason) = '
      - 'Reason:\s+\w+\.Error\(\)'
      - 'errors.New\((.+)\.GetReason\(\)\)'
      - 'commonpb\.Status\{[\s\n]*ErrorCode:[\s\n]*.+[\s\S\n]*?\}'
      - 'os\.Open\(.+\)'
      - 'os\.ReadFile\(.+\)'
      - 'os\.WriteFile\(.+\)'
      - "runtime.NumCPU"
      - "runtime.GOMAXPROCS(0)"
      #- 'fmt\.Print.*' WIP

issues:
  exclude-dirs:
    - build
    - configs
    - deployments
    - docs
    - scripts
    - internal/core
    - cmake_build
    - mmap
    - data
    - ci
  exclude-files:
    - partial_search_test.go
  exclude-use-default: false
  exclude-rules:
    - path: .+_test\.go
      linters:
        - forbidigo
  exclude:
    - should have a package comment
    - should have comment
    - should be of the form
    - should not use dot imports
    - which can be annoying to use
    # Binds to all network interfaces
    - G102
    # Use of unsafe calls should be audited
    - G103
    # Errors unhandled
    - G104
    # file/folder Permission
    - G301
    - G302
    # Potential file inclusion via variable
    - G304
    # Deferring unsafe method like *os.File Close
    - G307
    # TLS MinVersion too low
    - G402
    # Use of weak random number generator math/rand
    - G404
    # Unused parameters
    - SA1019
    # defer return errors
    - SA5001
    # TODO: cleanup following exclusions, added on golangci-lint upgrade
    - sloppyLen
    - dupSubExpr
    - assignOp
    - ifElseChain
    - elseif
    - commentFormatting
    - exitAfterDefer
    - captLocal
    - singleCaseSwitch
    - typeSwitchVar
    - indent-error-flow
    - appendAssign
    - deprecatedComment
    - SA9009
    - SA1006
    - S1009
    - offBy1
    - unslice    
    # Integer overflow conversion
    - G115
    - has no field or method

  # Maximum issues count per one linter. Set to 0 to disable. Default is 50.
  max-issues-per-linter: 0
  # Maximum count of issues with the same text. Set to 0 to disable. Default is 3.
  max-same-issues: 0

service:
  # use the fixed version to not introduce new linters unexpectedly
  golangci-lint-version: 1.55.2



---
File: /go.mod
---

module github.com/milvus-io/milvus/client/v2

go 1.24.1

require (
	github.com/blang/semver/v4 v4.0.0
	github.com/cockroachdb/errors v1.9.1
	github.com/grpc-ecosystem/go-grpc-middleware v1.3.0
	github.com/milvus-io/milvus-proto/go-api/v2 v2.5.11
	github.com/milvus-io/milvus/pkg/v2 v2.5.7
	github.com/quasilyte/go-ruleguard/dsl v0.3.22
	github.com/samber/lo v1.27.0
	github.com/stretchr/testify v1.9.0
	github.com/tidwall/gjson v1.17.1
	go.uber.org/atomic v1.11.0
	google.golang.org/grpc v1.65.0
	google.golang.org/protobuf v1.34.2
)

require (
	github.com/beorn7/perks v1.0.1 // indirect
	github.com/cenkalti/backoff/v4 v4.2.1 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/cilium/ebpf v0.11.0 // indirect
	github.com/cockroachdb/logtags v0.0.0-20211118104740-dabe8e521a4f // indirect
	github.com/cockroachdb/redact v1.1.3 // indirect
	github.com/containerd/cgroups/v3 v3.0.3 // indirect
	github.com/coreos/go-semver v0.3.0 // indirect
	github.com/coreos/go-systemd/v22 v22.3.2 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/docker/go-units v0.4.0 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/form3tech-oss/jwt-go v3.2.3+incompatible // indirect
	github.com/getsentry/sentry-go v0.12.0 // indirect
	github.com/go-logr/logr v1.4.2 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/go-ole/go-ole v1.2.6 // indirect
	github.com/godbus/dbus/v5 v5.0.4 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/golang/protobuf v1.5.4 // indirect
	github.com/google/btree v1.1.2 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/gorilla/websocket v1.4.2 // indirect
	github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0 // indirect
	github.com/grpc-ecosystem/grpc-gateway v1.16.0 // indirect
	github.com/grpc-ecosystem/grpc-gateway/v2 v2.16.0 // indirect
	github.com/jonboulle/clockwork v0.2.2 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/kr/pretty v0.3.1 // indirect
	github.com/kr/text v0.2.0 // indirect
	github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 // indirect
	github.com/matttproud/golang_protobuf_extensions v1.0.4 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/opencontainers/runtime-spec v1.0.2 // indirect
	github.com/panjf2000/ants/v2 v2.7.2 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c // indirect
	github.com/prometheus/client_golang v1.14.0 // indirect
	github.com/prometheus/client_model v0.5.0 // indirect
	github.com/prometheus/common v0.42.0 // indirect
	github.com/prometheus/procfs v0.9.0 // indirect
	github.com/rogpeppe/go-internal v1.12.0 // indirect
	github.com/shirou/gopsutil/v3 v3.22.9 // indirect
	github.com/sirupsen/logrus v1.9.3 // indirect
	github.com/soheilhy/cmux v0.1.5 // indirect
	github.com/spaolacci/murmur3 v1.1.0 // indirect
	github.com/spf13/cast v1.3.1 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	github.com/tidwall/match v1.1.1 // indirect
	github.com/tidwall/pretty v1.2.0 // indirect
	github.com/tklauser/go-sysconf v0.3.10 // indirect
	github.com/tklauser/numcpus v0.4.0 // indirect
	github.com/tmc/grpc-websocket-proxy v0.0.0-20201229170055-e5319fda7802 // indirect
	github.com/uber/jaeger-client-go v2.30.0+incompatible // indirect
	github.com/x448/float16 v0.8.4 // indirect
	github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2 // indirect
	github.com/yusufpapurcu/wmi v1.2.2 // indirect
	go.etcd.io/bbolt v1.3.6 // indirect
	go.etcd.io/etcd/api/v3 v3.5.5 // indirect
	go.etcd.io/etcd/client/pkg/v3 v3.5.5 // indirect
	go.etcd.io/etcd/client/v2 v2.305.5 // indirect
	go.etcd.io/etcd/client/v3 v3.5.5 // indirect
	go.etcd.io/etcd/pkg/v3 v3.5.5 // indirect
	go.etcd.io/etcd/raft/v3 v3.5.5 // indirect
	go.etcd.io/etcd/server/v3 v3.5.5 // indirect
	go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0 // indirect
	go.opentelemetry.io/otel v1.28.0 // indirect
	go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.20.0 // indirect
	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.20.0 // indirect
	go.opentelemetry.io/otel/metric v1.28.0 // indirect
	go.opentelemetry.io/otel/sdk v1.28.0 // indirect
	go.opentelemetry.io/otel/trace v1.28.0 // indirect
	go.opentelemetry.io/proto/otlp v1.0.0 // indirect
	go.uber.org/automaxprocs v1.5.3 // indirect
	go.uber.org/multierr v1.11.0 // indirect
	go.uber.org/zap v1.27.0 // indirect
	golang.org/x/crypto v0.35.0 // indirect
	golang.org/x/exp v0.0.0-20240506185415-9bf2ced13842 // indirect
	golang.org/x/net v0.36.0 // indirect
	golang.org/x/sync v0.11.0 // indirect
	golang.org/x/sys v0.30.0 // indirect
	golang.org/x/text v0.22.0 // indirect
	golang.org/x/time v0.5.0 // indirect
	google.golang.org/genproto v0.0.0-20231106174013-bbf56f31fb17 // indirect
	google.golang.org/genproto/googleapis/api v0.0.0-20240528184218-531527333157 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20240730163845-b1a4ccb954bf // indirect
	gopkg.in/inf.v0 v0.9.1 // indirect
	gopkg.in/natefinch/lumberjack.v2 v2.0.0 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	k8s.io/apimachinery v0.28.6 // indirect
	sigs.k8s.io/yaml v1.3.0 // indirect
)



---
File: /go.sum
---

cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
cloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=
cloud.google.com/go v0.44.1/go.mod h1:iSa0KzasP4Uvy3f1mN/7PiObzGgflwredwwASm/v6AU=
cloud.google.com/go v0.44.2/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=
cloud.google.com/go v0.45.1/go.mod h1:RpBamKRgapWJb87xiFSdk4g1CME7QZg3uwTez+TSTjc=
cloud.google.com/go v0.46.3/go.mod h1:a6bKKbmY7er1mI7TEI4lsAkts/mkhTSZK8w33B4RAg0=
cloud.google.com/go/bigquery v1.0.1/go.mod h1:i/xbL2UlR5RvWAURpBYZTtm/cXjCha9lbfbpx4poX+o=
cloud.google.com/go/datastore v1.0.0/go.mod h1:LXYbyblFSglQ5pkeyhO+Qmw7ukd3C+pD7TKLgZqpHYE=
cloud.google.com/go/firestore v1.1.0/go.mod h1:ulACoGHTpvq5r8rxGJ4ddJZBZqakUQqClKRT5SZwBmk=
cloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=
cloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=
dmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=
github.com/AndreasBriese/bbloom v0.0.0-20190306092124-e2d15f34fcf9/go.mod h1:bOvUY6CB00SOBii9/FifXqc0awNKxLFCL/+pkDPuyl8=
github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
github.com/BurntSushi/toml v1.2.1 h1:9F2/+DoOYIOksmaJFPw1tGFy1eDnIJXg+UHjuD8lTak=
github.com/BurntSushi/toml v1.2.1/go.mod h1:CxXYINrC8qIiEnFrOxCa7Jy5BFHlXnUU2pbicEuybxQ=
github.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=
github.com/CloudyKit/fastprinter v0.0.0-20200109182630-33d98a066a53/go.mod h1:+3IMCy2vIlbG1XG/0ggNQv0SvxCAIpPM5b1nCz56Xno=
github.com/CloudyKit/jet/v3 v3.0.0/go.mod h1:HKQPgSJmdK8hdoAbKUUWajkHyHo4RaU5rMdUywE7VMo=
github.com/Joker/hpp v1.0.0/go.mod h1:8x5n+M1Hp5hC0g8okX3sR3vFQwynaX/UgSOM9MeBKzY=
github.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=
github.com/Shopify/goreferrer v0.0.0-20181106222321-ec9c9a553398/go.mod h1:a1uqRtAwp2Xwc6WNPJEufxJ7fx3npB4UV/JOLmbu5I0=
github.com/ajg/form v1.5.1/go.mod h1:uL1WgH+h2mgNtvBq0339dVnzXdBETtL2LeUXaIv25UY=
github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
github.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
github.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=
github.com/alecthomas/units v0.0.0-20190717042225-c3de453c63f4/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=
github.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d/go.mod h1:rBZYJk541a8SKzHPHnH3zbiI+7dagKZ0cgpgrD7Fyho=
github.com/antihax/optional v1.0.0/go.mod h1:uupD/76wgC+ih3iEmQUL+0Ugr19nfwCT1kdvxnR2qWY=
github.com/armon/circbuf v0.0.0-20150827004946-bbbad097214e/go.mod h1:3U/XgcO3hCbHZ8TKRvWD2dDTCfh9M9ya+I9JpbB7O8o=
github.com/armon/consul-api v0.0.0-20180202201655-eb2c6b5be1b6/go.mod h1:grANhF5doyWs3UAsr3K4I6qtAmlQcZDesFNEHPZAzj8=
github.com/armon/go-metrics v0.0.0-20180917152333-f0300d1749da/go.mod h1:Q73ZrmVTwzkszR9V5SSuryQ31EELlFMUz1kKyl939pY=
github.com/armon/go-radix v0.0.0-20180808171621-7fddfc383310/go.mod h1:ufUuZ+zHj4x4TnLV4JWEpy2hxWSpsRywHrMgIH9cCH8=
github.com/aymerick/raymond v2.0.3-0.20180322193309-b565731e1464+incompatible/go.mod h1:osfaiScAUVup+UC9Nfq76eWqDhXlp+4UYaA8uhTBO6g=
github.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=
github.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=
github.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=
github.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=
github.com/bgentry/speakeasy v0.1.0/go.mod h1:+zsyZBPWlz7T6j88CTgSN5bM796AkVf0kBD4zp0CCIs=
github.com/bketelsen/crypt v0.0.3-0.20200106085610-5cbc8cc4026c/go.mod h1:MKsuJmJgSg28kpZDP6UIiPt0e0Oz0kqKNGyRaWEPv84=
github.com/blang/semver/v4 v4.0.0 h1:1PFHFE6yCCTv8C1TeyNNarDzntLi7wMI5i/pzqYIsAM=
github.com/blang/semver/v4 v4.0.0/go.mod h1:IbckMUScFkM3pff0VJDNKRiT6TG/YpiHIM2yvyW5YoQ=
github.com/cenkalti/backoff/v4 v4.1.1/go.mod h1:scbssz8iZGpm3xbr14ovlUdkxfGXNInqkPWOWmG2CLw=
github.com/cenkalti/backoff/v4 v4.2.1 h1:y4OZtCnogmCPw98Zjyt5a6+QwPLGkiQsYW5oUqylYbM=
github.com/cenkalti/backoff/v4 v4.2.1/go.mod h1:Y3VNntkOUPxTVeUxJ/G5vcM//AlwfmyYozVcomhLiZE=
github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=
github.com/certifi/gocertifi v0.0.0-20191021191039-0944d244cd40/go.mod h1:sGbDF6GwGcLpkNXPUTkMRoywsNa/ol15pxFe6ERfguA=
github.com/certifi/gocertifi v0.0.0-20200922220541-2c3bb06c6054/go.mod h1:sGbDF6GwGcLpkNXPUTkMRoywsNa/ol15pxFe6ERfguA=
github.com/cespare/xxhash v1.1.0/go.mod h1:XrSqR1VqqWfGrhpAt58auRo0WTKS1nRRg3ghfAqPWnc=
github.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=
github.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/cilium/ebpf v0.11.0 h1:V8gS/bTCCjX9uUnkUFUpPsksM8n1lXBAvHcpiFk1X2Y=
github.com/cilium/ebpf v0.11.0/go.mod h1:WE7CZAnqOL2RouJ4f1uyNhqr2P4CCvXFIqdRDUgWsVs=
github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
github.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=
github.com/cncf/udpa/go v0.0.0-20201120205902-5459f2c99403/go.mod h1:WmhPx2Nbnhtbo57+VJT5O0JRkEi1Wbu0z5j0R8u5Hbk=
github.com/cncf/xds/go v0.0.0-20210312221358-fbca930ec8ed/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cncf/xds/go v0.0.0-20210805033703-aa0b78936158/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=
github.com/cockroachdb/datadriven v0.0.0-20200714090401-bf6692d28da5/go.mod h1:h6jFvWxBdQXxjopDMZyH2UVceIRfR84bdzbkoKrsWNo=
github.com/cockroachdb/datadriven v1.0.2 h1:H9MtNqVoVhvd9nCBwOyDjUEdZCREqbIdCJD93PBm/jA=
github.com/cockroachdb/datadriven v1.0.2/go.mod h1:a9RdTaap04u637JoCzcUoIcDmvwSUtcUFtT/C3kJlTU=
github.com/cockroachdb/errors v1.2.4/go.mod h1:rQD95gz6FARkaKkQXUksEje/d9a6wBJoCr5oaCLELYA=
github.com/cockroachdb/errors v1.9.1 h1:yFVvsI0VxmRShfawbt/laCIDy/mtTqqnvoNgiy5bEV8=
github.com/cockroachdb/errors v1.9.1/go.mod h1:2sxOtL2WIc096WSZqZ5h8fa17rdDq9HZOZLBCor4mBk=
github.com/cockroachdb/logtags v0.0.0-20190617123548-eb05cc24525f/go.mod h1:i/u985jwjWRlyHXQbwatDASoW0RMlZ/3i9yJHE2xLkI=
github.com/cockroachdb/logtags v0.0.0-20211118104740-dabe8e521a4f h1:6jduT9Hfc0njg5jJ1DdKCFPdMBrp/mdZfCpa5h+WM74=
github.com/cockroachdb/logtags v0.0.0-20211118104740-dabe8e521a4f/go.mod h1:Vz9DsVWQQhf3vs21MhPMZpMGSht7O/2vFW2xusFUVOs=
github.com/cockroachdb/redact v1.1.3 h1:AKZds10rFSIj7qADf0g46UixK8NNLwWTNdCIGS5wfSQ=
github.com/cockroachdb/redact v1.1.3/go.mod h1:BVNblN9mBWFyMyqK1k3AAiSxhvhfK2oOZZ2lK+dpvRg=
github.com/codegangsta/inject v0.0.0-20150114235600-33e0aa1cb7c0/go.mod h1:4Zcjuz89kmFXt9morQgcfYZAYZ5n8WHjt81YYWIwtTM=
github.com/containerd/cgroups/v3 v3.0.3 h1:S5ByHZ/h9PMe5IOQoN7E+nMc2UcLEM/V48DGDJ9kip0=
github.com/containerd/cgroups/v3 v3.0.3/go.mod h1:8HBe7V3aWGLFPd/k03swSIsGjZhHI2WzJmticMgVuz0=
github.com/coreos/bbolt v1.3.2/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkEiiKk=
github.com/coreos/etcd v3.3.10+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=
github.com/coreos/etcd v3.3.13+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=
github.com/coreos/go-etcd v2.0.0+incompatible/go.mod h1:Jez6KQU2B/sWsbdaef3ED8NzMklzPG4d5KIOhIy30Tk=
github.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=
github.com/coreos/go-semver v0.3.0 h1:wkHLiw0WNATZnSG7epLsujiMCgPAc9xhjJ4tgnAxmfM=
github.com/coreos/go-semver v0.3.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=
github.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=
github.com/coreos/go-systemd/v22 v22.3.2 h1:D9/bQk5vlXQFZ6Kwuu6zaiXJ9oTPe68++AzAJc1DzSI=
github.com/coreos/go-systemd/v22 v22.3.2/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=
github.com/coreos/pkg v0.0.0-20180928190104-399ea9e2e55f/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=
github.com/cpuguy83/go-md2man v1.0.10/go.mod h1:SmD6nW6nTyfqj6ABTjUi3V3JVMnlJmwcJI5acqYI6dE=
github.com/cpuguy83/go-md2man/v2 v2.0.0/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=
github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/creack/pty v1.1.11/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dgraph-io/badger v1.6.0/go.mod h1:zwt7syl517jmP8s94KqSxTlM6IMsdhYy6psNgSztDR4=
github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=
github.com/dgryski/go-farm v0.0.0-20190423205320-6a90982ecee2/go.mod h1:SqUrOPUnsFjfmXRMNPybcSiG0BgUW2AuFH8PAnS2iTw=
github.com/dgryski/go-sip13 v0.0.0-20181026042036-e10d5fee7954/go.mod h1:vAd38F8PWV+bWy6jNmig1y/TA+kYO4g3RSRF0IAv0no=
github.com/docker/go-units v0.4.0 h1:3uh0PgVws3nIA0Q+MwDC8yjEPf9zjRfZZWXZYDct3Tw=
github.com/docker/go-units v0.4.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=
github.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=
github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
github.com/eknkc/amber v0.0.0-20171010120322-cdade1c07385/go.mod h1:0vRUJqYpeSZifjYj7uP3BG/gKcuzL9xWVV/Y+cK33KM=
github.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
github.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=
github.com/envoyproxy/go-control-plane v0.9.9-0.20201210154907-fd9021fe5dad/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=
github.com/envoyproxy/go-control-plane v0.9.9-0.20210217033140-668b12f5399d/go.mod h1:cXg6YxExXjJnVBQHBLXeUAgxn2UodCpnH306RInaBQk=
github.com/envoyproxy/go-control-plane v0.9.9-0.20210512163311-63b5d3c536b0/go.mod h1:hliV/p42l8fGbc6Y9bQ70uLwIvmJyVE5k4iMKlh8wCQ=
github.com/envoyproxy/go-control-plane v0.9.10-0.20210907150352-cf90f659a021/go.mod h1:AFq3mo9L8Lqqiid3OhADV3RfLJnjiw63cSpi+fDTRC0=
github.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=
github.com/etcd-io/bbolt v1.3.3/go.mod h1:ZF2nL25h33cCyBtcyWeZ2/I3HQOfTP+0PIEvHjkjCrw=
github.com/fasthttp-contrib/websocket v0.0.0-20160511215533-1f3b11f56072/go.mod h1:duJ4Jxv5lDcvg4QuQr0oowTf7dz4/CR8NtyCooz9HL8=
github.com/fatih/color v1.7.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=
github.com/fatih/structs v1.1.0/go.mod h1:9NiDSp5zOcgEDl+j00MP/WkGVPOlPRLejGD8Ga6PJ7M=
github.com/form3tech-oss/jwt-go v3.2.3+incompatible h1:7ZaBxOI7TMoYBfyA3cQHErNNyAWIKUMIwqxEtgHOs5c=
github.com/form3tech-oss/jwt-go v3.2.3+incompatible/go.mod h1:pbq4aXjuKjdthFRnoDwaVPLA+WlJuPGy+QneDUgJi2k=
github.com/frankban/quicktest v1.14.5 h1:dfYrrRyLtiqT9GyKXgdh+k4inNeTvmGbuSgZ3lx3GhA=
github.com/frankban/quicktest v1.14.5/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=
github.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=
github.com/gavv/httpexpect v2.0.0+incompatible/go.mod h1:x+9tiU1YnrOvnB725RkpoLv1M62hOWzwo5OXotisrKc=
github.com/getsentry/raven-go v0.2.0/go.mod h1:KungGk8q33+aIAZUIVWZDr2OfAEBsO49PX4NzFV5kcQ=
github.com/getsentry/sentry-go v0.12.0 h1:era7g0re5iY13bHSdN/xMkyV+5zZppjRVQhZrXCaEIk=
github.com/getsentry/sentry-go v0.12.0/go.mod h1:NSap0JBYWzHND8oMbyi0+XZhUalc1TBdRL1M71JZW2c=
github.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=
github.com/gin-contrib/sse v0.0.0-20190301062529-5545eab6dad3/go.mod h1:VJ0WA2NBN22VlZ2dKZQPAPnyWw5XTlK1KymzLKsr59s=
github.com/gin-gonic/gin v1.4.0/go.mod h1:OW2EZn3DO8Ln9oIKOvM++LBO+5UPHJJDH72/q/3rZdM=
github.com/go-check/check v0.0.0-20180628173108-788fd7840127/go.mod h1:9ES+weclKsC9YodN5RgxqK/VD9HM9JsCSh7rNhMZE98=
github.com/go-errors/errors v1.0.1 h1:LUHzmkK3GUKUrL/1gfBUxAHzcev3apQlezX/+O7ma6w=
github.com/go-errors/errors v1.0.1/go.mod h1:f4zRHt4oKfwPJE5k8C9vpYG+aDHdBFUsgrm6/TyX73Q=
github.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=
github.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=
github.com/go-kit/kit v0.9.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=
github.com/go-kit/log v0.1.0/go.mod h1:zbhenjAZHb184qTLMA9ZjW7ThYL0H2mk7Q6pNt4vbaY=
github.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=
github.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=
github.com/go-logfmt/logfmt v0.5.0/go.mod h1:wCYkCAKZfumFQihp8CzCvQ3paCTfi41vtzG1KdI/P7A=
github.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
github.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=
github.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/go-martini/martini v0.0.0-20170121215854-22fa46961aab/go.mod h1:/P9AEU963A2AYjv4d1V5eVL1CQbEJq6aCNHDDjibzu8=
github.com/go-ole/go-ole v1.2.6 h1:/Fpf6oFPoeFik9ty7siob0G6Ke8QvQEuVcuChpwXzpY=
github.com/go-ole/go-ole v1.2.6/go.mod h1:pprOEPIfldk/42T2oK7lQ4v4JSDwmV0As9GaiUsvbm0=
github.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=
github.com/gobwas/httphead v0.0.0-20180130184737-2c6c146eadee/go.mod h1:L0fX3K22YWvt/FAX9NnzrNzcI4wNYi9Yku4O0LKYflo=
github.com/gobwas/pool v0.2.0/go.mod h1:q8bcK0KcYlCgd9e7WYLm9LpyS+YeLd8JVDW6WezmKEw=
github.com/gobwas/ws v1.0.2/go.mod h1:szmBTxLgaFppYjEmNtny/v3w89xOydFnnZMcgRRu/EM=
github.com/godbus/dbus/v5 v5.0.4 h1:9349emZab16e7zQvpmsbtjc18ykshndd8y2PG3sgJbA=
github.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
github.com/gogo/googleapis v0.0.0-20180223154316-0cd9801be74a/go.mod h1:gf4bu3Q80BeJ6H1S1vYPm8/ELATdvryBaNFGgqEef3s=
github.com/gogo/googleapis v1.4.1/go.mod h1:2lpHqI5OcWCtVElxXnPt+s8oJvMpySlOyM6xDCrzib4=
github.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=
github.com/gogo/protobuf v1.2.0/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=
github.com/gogo/protobuf v1.2.1/go.mod h1:hp+jE20tsWTFYpLwKvXlhS1hjn+gTNwPg2I6zVXpSg4=
github.com/gogo/protobuf v1.3.1/go.mod h1:SlYgWuQ5SjCEi6WLHjHCa1yvBfUnHcTbrrZtXPKa29o=
github.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=
github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=
github.com/gogo/status v1.1.0/go.mod h1:BFv9nrluPLmrS0EmGVvLaPNmRosr9KapBYd5/hpY1WM=
github.com/golang-jwt/jwt v3.2.2+incompatible/go.mod h1:8pz2t5EyA70fFQQSrl6XZXzqecmYZeUEB8OUGHkxJ+I=
github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
github.com/golang/glog v1.2.1 h1:OptwRhECazUx5ix5TTWC3EZhsZEHWcYWY4FQHTIubm4=
github.com/golang/glog v1.2.1/go.mod h1:6AhwSGph0fcJtXVM/PEHPqZlFeoLxhs7/t5UDAwmO+w=
github.com/golang/groupcache v0.0.0-20190129154638-5b532d6fd5ef/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
github.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=
github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
github.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=
github.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=
github.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=
github.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=
github.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=
github.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=
github.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
github.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=
github.com/golang/protobuf v1.5.1/go.mod h1:DopwsBzvsk0Fs44TXzsVbJyPhcCPeIwnvohx4u74HPM=
github.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=
github.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=
github.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=
github.com/gomodule/redigo v1.7.1-0.20190724094224-574c33c3df38/go.mod h1:B4C85qUVwatsJoIUNIfCRsp7qO0iAmpGFZ4EELWSbC4=
github.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
github.com/google/btree v1.0.1/go.mod h1:xXMiIv4Fb/0kKde4SpL7qlzvu5cMJDRkFDxJfI9uaxA=
github.com/google/btree v1.1.2 h1:xf4v41cLI2Z6FxbKm+8Bu+m8ifhj15JuZ9sa0jZCMUU=
github.com/google/btree v1.1.2/go.mod h1:qOPhT0dTNdNzV6Z/lhRX0YXUafgPLFUh+gZMl761Gm4=
github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
github.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.4/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.6/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/go-querystring v1.0.0/go.mod h1:odCYkC5MyYFN7vkCjXpyrEuKhc/BUO6wN/zVPAxq5ck=
github.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
github.com/google/gofuzz v1.2.0 h1:xRy4A+RhZaiKjJ1bPfwQ8sedCA+YS2YcCHW6ec7JMi0=
github.com/google/gofuzz v1.2.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=
github.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=
github.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=
github.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=
github.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=
github.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=
github.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=
github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
github.com/gorilla/websocket v1.4.1/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
github.com/gorilla/websocket v1.4.2 h1:+/TMaTYc4QFitKJxsQ7Yye35DkWvkdLcvGKqM+x0Ufc=
github.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
github.com/grpc-ecosystem/go-grpc-middleware v1.0.0/go.mod h1:FiyG127CGDf3tlThmgyCl78X/SZQqEOJBCDaAfeWzPs=
github.com/grpc-ecosystem/go-grpc-middleware v1.3.0 h1:+9834+KizmvFV7pXQGSXQTsaWhq2GjuNUt0aUU0YBYw=
github.com/grpc-ecosystem/go-grpc-middleware v1.3.0/go.mod h1:z0ButlSOZa5vEBq9m2m2hlwIgKw+rp3sdCBRoJY+30Y=
github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0 h1:Ovs26xHkKqVztRpIrF/92BcuyuQ/YW4NSIpoGtfXNho=
github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=
github.com/grpc-ecosystem/grpc-gateway v1.9.0/go.mod h1:vNeuVxBJEsws4ogUvrchl83t/GYV9WGTSLVdBhOQFDY=
github.com/grpc-ecosystem/grpc-gateway v1.16.0 h1:gmcG1KaJ57LophUzW0Hy8NmPhnMZb4M0+kPpLofRdBo=
github.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFbcEtjT1g+wF4CSlocrBnw=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.16.0 h1:YBftPWNWd4WwGqtY2yeZL2ef8rHAxPBD8KFhJpmcqms=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.16.0/go.mod h1:YN5jB8ie0yfIUg6VvR9Kz84aCaG7AsGZnLjhHbUqwPg=
github.com/hashicorp/consul/api v1.1.0/go.mod h1:VmuI/Lkw1nC05EYQWNKwWGbkg+FbDBtguAZLlVdkD9Q=
github.com/hashicorp/consul/sdk v0.1.1/go.mod h1:VKf9jXwCTEY1QZP2MOLRhb5i/I/ssyNV1vwHyQBF0x8=
github.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=
github.com/hashicorp/go-cleanhttp v0.5.1/go.mod h1:JpRdi6/HCYpAwUzNwuwqhbovhLtngrth3wmdIIUrZ80=
github.com/hashicorp/go-immutable-radix v1.0.0/go.mod h1:0y9vanUI8NX6FsYoO3zeMjhV/C5i9g4Q3DwcSNZ4P60=
github.com/hashicorp/go-msgpack v0.5.3/go.mod h1:ahLV/dePpqEmjfWmKiqvPkv/twdG7iPBM1vqhUKIvfM=
github.com/hashicorp/go-multierror v1.0.0/go.mod h1:dHtQlpGsu+cZNNAkkCN/P3hoUDHhCYQXV3UM06sGGrk=
github.com/hashicorp/go-rootcerts v1.0.0/go.mod h1:K6zTfqpRlCUIjkwsN4Z+hiSfzSTQa6eBIzfwKfwNnHU=
github.com/hashicorp/go-sockaddr v1.0.0/go.mod h1:7Xibr9yA9JjQq1JpNB2Vw7kxv8xerXegt+ozgdvDeDU=
github.com/hashicorp/go-syslog v1.0.0/go.mod h1:qPfqrKkXGihmCqbJM2mZgkZGvKG1dFdvsLplgctolz4=
github.com/hashicorp/go-uuid v1.0.0/go.mod h1:6SBZvOh/SIDV7/2o3Jml5SYk/TvGqwFJ/bN7x4byOro=
github.com/hashicorp/go-uuid v1.0.1/go.mod h1:6SBZvOh/SIDV7/2o3Jml5SYk/TvGqwFJ/bN7x4byOro=
github.com/hashicorp/go-version v1.2.0/go.mod h1:fltr4n8CU8Ke44wwGCBoEymUuxUHl09ZGVZPK5anwXA=
github.com/hashicorp/go.net v0.0.1/go.mod h1:hjKkEWcCURg++eb33jQU7oqQcI9XDCnUzHA0oac0k90=
github.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
github.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
github.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=
github.com/hashicorp/logutils v1.0.0/go.mod h1:QIAnNjmIWmVIIkWDTG1z5v++HQmx9WQRO+LraFDTW64=
github.com/hashicorp/mdns v1.0.0/go.mod h1:tL+uN++7HEJ6SQLQ2/p+z2pH24WQKWjBPkE0mNTz8vQ=
github.com/hashicorp/memberlist v0.1.3/go.mod h1:ajVTdAv/9Im8oMAAj5G31PhhMCZJV2pPBoIllUwCN7I=
github.com/hashicorp/serf v0.8.2/go.mod h1:6hOLApaqBFA1NXqRQAsxw9QxuDEvNxSQRwA/JwenrHc=
github.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=
github.com/hydrogen18/memlistener v0.0.0-20200120041712-dcc25e7acd91/go.mod h1:qEIFzExnS6016fRpRfxrExeVn2gbClQA99gQhnIcdhE=
github.com/imkira/go-interpol v1.1.0/go.mod h1:z0h2/2T3XF8kyEPpRgJ3kmNv+C43p+I/CoI+jC3w2iA=
github.com/inconshreveable/mousetrap v1.0.0/go.mod h1:PxqpIevigyE2G7u3NXJIT2ANytuPF1OarO4DADm73n8=
github.com/iris-contrib/blackfriday v2.0.0+incompatible/go.mod h1:UzZ2bDEoaSGPbkg6SAB4att1aAwTmVIx/5gCVqeyUdI=
github.com/iris-contrib/go.uuid v2.0.0+incompatible/go.mod h1:iz2lgM/1UnEf1kP0L/+fafWORmlnuysV2EMP8MW+qe0=
github.com/iris-contrib/jade v1.1.3/go.mod h1:H/geBymxJhShH5kecoiOCSssPX7QWYH7UaeZTSWddIk=
github.com/iris-contrib/pongo2 v0.0.1/go.mod h1:Ssh+00+3GAZqSQb30AvBRNxBx7rf0GqwkjqxNd0u65g=
github.com/iris-contrib/schema v0.0.1/go.mod h1:urYA3uvUNG1TIIjOSCzHr9/LmbQo8LrOcOqfqxa4hXw=
github.com/jonboulle/clockwork v0.1.0/go.mod h1:Ii8DK3G1RaLaWxj9trq07+26W01tbo22gdxWY5EU2bo=
github.com/jonboulle/clockwork v0.2.2 h1:UOGuzwb1PwsrDAObMuhUnj0p5ULPj8V/xJ7Kx9qUBdQ=
github.com/jonboulle/clockwork v0.2.2/go.mod h1:Pkfl5aHPm1nk2H9h0bjmnJD/BcgbGXUBGnn1kMkgxc8=
github.com/jpillora/backoff v1.0.0/go.mod h1:J/6gKK9jxlEcS3zixgDgUAsiuZ7yrSoa/FX5e0EB2j4=
github.com/json-iterator/go v1.1.6/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=
github.com/json-iterator/go v1.1.9/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=
github.com/json-iterator/go v1.1.10/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=
github.com/json-iterator/go v1.1.11/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=
github.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=
github.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=
github.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=
github.com/jtolds/gls v4.20.0+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=
github.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=
github.com/julienschmidt/httprouter v1.3.0/go.mod h1:JR6WtHb+2LUe8TCKY3cZOxFyyO8IZAc4RVcycCCAKdM=
github.com/k0kubun/colorstring v0.0.0-20150214042306-9440f1994b88/go.mod h1:3w7q1U84EfirKl04SVQ/s7nPm1ZPhiXd34z40TNz36k=
github.com/kataras/golog v0.0.10/go.mod h1:yJ8YKCmyL+nWjERB90Qwn+bdyBZsaQwU3bTVFgkFIp8=
github.com/kataras/iris/v12 v12.1.8/go.mod h1:LMYy4VlP67TQ3Zgriz8RE2h2kMZV2SgMYbq3UhfoFmE=
github.com/kataras/neffos v0.0.14/go.mod h1:8lqADm8PnbeFfL7CLXh1WHw53dG27MC3pgi2R1rmoTE=
github.com/kataras/pio v0.0.2/go.mod h1:hAoW0t9UmXi4R5Oyq5Z4irTbaTsOemSrDGUtaTl7Dro=
github.com/kataras/sitemap v0.0.5/go.mod h1:KY2eugMKiPwsJgx7+U103YZehfvNGOXURubcGyk0Bz8=
github.com/kisielk/errcheck v1.1.0/go.mod h1:EZBBE59ingxPouuu3KfxchcWSUPOHkagtvWXihfKN4Q=
github.com/kisielk/errcheck v1.2.0/go.mod h1:/BMXB+zMLi60iA8Vv6Ksmxu/1UDYcXs4uQLJ+jE2L00=
github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=
github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
github.com/klauspost/compress v1.8.2/go.mod h1:RyIbtBH6LamlWaDj8nUwkbUhJ87Yi3uG0guNDohfE1A=
github.com/klauspost/compress v1.9.7/go.mod h1:RyIbtBH6LamlWaDj8nUwkbUhJ87Yi3uG0guNDohfE1A=
github.com/klauspost/cpuid v1.2.1/go.mod h1:Pj4uuM528wm8OyEC2QMXAi2YiTZ96dNQPGgoMS4s3ek=
github.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
github.com/konsorten/go-windows-terminal-sequences v1.0.3/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
github.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=
github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
github.com/kr/pretty v0.3.0/go.mod h1:640gp4NfQd8pI5XOwp5fnNeVWj67G7CFk/SaSQn7NBk=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/labstack/echo/v4 v4.5.0/go.mod h1:czIriw4a0C1dFun+ObrXp7ok03xON0N1awStJ6ArI7Y=
github.com/labstack/gommon v0.3.0/go.mod h1:MULnywXg0yavhxWKc+lOruYdAhDwPK9wf0OL7NoOu+k=
github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 h1:6E+4a0GO5zZEnZ81pIr0yLvtUWk2if982qA3F3QD6H4=
github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0/go.mod h1:zJYVVT2jmtg6P3p1VtQj7WsuWi/y4VnjVBn7F8KPB3I=
github.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
github.com/magiconair/properties v1.8.1/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
github.com/mattn/go-colorable v0.0.9/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=
github.com/mattn/go-colorable v0.1.2/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=
github.com/mattn/go-colorable v0.1.8/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=
github.com/mattn/go-colorable v0.1.11/go.mod h1:u5H1YNBxpqRaxsYJYSkiCWKzEfiAb1Gb520KVy5xxl4=
github.com/mattn/go-isatty v0.0.3/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=
github.com/mattn/go-isatty v0.0.7/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=
github.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=
github.com/mattn/go-isatty v0.0.9/go.mod h1:YNRxwqDuOph6SZLI9vUUz6OYw3QyUt7WiY2yME+cCiQ=
github.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=
github.com/mattn/go-isatty v0.0.14/go.mod h1:7GGIvUiUoEMVVmxf/4nioHXj79iQHKdU27kJ6hsGG94=
github.com/mattn/goveralls v0.0.2/go.mod h1:8d1ZMHsd7fW6IRPKQh46F2WRpyib5/X4FOpevwGNQEw=
github.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=
github.com/matttproud/golang_protobuf_extensions v1.0.4 h1:mmDVorXM7PCGKw94cs5zkfA9PSy5pEvNWRP0ET0TIVo=
github.com/matttproud/golang_protobuf_extensions v1.0.4/go.mod h1:BSXmuO+STAnVfrANrmjBb36TMTDstsz7MSK+HVaYKv4=
github.com/mediocregopher/radix/v3 v3.4.2/go.mod h1:8FL3F6UQRXHXIBSPUs5h0RybMF8i4n7wVopoX3x7Bv8=
github.com/microcosm-cc/bluemonday v1.0.2/go.mod h1:iVP4YcDBq+n/5fb23BhYFvIMq/leAFZyRl6bYmGDlGc=
github.com/miekg/dns v1.0.14/go.mod h1:W1PPwlIAgtquWBMBEV9nkV9Cazfe8ScdGz/Lj7v3Nrg=
github.com/milvus-io/milvus-proto/go-api/v2 v2.5.11 h1:W+FHnglCc/ShYnrfzt+k0WU8uA9Ocx7jHb9ucSzhNlM=
github.com/milvus-io/milvus-proto/go-api/v2 v2.5.11/go.mod h1:/6UT4zZl6awVeXLeE7UGDWZvXj3IWkRsh3mqsn0DiAs=
github.com/milvus-io/milvus/pkg/v2 v2.5.7 h1:b45jq1s1v03AekFucs2/dkkXohB57gEx7gspJuAkfbY=
github.com/milvus-io/milvus/pkg/v2 v2.5.7/go.mod h1:pImw1IGNS7k/5yvlZV2tZi5vZu1VQRlQij+r39d+XnI=
github.com/mitchellh/cli v1.0.0/go.mod h1:hNIlj7HEI86fIcpObd7a0FcrxTWetlwJDGcceTlRvqc=
github.com/mitchellh/go-homedir v1.0.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=
github.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=
github.com/mitchellh/go-testing-interface v1.0.0/go.mod h1:kRemZodwjscx+RGhAo8eIhFbs2+BFgRtFPeD/KE+zxI=
github.com/mitchellh/gox v0.4.0/go.mod h1:Sd9lOJ0+aimLBi73mGofS1ycjY8lL3uZM3JPS42BGNg=
github.com/mitchellh/iochan v1.0.0/go.mod h1:JwYml1nuB7xOzsp52dPpHFffvOCDupsG0QubkSMEySY=
github.com/mitchellh/mapstructure v0.0.0-20160808181253-ca63d7c062ee/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=
github.com/mitchellh/mapstructure v1.1.2/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=
github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=
github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=
github.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=
github.com/modern-go/reflect2 v1.0.1/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=
github.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=
github.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=
github.com/moul/http2curl v1.0.0/go.mod h1:8UbvGypXm98wA/IqH45anm5Y2Z6ep6O31QGOAZ3H0fQ=
github.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=
github.com/mwitkow/go-conntrack v0.0.0-20190716064945-2f068394615f/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=
github.com/nats-io/jwt v0.3.0/go.mod h1:fRYCDE99xlTsqUzISS1Bi75UBJ6ljOJQOAAu5VglpSg=
github.com/nats-io/nats.go v1.9.1/go.mod h1:ZjDU1L/7fJ09jvUSRVBR2e7+RnLiiIQyqyzEE/Zbp4w=
github.com/nats-io/nkeys v0.1.0/go.mod h1:xpnFELMwJABBLVhffcfd1MZx6VsNRFpEugbxziKVo7w=
github.com/nats-io/nuid v1.0.1/go.mod h1:19wcPz3Ph3q0Jbyiqsd0kePYG7A95tJPxeL+1OSON2c=
github.com/oklog/ulid v1.3.1/go.mod h1:CirwcVhetQ6Lv90oh/F+FBtV6XMibvdAFo93nm5qn4U=
github.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
github.com/onsi/ginkgo v1.10.3/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=
github.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=
github.com/opencontainers/runtime-spec v1.0.2 h1:UfAcuLBJB9Coz72x1hgl8O5RVzTdNiaglX6v2DM6FI0=
github.com/opencontainers/runtime-spec v1.0.2/go.mod h1:jwyrGlmzljRJv/Fgzds9SsS/C5hL+LL3ko9hs6T5lQ0=
github.com/opentracing/opentracing-go v1.1.0/go.mod h1:UkNAQd3GIcIGf0SeVgPpRdFStlNbqXla1AfSYxPUl2o=
github.com/panjf2000/ants/v2 v2.7.2 h1:2NUt9BaZFO5kQzrieOmK/wdb/tQ/K+QHaxN8sOgD63U=
github.com/panjf2000/ants/v2 v2.7.2/go.mod h1:KIBmYG9QQX5U2qzFP/yQJaq/nSb6rahS9iEHkrCMgM8=
github.com/pascaldekloe/goe v0.0.0-20180627143212-57f6aae5913c/go.mod h1:lzWF7FIEvWOWxwDKqyGYQf6ZUaNfKdP144TG7ZOy1lc=
github.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=
github.com/pingcap/errors v0.11.4/go.mod h1:Oi8TUi2kEtXXLMJk9l1cGmz20kV3TaQ0usTwv5KuLY8=
github.com/pingcap/errors v0.11.5-0.20211224045212-9687c2b0f87c h1:xpW9bvK+HuuTmyFqUwr+jcCvpVkK7sumiz+ko5H9eq4=
github.com/pingcap/errors v0.11.5-0.20211224045212-9687c2b0f87c/go.mod h1:X2r9ueLEUZgtx2cIogM0v4Zj5uvvzhuuiu7Pn8HzMPg=
github.com/pkg/diff v0.0.0-20210226163009-20ebb0f2a09e/go.mod h1:pJLUxLENpZxwdsKMEsNbx1VGcRFpLqf3715MtcvvzbA=
github.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/posener/complete v1.1.1/go.mod h1:em0nMJCgc9GFtwrmVmEMR/ZL6WyhyjMBndrE9hABlRI=
github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c h1:ncq/mPwQF4JjgDlrVEn3C11VoGHZN7m8qihwgMEtzYw=
github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c/go.mod h1:OmDBASR4679mdNQnz2pUhc2G8CO2JrUAVFDRBDP/hJE=
github.com/prashantv/gostub v1.1.0 h1:BTyx3RfQjRHnUWaGF9oQos79AlQ5k8WNktv7VGvVH4g=
github.com/prashantv/gostub v1.1.0/go.mod h1:A5zLQHz7ieHGG7is6LLXLz7I8+3LZzsrV0P1IAHhP5U=
github.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=
github.com/prometheus/client_golang v0.9.3/go.mod h1:/TN21ttK/J9q6uSwhBd54HahCDft0ttaMvbicHlPoso=
github.com/prometheus/client_golang v1.0.0/go.mod h1:db9x61etRT2tGnBNRi70OPL5FsnadC4Ky3P0J6CfImo=
github.com/prometheus/client_golang v1.7.1/go.mod h1:PY5Wy2awLA44sXw4AOSfFBetzPP4j5+D6mVACh+pe2M=
github.com/prometheus/client_golang v1.11.1/go.mod h1:Z6t4BnS23TR94PD6BsDNk8yVqroYurpAkEiz0P2BEV0=
github.com/prometheus/client_golang v1.14.0 h1:nJdhIvne2eSX/XRAFV9PcvFFRbrjbcTUj0VP62TMhnw=
github.com/prometheus/client_golang v1.14.0/go.mod h1:8vpkKitgIVNcqrRBWh1C4TIUQgYNtG/XQE4E/Zae36Y=
github.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=
github.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/prometheus/client_model v0.2.0/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
github.com/prometheus/client_model v0.5.0 h1:VQw1hfvPvk3Uv6Qf29VrPF32JB6rtbgI6cYPYQjL0Qw=
github.com/prometheus/client_model v0.5.0/go.mod h1:dTiFglRmd66nLR9Pv9f0mZi7B7fk5Pm3gvsjB5tr+kI=
github.com/prometheus/common v0.0.0-20181113130724-41aa239b4cce/go.mod h1:daVV7qP5qjZbuso7PdcryaAu0sAZbrN9i7WWcTMWvro=
github.com/prometheus/common v0.4.0/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=
github.com/prometheus/common v0.4.1/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=
github.com/prometheus/common v0.10.0/go.mod h1:Tlit/dnDKsSWFlCLTWaA1cyBgKHSMdTB80sz/V91rCo=
github.com/prometheus/common v0.26.0/go.mod h1:M7rCNAaPfAosfx8veZJCuw84e35h3Cfd9VFqTh1DIvc=
github.com/prometheus/common v0.42.0 h1:EKsfXEYo4JpWMHH5cg+KOUWeuJSov1Id8zGR8eeI1YM=
github.com/prometheus/common v0.42.0/go.mod h1:xBwqVerjNdUDjgODMpudtOMwlOwf2SaTr1yjz4b7Zbc=
github.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=
github.com/prometheus/procfs v0.0.0-20190507164030-5867b95ac084/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=
github.com/prometheus/procfs v0.0.2/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=
github.com/prometheus/procfs v0.1.3/go.mod h1:lV6e/gmhEcM9IjHGsFOCxxuZ+z1YqCvr4OA4YeYWdaU=
github.com/prometheus/procfs v0.6.0/go.mod h1:cz+aTbrPOrUb4q7XlbU9ygM+/jj0fzG6c1xBZuNvfVA=
github.com/prometheus/procfs v0.9.0 h1:wzCHvIvM5SxWqYvwgVL7yJY8Lz3PKn49KQtpgMYJfhI=
github.com/prometheus/procfs v0.9.0/go.mod h1:+pB4zwohETzFnmlpe6yd2lSc+0/46IYZRB/chUwxUZY=
github.com/prometheus/tsdb v0.7.1/go.mod h1:qhTCs0VvXwvX/y3TZrWD7rabWM+ijKTux40TwIPHuXU=
github.com/quasilyte/go-ruleguard/dsl v0.3.22 h1:wd8zkOhSNr+I+8Qeciml08ivDt1pSXe60+5DqOpCjPE=
github.com/quasilyte/go-ruleguard/dsl v0.3.22/go.mod h1:KeCP03KrjuSO0H1kTuZQCWlQPulDV6YMIXmpQss17rU=
github.com/rogpeppe/fastuuid v0.0.0-20150106093220-6724a57986af/go.mod h1:XWv6SoW27p1b0cqNHllgS5HIMJraePCO15w5zCzIWYg=
github.com/rogpeppe/fastuuid v1.2.0/go.mod h1:jVj6XXZzXRy/MSR5jhDC/2q6DgLz+nrA6LYCDYWNEvQ=
github.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=
github.com/rogpeppe/go-internal v1.6.1/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=
github.com/rogpeppe/go-internal v1.8.1/go.mod h1:JeRgkft04UBgHMgCIwADu4Pn6Mtm5d4nPKWu0nJ5d+o=
github.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=
github.com/rogpeppe/go-internal v1.12.0 h1:exVL4IDcn6na9z1rAb56Vxr+CgyK3nn3O+epU5NdKM8=
github.com/rogpeppe/go-internal v1.12.0/go.mod h1:E+RYuTGaKKdloAfM02xzb0FW3Paa99yedzYV+kq4uf4=
github.com/russross/blackfriday v1.5.2/go.mod h1:JO/DiYxRf+HjHt06OyowR9PTA263kcR/rfWxYHBV53g=
github.com/russross/blackfriday/v2 v2.0.1/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/ryanuber/columnize v0.0.0-20160712163229-9b3edd62028f/go.mod h1:sm1tb6uqfes/u+d4ooFouqFdy9/2g9QGwK3SQygK0Ts=
github.com/ryanuber/columnize v2.1.0+incompatible/go.mod h1:sm1tb6uqfes/u+d4ooFouqFdy9/2g9QGwK3SQygK0Ts=
github.com/samber/lo v1.27.0 h1:GOyDWxsblvqYobqsmUuMddPa2/mMzkKyojlXol4+LaQ=
github.com/samber/lo v1.27.0/go.mod h1:it33p9UtPMS7z72fP4gw/EIfQB2eI8ke7GR2wc6+Rhg=
github.com/schollz/closestmatch v2.1.0+incompatible/go.mod h1:RtP1ddjLong6gTkbtmuhtR2uUrrJOpYzYRvbcPAid+g=
github.com/sean-/seed v0.0.0-20170313163322-e2103e2c3529/go.mod h1:DxrIzT+xaE7yg65j358z/aeFdxmN0P9QXhEzd20vsDc=
github.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAmXWZgo=
github.com/shirou/gopsutil/v3 v3.22.9 h1:yibtJhIVEMcdw+tCTbOPiF1VcsuDeTE4utJ8Dm4c5eA=
github.com/shirou/gopsutil/v3 v3.22.9/go.mod h1:bBYl1kjgEJpWpxeHmLI+dVHWtyAwfcmSBLDsp2TNT8A=
github.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=
github.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=
github.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=
github.com/sirupsen/logrus v1.6.0/go.mod h1:7uNnSEd1DgxDLC74fIahvMZmmYsHGZGEOFrfsX/uA88=
github.com/sirupsen/logrus v1.7.0/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=
github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=
github.com/smartystreets/goconvey v1.6.4/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=
github.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=
github.com/soheilhy/cmux v0.1.5 h1:jjzc5WVemNEDTLwv9tlmemhC73tI08BNOIGwBOo10Js=
github.com/soheilhy/cmux v0.1.5/go.mod h1:T7TcVDs9LWfQgPlPsdngu6I6QIoyIFZDDC6sNE1GqG0=
github.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=
github.com/spaolacci/murmur3 v1.1.0 h1:7c1g84S4BPRrfL5Xrdp6fOJ206sU9y293DDHaoy0bLI=
github.com/spaolacci/murmur3 v1.1.0/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=
github.com/spf13/afero v1.1.2/go.mod h1:j4pytiNVoe2o6bmDsKpLACNPDBIoEAkihy7loJ1B0CQ=
github.com/spf13/cast v1.3.0/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=
github.com/spf13/cast v1.3.1 h1:nFm6S0SMdyzrzcmThSipiEubIDy8WEXKNZ0UOgiRpng=
github.com/spf13/cast v1.3.1/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=
github.com/spf13/cobra v0.0.5/go.mod h1:3K3wKZymM7VvHMDS9+Akkh4K60UwM26emMESw8tLCHU=
github.com/spf13/cobra v1.1.3/go.mod h1:pGADOWyqRD/YMrPZigI/zbliZ2wVD/23d+is3pSWzOo=
github.com/spf13/jwalterweatherman v1.0.0/go.mod h1:cQK4TGJAtQXfYWX+Ddv3mKDzgVb68N+wFjFa4jdeBTo=
github.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=
github.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=
github.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/spf13/viper v1.3.2/go.mod h1:ZiWeW+zYFKm7srdB9IoDzzZXaJaI5eL9QjNiN/DMA2s=
github.com/spf13/viper v1.7.0/go.mod h1:8WkrPz2fc9jxqZNCJI/76HCieCp4Q8HaLFoCha5qpdg=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/subosito/gotenv v1.2.0/go.mod h1:N0PQaV/YGNqwC0u51sEeR/aUtSLEXKX9iv69rRypqCw=
github.com/thoas/go-funk v0.9.1 h1:O549iLZqPpTUQ10ykd26sZhzD+rmR5pWhuElrhbC20M=
github.com/thoas/go-funk v0.9.1/go.mod h1:+IWnUfUmFO1+WVYQWQtIJHeRRdaIyyYglZN7xzUPe4Q=
github.com/tidwall/gjson v1.17.1 h1:wlYEnwqAHgzmhNUFfw7Xalt2JzQvsMx2Se4PcoFCT/U=
github.com/tidwall/gjson v1.17.1/go.mod h1:/wbyibRr2FHMks5tjHJ5F8dMZh3AcwJEMf5vlfC0lxk=
github.com/tidwall/match v1.1.1 h1:+Ho715JplO36QYgwN9PGYNhgZvoUSc9X2c80KVTi+GA=
github.com/tidwall/match v1.1.1/go.mod h1:eRSPERbgtNPcGhD8UCthc6PmLEQXEWd3PRB5JTxsfmM=
github.com/tidwall/pretty v1.2.0 h1:RWIZEg2iJ8/g6fDDYzMpobmaoGh5OLl4AXtGUGPcqCs=
github.com/tidwall/pretty v1.2.0/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=
github.com/tklauser/go-sysconf v0.3.10 h1:IJ1AZGZRWbY8T5Vfk04D9WOA5WSejdflXxP03OUqALw=
github.com/tklauser/go-sysconf v0.3.10/go.mod h1:C8XykCvCb+Gn0oNCWPIlcb0RuglQTYaQ2hGm7jmxEFk=
github.com/tklauser/numcpus v0.4.0 h1:E53Dm1HjH1/R2/aoCtXtPgzmElmn51aOkhCFSuZq//o=
github.com/tklauser/numcpus v0.4.0/go.mod h1:1+UI3pD8NW14VMwdgJNJ1ESk2UnwhAnz5hMwiKKqXCQ=
github.com/tmc/grpc-websocket-proxy v0.0.0-20190109142713-0ad062ec5ee5/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=
github.com/tmc/grpc-websocket-proxy v0.0.0-20201229170055-e5319fda7802 h1:uruHq4dN7GR16kFc5fp3d1RIYzJW5onx8Ybykw2YQFA=
github.com/tmc/grpc-websocket-proxy v0.0.0-20201229170055-e5319fda7802/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=
github.com/uber/jaeger-client-go v2.30.0+incompatible h1:D6wyKGCecFaSRUpo8lCVbaOOb6ThwMmTEbhRwtKR97o=
github.com/uber/jaeger-client-go v2.30.0+incompatible/go.mod h1:WVhlPFC8FDjOFMMWRy2pZqQJSXxYSwNYOkTr/Z6d3Kk=
github.com/ugorji/go v1.1.4/go.mod h1:uQMGLiO92mf5W77hV/PUCpI3pbzQx3CRekS0kk+RGrc=
github.com/ugorji/go v1.1.7/go.mod h1:kZn38zHttfInRq0xu/PH0az30d+z6vm202qpg1oXVMw=
github.com/ugorji/go/codec v0.0.0-20181204163529-d75b2dcb6bc8/go.mod h1:VFNgLljTbGfSG7qAOspJ7OScBnGdDN/yBr0sguwnwf0=
github.com/ugorji/go/codec v1.1.7/go.mod h1:Ax+UKWsSmolVDwsd+7N3ZtXu+yMGCf907BLYF3GoBXY=
github.com/urfave/negroni v1.0.0/go.mod h1:Meg73S6kFm/4PpbYdq35yYWoCZ9mS/YSx+lKnmiohz4=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/fasthttp v1.6.0/go.mod h1:FstJa9V+Pj9vQ7OJie2qMHdwemEDaDiSdBnvPM1Su9w=
github.com/valyala/fasttemplate v1.0.1/go.mod h1:UQGH1tvbgY+Nz5t2n7tXsz52dQxojPUpymEIMZ47gx8=
github.com/valyala/fasttemplate v1.2.1/go.mod h1:KHLXt3tVN2HBp8eijSv/kGJopbvo7S+qRAEEKiv+SiQ=
github.com/valyala/tcplisten v0.0.0-20161114210144-ceec8f93295a/go.mod h1:v3UYOV9WzVtRmSR+PDvWpU/qWl4Wa5LApYYX4ZtKbio=
github.com/x448/float16 v0.8.4 h1:qLwI1I70+NjRFUR3zs1JPUCgaCXSh3SW62uAKT1mSBM=
github.com/x448/float16 v0.8.4/go.mod h1:14CWIYCyZA/cWjXOioeEpHeN/83MdbZDRQHoFcYsOfg=
github.com/xeipuuv/gojsonpointer v0.0.0-20180127040702-4e3ac2762d5f/go.mod h1:N2zxlSyiKSe5eX1tZViRH5QA0qijqEDrYZiPEAiq3wU=
github.com/xeipuuv/gojsonreference v0.0.0-20180127040603-bd5ef7bd5415/go.mod h1:GwrjFmJcFw6At/Gs6z4yjiIwzuJ1/+UwLxMQDVQXShQ=
github.com/xeipuuv/gojsonschema v1.2.0/go.mod h1:anYRn/JVcOK2ZgGU+IjEV4nwlhoK5sQluxsYJ78Id3Y=
github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2 h1:eY9dn8+vbi4tKz5Qo6v2eYzo7kUS51QINcR5jNpbZS8=
github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=
github.com/xordataexchange/crypt v0.0.3-0.20170626215501-b2862e3d0a77/go.mod h1:aYKd//L2LvnjZzWKhF00oedf4jCCReLcmhLdhm1A27Q=
github.com/yalp/jsonpath v0.0.0-20180802001716-5cc68e5049a0/go.mod h1:/LWChgwKmvncFJFHJ7Gvn9wZArjbV5/FppcK2fKk/tI=
github.com/yudai/gojsondiff v1.0.0/go.mod h1:AY32+k2cwILAkW1fbgxQ5mUmMiZFgLIV+FBNExI05xg=
github.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82/go.mod h1:lgjkn3NuSvDfVJdfcVVdX+jpBxNmX4rDAzaS45IcYoM=
github.com/yudai/pp v2.0.1+incompatible/go.mod h1:PuxR/8QJ7cyCkFp/aUDS+JY727OFEZkTdatxwunjIkc=
github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=
github.com/yusufpapurcu/wmi v1.2.2 h1:KBNDSne4vP5mbSWnJbO+51IMOXJB67QiYCSBrubbPRg=
github.com/yusufpapurcu/wmi v1.2.2/go.mod h1:SBZ9tNy3G9/m5Oi98Zks0QjeHVDvuK0qfxQmPyzfmi0=
go.etcd.io/bbolt v1.3.2/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=
go.etcd.io/bbolt v1.3.6 h1:/ecaJf0sk1l4l6V4awd65v2C3ILy7MSj+s/x1ADCIMU=
go.etcd.io/bbolt v1.3.6/go.mod h1:qXsaaIqmgQH0T+OPdb99Bf+PKfBBQVAdyD6TY9G8XM4=
go.etcd.io/etcd/api/v3 v3.5.5 h1:BX4JIbQ7hl7+jL+g+2j5UAr0o1bctCm6/Ct+ArBGkf0=
go.etcd.io/etcd/api/v3 v3.5.5/go.mod h1:KFtNaxGDw4Yx/BA4iPPwevUTAuqcsPxzyX8PHydchN8=
go.etcd.io/etcd/client/pkg/v3 v3.5.5 h1:9S0JUVvmrVl7wCF39iTQthdaaNIiAaQbmK75ogO6GU8=
go.etcd.io/etcd/client/pkg/v3 v3.5.5/go.mod h1:ggrwbk069qxpKPq8/FKkQ3Xq9y39kbFR4LnKszpRXeQ=
go.etcd.io/etcd/client/v2 v2.305.5 h1:DktRP60//JJpnPC0VBymAN/7V71GHMdjDCBt4ZPXDjI=
go.etcd.io/etcd/client/v2 v2.305.5/go.mod h1:zQjKllfqfBVyVStbt4FaosoX2iYd8fV/GRy/PbowgP4=
go.etcd.io/etcd/client/v3 v3.5.5 h1:q++2WTJbUgpQu4B6hCuT7VkdwaTP7Qz6Daak3WzbrlI=
go.etcd.io/etcd/client/v3 v3.5.5/go.mod h1:aApjR4WGlSumpnJ2kloS75h6aHUmAyaPLjHMxpc7E7c=
go.etcd.io/etcd/pkg/v3 v3.5.5 h1:Ablg7T7OkR+AeeeU32kdVhw/AGDsitkKPl7aW73ssjU=
go.etcd.io/etcd/pkg/v3 v3.5.5/go.mod h1:6ksYFxttiUGzC2uxyqiyOEvhAiD0tuIqSZkX3TyPdaE=
go.etcd.io/etcd/raft/v3 v3.5.5 h1:Ibz6XyZ60OYyRopu73lLM/P+qco3YtlZMOhnXNS051I=
go.etcd.io/etcd/raft/v3 v3.5.5/go.mod h1:76TA48q03g1y1VpTue92jZLr9lIHKUNcYdZOOGyx8rI=
go.etcd.io/etcd/server/v3 v3.5.5 h1:jNjYm/9s+f9A9r6+SC4RvNaz6AqixpOvhrFdT0PvIj0=
go.etcd.io/etcd/server/v3 v3.5.5/go.mod h1:rZ95vDw/jrvsbj9XpTqPrTAB9/kzchVdhRirySPkUBc=
go.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=
go.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.25.0/go.mod h1:E5NNboN0UqSAki0Atn9kVwaN7I+l25gGxDqBueo/74E=
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0 h1:4Pp6oUg3+e/6M4C0A/3kJ2VYa++dsWVTtGgLVj5xtHg=
go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.49.0/go.mod h1:Mjt1i1INqiaoZOMGR1RIUJN+i3ChKoFRqzrRQhlkbs0=
go.opentelemetry.io/otel v1.0.1/go.mod h1:OPEOD4jIT2SlZPMmwT6FqZz2C0ZNdQqiWcoK6M0SNFU=
go.opentelemetry.io/otel v1.28.0 h1:/SqNcYk+idO0CxKEUOtKQClMK/MimZihKYMruSMViUo=
go.opentelemetry.io/otel v1.28.0/go.mod h1:q68ijF8Fc8CnMHKyzqL6akLO46ePnjkgfIMIjUIX9z4=
go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.0.1/go.mod h1:Kv8liBeVNFkkkbilbgWRpV+wWuu+H5xdOT6HAgd30iw=
go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.20.0 h1:DeFD0VgTZ+Cj6hxravYYZE2W4GlneVH81iAOPjZkzk8=
go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.20.0/go.mod h1:GijYcYmNpX1KazD5JmWGsi4P7dDTTTnfv1UbGn84MnU=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.0.1/go.mod h1:xOvWoTOrQjxjW61xtOmD/WKGRYb/P4NzRo3bs65U6Rk=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.20.0 h1:gvmNvqrPYovvyRmCSygkUDyL8lC5Tl845MLEwqpxhEU=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.20.0/go.mod h1:vNUq47TGFioo+ffTSnKNdob241vePmtNZnAODKapKd0=
go.opentelemetry.io/otel/metric v1.28.0 h1:f0HGvSl1KRAU1DLgLGFjrwVyismPlnuU6JD6bOeuA5Q=
go.opentelemetry.io/otel/metric v1.28.0/go.mod h1:Fb1eVBFZmLVTMb6PPohq3TO9IIhUisDsbJoL/+uQW4s=
go.opentelemetry.io/otel/sdk v1.0.1/go.mod h1:HrdXne+BiwsOHYYkBE5ysIcv2bvdZstxzmCQhxTcZkI=
go.opentelemetry.io/otel/sdk v1.28.0 h1:b9d7hIry8yZsgtbmM0DKyPWMMUMlK9NEKuIG4aBqWyE=
go.opentelemetry.io/otel/sdk v1.28.0/go.mod h1:oYj7ClPUA7Iw3m+r7GeEjz0qckQRJK2B8zjcZEfu7Pg=
go.opentelemetry.io/otel/trace v1.0.1/go.mod h1:5g4i4fKLaX2BQpSBsxw8YYcgKpMMSW3x7ZTuYBr3sUk=
go.opentelemetry.io/otel/trace v1.28.0 h1:GhQ9cUuQGmNDd5BTCP2dAvv75RdMxEfTmYejp+lkx9g=
go.opentelemetry.io/otel/trace v1.28.0/go.mod h1:jPyXzNPg6da9+38HEwElrQiHlVMTnVfM3/yv2OlIHaI=
go.opentelemetry.io/proto/otlp v0.7.0/go.mod h1:PqfVotwruBrMGOCsRd/89rSnXhoiJIqeYNgFYFoEGnI=
go.opentelemetry.io/proto/otlp v0.9.0/go.mod h1:1vKfU9rv61e9EVGthD1zNvUbiwPcimSsOPU9brfSHJg=
go.opentelemetry.io/proto/otlp v1.0.0 h1:T0TX0tmXU8a3CbNXzEKGeU5mIVOdf0oykP+u2lIVU/I=
go.opentelemetry.io/proto/otlp v1.0.0/go.mod h1:Sy6pihPLfYHkr3NkUbEhGHFhINUSI/v80hjKIs5JXpM=
go.uber.org/atomic v1.4.0/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=
go.uber.org/atomic v1.7.0/go.mod h1:fEN4uk6kAWBTFdckzkM89CLk9XfWZrxpCo0nPH17wJc=
go.uber.org/atomic v1.11.0 h1:ZvwS0R+56ePWxUNi+Atn9dWONBPp/AUETXlHW0DxSjE=
go.uber.org/atomic v1.11.0/go.mod h1:LUxbIzbOniOlMKjJjyPfpl4v+PKK2cNJn91OQbhoJI0=
go.uber.org/automaxprocs v1.5.3 h1:kWazyxZUrS3Gs4qUpbwo5kEIMGe/DAvi5Z4tl2NW4j8=
go.uber.org/automaxprocs v1.5.3/go.mod h1:eRbA25aqJrxAbsLO0xy5jVwPt7FQnRgjW+efnwa1WM0=
go.uber.org/goleak v1.3.0 h1:2K3zAYmnTNqV73imy9J1T3WC+gmCePx2hEGkimedGto=
go.uber.org/goleak v1.3.0/go.mod h1:CoHD4mav9JJNrW/WLlf7HGZPjdw8EucARQHekz1X6bE=
go.uber.org/multierr v1.1.0/go.mod h1:wR5kodmAFQ0UK8QlbwjlSNy0Z68gJhDJUG5sjR94q/0=
go.uber.org/multierr v1.6.0/go.mod h1:cdWPpRnG4AhwMwsgIHip0KRBQjJy5kYEpYjJxpXp9iU=
go.uber.org/multierr v1.11.0 h1:blXXJkSxSSfBVBlC76pxqeO+LN3aDfLQo+309xJstO0=
go.uber.org/multierr v1.11.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=
go.uber.org/zap v1.10.0/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=
go.uber.org/zap v1.17.0/go.mod h1:MXVU+bhUf/A7Xi2HNOnopQOrmycQ5Ih87HtOu4q5SSo=
go.uber.org/zap v1.27.0 h1:aJMhYGrd5QSmlpLMr2MftRKl7t8J8PTZPA732ud/XR8=
go.uber.org/zap v1.27.0/go.mod h1:GB2qFLM7cTU87MWRP2mPIjqfIDnGu+VIO4V/SdhGo2E=
golang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=
golang.org/x/crypto v0.0.0-20181029021203-45a5f77698d3/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=
golang.org/x/crypto v0.0.0-20181203042331-505ab145d0a9/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20190701094942-4def268fd1a4/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20191227163750-53104e6ec876/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20210322153248-0c34fe9e7dc2/go.mod h1:T9bdIzuCu7OtxOm1hfPfRQxPLYneinmdGuTeoZ9dtd4=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.0.0-20220411220226-7b82a4e95df4/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
golang.org/x/crypto v0.35.0 h1:b15kiHdrGCHrP6LvwaQ3c03kgNhhiMgvlhxHQhmg2Xs=
golang.org/x/crypto v0.35.0/go.mod h1:dy7dXNW32cAb/6/PRuTNsix8T+vJAqvuIy5Bli/x0YQ=
golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
golang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=
golang.org/x/exp v0.0.0-20190829153037-c13cbed26979/go.mod h1:86+5VVa7VpoJ4kLfm080zCjGlMRFzhUhsZKEZO7MGek=
golang.org/x/exp v0.0.0-20191030013958-a1ab85dbe136/go.mod h1:JXzH8nQsPlswgeRAPE3MuO9GYsAcnJvJ4vnMwN/5qkY=
golang.org/x/exp v0.0.0-20240506185415-9bf2ced13842 h1:vr/HnozRka3pE4EsMEg1lgkXJkTFJCVUX+S/ZT6wYzM=
golang.org/x/exp v0.0.0-20240506185415-9bf2ced13842/go.mod h1:XtvwrStGgqGPLc4cjQfWqZHG1YFdYs6swckp8vpsjnc=
golang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=
golang.org/x/image v0.0.0-20190802002840-cff245a6509b/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=
golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=
golang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20190909230951-414d861bb4ac/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
golang.org/x/lint v0.0.0-20210508222113-6edffad5e616/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
golang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=
golang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCcRqshq8CkpyQDoeVncDDYHnLhea+o=
golang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=
golang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=
golang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=
golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20181023162649-9b4f9f5ad519/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20181201002055-351d144fa1fc/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20181220203305-927f97764cc3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190327091125-710a502c58a2/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=
golang.org/x/net v0.0.0-20190613194153-d28f0bde5980/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20190827160401-ba9fcec4b297/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200625001655-4c5254603344/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
golang.org/x/net v0.0.0-20200822124328-c89045814202/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=
golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20201202161906-c7110b5ffcbb/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=
golang.org/x/net v0.0.0-20211008194852-3b03d305991f/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.36.0 h1:vWF2fRbw4qslQsQzgFqZff+BItCvGFQqKzKIzx1rmoA=
golang.org/x/net v0.36.0/go.mod h1:bFmbeoIPfrw4sMHNhb4J9f6+tPziuGjq7Jk/38fxi1I=
golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.11.0 h1:GGz8+XQP4FvTTrjZPzNKTMFtSXH80RAzG+5ghFPgK9w=
golang.org/x/sync v0.11.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sys v0.0.0-20180823144017-11551d06cbcc/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20181026203630-95b1ffbd15a5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20181107165924-66b7b1311ac8/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20181205085412-a5c9d58dba9a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190626221950-04f50cda93cb/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190813064441-fde4db37ae7a/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190916202348-b4ddaad3f8a3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200106162015-b016eb3dc98e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200615200032-f1bc736245b1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200625212154-ddb9806d33ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200923182605-d9f96fdee20d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201204225414-ed752295db88/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210124154548-22da62e12c0c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210403161142-5e06dd20ab57/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423185535-09eb48e85fd7/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210603081109-ebe580a85c40/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210927094055-39ccf1dd6fa6/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20211007075335-d3039528d8ac/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220128215802-99c3d69c2c27/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220209214540-3681064d5158/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.30.0 h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc=
golang.org/x/sys v0.30.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.5/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.22.0 h1:bofq7m3/HAFvbF51jz3Q9wLg3jkvSPuiZu/pD1XwgtM=
golang.org/x/text v0.22.0/go.mod h1:YRoo4H8PVmsu+E3Ou7cqLVH8oXWIHVoX0jqUWALQhfY=
golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.0.0-20201208040808-7e3f01d25324/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.0.0-20210220033141-f8bda1e9f3ba/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/time v0.5.0 h1:o7cqy6amK/52YcAKIPlM3a+Fpj35zvRj2TP+e1xFSfk=
golang.org/x/time v0.5.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=
golang.org/x/tools v0.0.0-20180221164845-07fd8470d635/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20181030221726-6c7e314b6563/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20181221001348-537d06c36207/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190327201419-c70d86f8b7cf/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190328211700-ab21143f2384/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
golang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20190506145303-2d16b83fe98c/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
golang.org/x/tools v0.0.0-20190606124116-d0a3d012864b/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
golang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
golang.org/x/tools v0.0.0-20190628153133-6cdbf07be9d0/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
golang.org/x/tools v0.0.0-20190816200558-6889da9d5479/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20190911174233-4f2ddba30aff/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191012152004-8de300cfc20a/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191112195655-aa38f8e97acc/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
golang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.1.2/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=
golang.org/x/tools v0.1.3/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=
google.golang.org/api v0.7.0/go.mod h1:WtwebWUNSVBH/HAw79HIFXZNqEvBhG+Ra+ax0hx3E3M=
google.golang.org/api v0.8.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=
google.golang.org/api v0.9.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=
google.golang.org/api v0.13.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
google.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=
google.golang.org/genproto v0.0.0-20180518175338-11a468237815/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
google.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190418145605-e7d98fc518a7/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190502173448-54afdca5d873/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
google.golang.org/genproto v0.0.0-20190801165951-fa694d86fc64/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
google.golang.org/genproto v0.0.0-20190911173649-1774047e7e51/go.mod h1:IbNlFCBrqXvoKpeg0TB2l7cyZUmoaFKYIwrEpbDKLA8=
google.golang.org/genproto v0.0.0-20191108220845-16a3f7862a1a/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
google.golang.org/genproto v0.0.0-20200423170343-7949de9c1215/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200513103714-09dca8ec2884/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
google.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=
google.golang.org/genproto v0.0.0-20210602131652-f16073e35f0c/go.mod h1:UODoCrxHCcBojKKwX1terBiRUaqAsFqJiF615XL43r0=
google.golang.org/genproto v0.0.0-20210624195500-8bfb893ecb84/go.mod h1:SzzZ/N+nwJDaO1kznhnlzqS8ocJICar6hYhVyhi++24=
google.golang.org/genproto v0.0.0-20231106174013-bbf56f31fb17 h1:wpZ8pe2x1Q3f2KyT5f8oP/fa9rHAKgFPr/HZdNuS+PQ=
google.golang.org/genproto v0.0.0-20231106174013-bbf56f31fb17/go.mod h1:J7XzRzVy1+IPwWHZUzoD0IccYZIrXILAQpc+Qy9CMhY=
google.golang.org/genproto/googleapis/api v0.0.0-20240528184218-531527333157 h1:7whR9kGa5LUwFtpLm2ArCEejtnxlGeLbAyjFY8sGNFw=
google.golang.org/genproto/googleapis/api v0.0.0-20240528184218-531527333157/go.mod h1:99sLkeliLXfdj2J75X3Ho+rrVCaJze0uwN7zDDkjPVU=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240730163845-b1a4ccb954bf h1:liao9UHurZLtiEwBgT9LMOnKYsHze6eA6w1KQCMVN2Q=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240730163845-b1a4ccb954bf/go.mod h1:Ue6ibwXGpU+dqIcODieyLOcgj7z8+IcskoNIgZxtrFY=
google.golang.org/grpc v1.12.0/go.mod h1:yo6s7OP7yaDglbqo1J04qKzAhqBH6lvTonzMVmEdcZw=
google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
google.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=
google.golang.org/grpc v1.21.1/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=
google.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=
google.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=
google.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
google.golang.org/grpc v1.29.1/go.mod h1:itym6AZVZYACWQqET3MqgPpjcuV5QH3BxFS3IjizoKk=
google.golang.org/grpc v1.33.1/go.mod h1:fr5YgcSWrqhRRxogOsw7RzIpsmvOZ6IcH4kBYTpR3n0=
google.golang.org/grpc v1.36.0/go.mod h1:qjiiYl8FncCW8feJPdyg3v6XW24KsRHe+dy9BAGRRjU=
google.golang.org/grpc v1.37.1/go.mod h1:NREThFqKR1f3iQ6oBuvc5LadQuXVGo9rkm5ZGrQdJfM=
google.golang.org/grpc v1.38.0/go.mod h1:NREThFqKR1f3iQ6oBuvc5LadQuXVGo9rkm5ZGrQdJfM=
google.golang.org/grpc v1.40.0/go.mod h1:ogyxbiOoUXAkP+4+xa6PZSE9DZgIHtSpzjDTB9KAK34=
google.golang.org/grpc v1.41.0/go.mod h1:U3l9uK9J0sini8mHphKoXyaqDA/8VyGnDee1zzIUK6k=
google.golang.org/grpc v1.65.0 h1:bs/cUb4lp1G5iImFFd3u5ixQzweKizoZJAwBNLR42lc=
google.golang.org/grpc v1.65.0/go.mod h1:WgYC2ypjlB0EiQi6wdKixMqukr6lBc0Vo+oOgjrM5ZQ=
google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
google.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=
google.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=
google.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=
google.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
google.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=
google.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=
google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
google.golang.org/protobuf v1.27.1/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
google.golang.org/protobuf v1.34.2 h1:6xV6lTsCfpGD21XK49h7MhtcApnLqkfYgPcdHftf6hg=
google.golang.org/protobuf v1.34.2/go.mod h1:qYOHts0dSfpeUzUFpOMr/WGzszTmLH+DiWniOlNbLDw=
gopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
gopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=
gopkg.in/go-playground/assert.v1 v1.2.1/go.mod h1:9RXL0bg/zibRAgZUYszZSwO/z8Y/a8bDuhia5mkpMnE=
gopkg.in/go-playground/validator.v8 v8.18.2/go.mod h1:RX2a/7Ha8BgOhfk7j780h4/u/RRjR0eouCJSH80/M2Y=
gopkg.in/inf.v0 v0.9.1 h1:73M5CoZyi3ZLMOyDlQh031Cx6N9NDJ2Vvfl76EDAgDc=
gopkg.in/inf.v0 v0.9.1/go.mod h1:cWUDdTG/fYaXco+Dcufb5Vnc6Gp2YChqWtbxRZE0mXw=
gopkg.in/ini.v1 v1.51.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
gopkg.in/ini.v1 v1.51.1/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=
gopkg.in/mgo.v2 v2.0.0-20180705113604-9856a29383ce/go.mod h1:yeKp02qBN3iKW1OzL3MGk2IdtZzaj7SFntXj72NppTA=
gopkg.in/natefinch/lumberjack.v2 v2.0.0 h1:1Lc07Kr7qY4U2YPouBjpCLxpiyxIVoxqXgkXLknAOE8=
gopkg.in/natefinch/lumberjack.v2 v2.0.0/go.mod h1:l0ndWWf7gzL7RNwBG7wST/UCcT4T24xpD6X8LsfU/+k=
gopkg.in/resty.v1 v1.12.0/go.mod h1:mDo4pnntr5jdWRML875a/NmxYqAlA73dVijT2AXvQQo=
gopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=
gopkg.in/yaml.v2 v2.0.0-20170812160011-eb3733d160e7/go.mod h1:JAlM8MvJe8wmxCU4Bli9HhUf9+ttbYbLASfIpnQbh74=
gopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.3/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.5/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=
gopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=
gopkg.in/yaml.v3 v3.0.0-20191120175047-4206685974f2/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190418001031-e561f6794a2a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
honnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=
k8s.io/apimachinery v0.28.6 h1:RsTeR4z6S07srPg6XYrwXpTJVMXsjPXn0ODakMytSW0=
k8s.io/apimachinery v0.28.6/go.mod h1:QFNX/kCl/EMT2WTSz8k4WLCv2XnkOLMaL8GAVRMdpsA=
rsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=
sigs.k8s.io/yaml v1.2.0/go.mod h1:yfXDCHCao9+ENCvLSE62v9VSji2MKu5jeNfTrofGhJc=
sigs.k8s.io/yaml v1.3.0 h1:a2VclLzOGrwOHDiV8EfBGhvjHvP46CtW5j6POvhYGGo=
sigs.k8s.io/yaml v1.3.0/go.mod h1:GeOyir5tyXNByN85N/dRIT9es5UQNerPYEKK56eTBm8=



---
File: /Makefile
---

# Licensed to the LF AI & Data foundation under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

GO		  ?= go
PWD 	  := $(shell pwd)
GOPATH	:= $(shell $(GO) env GOPATH)
SHELL 	:= /bin/bash
OBJPREFIX := "github.com/milvus-io/milvus/cmd/milvus/v2"

# TODO pass golangci-lint path
lint:
	@echo "Running lint checks..." 

unittest:
	@echo "Running unittests..."
	@(env bash $(PWD)/scripts/run_unittest.sh)

generate-mockery:
	@echo "Generating mockery Milvus service server"
	@../bin/mockery --srcpkg=github.com/milvus-io/milvus-proto/go-api/v2/milvuspb --name=MilvusServiceServer --filename=mock_milvus_server_test.go --output=milvusclient --outpkg=milvusclient --with-expecter 



---
File: /OWNERS
---

reviewers:
  - congqixia
  - ThreadDao

approvers:
  - maintainers




---
File: /README.md
---

# Go MilvusClient

[![license](https://img.shields.io/hexpm/l/plug.svg?color=green)](https://github.com/milvus-io/milvus/blob/master/LICENSE)
[![Go Reference](https://pkg.go.dev/badge/github.com/milvus-io/milvus/client/v2.svg)](https://pkg.go.dev/github.com/milvus-io/milvus/client/v2)

Go MilvusClient for [Milvus](https://github.com/milvus-io/milvus). To contribute code to this project, please read our [contribution guidelines](https://github.com/milvus-io/milvus/blob/master/CONTRIBUTING.md) first.


## Getting started

### Prerequisites

Go 1.21 or higher

### Install Milvus Go SDK

1. Use `go get` to install the latest version of the Milvus Go SDK and dependencies:

   ```shell
   go get -u github.com/milvus-io/milvus/client/v2
   ```

2. Include the Go MilvusClient in your application:

   ```go
    import "github.com/milvus-io/milvus/client/v2/milvusclient"

    //...other snippet ...
    ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	milvusAddr := "YOUR_MILVUS_ENDPOINT"

	cli, err := milvusclient.New(ctx, &milvusclient.ClientConfig{
		Address: milvusAddr,
	})
	if err != nil {
		// handle error
    }

    // Do your work with milvus client
    ```

### API Documentation

Refer to [https://milvus.io/api-reference/go/v2.5.x/About.md](https://milvus.io/api-reference/go/v2.5.x/About.md) for the Go SDK API documentation.

## Code format

The Go source code is formatted using gci & gofumpt. Please run `make lint-fix` before sumbit a PR.

